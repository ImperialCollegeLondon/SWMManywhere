{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SWMManywhere","text":"<p>This is the documentation for SWMManywhere. It is a software that lets you derive a synthetic urban drainage network anywhere in the world.</p>"},{"location":"#table-of-contents","title":"Table of contents","text":"<ul> <li>Home</li> <li>About</li> <li>Quickstart</li> <li>Guides:<ul> <li>Configuration file</li> <li>Parameters guide</li> <li>Graph functions</li> <li>Metrics guide</li> </ul> </li> <li>Notebooks:<ul> <li>Extended demo</li> <li>Real world demo</li> <li>Using custom data</li> </ul> </li> <li>Contributing</li> <li>API reference<ul> <li>SWMManywhere</li> <li>Graph utilities</li> <li>Geospatial utilities</li> <li>Metric utilities</li> <li>Logging</li> <li>Parameters</li> <li>FilePaths</li> <li>Post processing</li> <li>Preprocessing</li> <li>Config</li> </ul> </li> <li>Coverage report</li> </ul>"},{"location":"AUTHORS/","title":"Developers","text":"<ul> <li>Barnaby Dobson <code>b.dobson - at - imperial.ac.uk</code></li> <li>Taher Chegini</li> <li>Diego Alonso Alvarez</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socioeconomic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at <code>b.dobson -at- imperial.ac.ak</code>. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to <code>SWMManywhere</code>","text":"<p>Thank you for considering contributing to <code>SWMManywhere</code>.</p>"},{"location":"CONTRIBUTING/#bugs","title":"Bugs","text":"<p>Please create a new issue if you may have found a bug. Please describe the bug and instructions on recreating it (including OS and Python version). Label the issue with <code>bug</code>.</p>"},{"location":"CONTRIBUTING/#new-behaviour","title":"New behaviour","text":"<p>Our intention with <code>SWMManywhere</code> is that a high level of customisation to suit your needs may be achieved by adding new <code>graphfcns</code> or new <code>metrics</code>, see below. Other new behaviour may be tagged with <code>enhancement</code>, though please check existing issues to see if something similar already exists.</p>"},{"location":"CONTRIBUTING/#take-a-graph-give-a-graph-graphfcns","title":"Take a graph give a graph: <code>graphfcns</code>","text":"<p>All transformations that take place do so on graph functions; you can change the order in which these are executed and add new ones. If you want a <code>graphfcn</code> that does a new thing, please create an issue to discuss with the label <code>graphfcn</code>. If a single new <code>graphfcn</code> is not sufficient to capture the transformations that you'd like to apply, more may be needed. If this is the case, please first create an issue labelled with <code>enhancement</code> detailing the thing that you would like to capture, where we will discuss what <code>graphfcns</code> are needed, and use this issue to coordinate.</p>"},{"location":"CONTRIBUTING/#evaluate-against-real-data-with-metrics","title":"Evaluate against real data with: <code>metrics</code>","text":"<p>We have provided a large set of metrics against which a synthetic graph's performance may be evaluated if a real network is provided. If you want to create a new <code>metric</code>, please create an issue to discuss with the label <code>metric</code>.</p>"},{"location":"CONTRIBUTING/#installation-for-development","title":"Installation for development","text":"<p>To install <code>SWMManywhere</code> in development mode, first you will need a virtual environment. Here we use a <code>conda</code> environment which lets us use the version of python we want to use, but you can use any other tool you are familiar with. Just make sure you use a version of Python compatible with SWMManywhere.</p> <pre><code>conda create --name swmmanywhere python=3.10\nconda activate swmmanywhere\n</code></pre> <p>Once in the environment, you need to clone the <code>SWMManywhere</code> GitHub repository locally and move into the right folder. You will need <code>git</code> for that, installed either following the official instructions or with <code>conda install git</code>, if you use <code>conda</code>.</p> <pre><code>git clone https://github.com/ImperialCollegeLondon/SWMManywhere.git\ncd swmmanywhere\n</code></pre> <p>We use <code>pip-tools</code> to ensure consistency in the development process, ensuring all people contributing to <code>SWMManywhere</code> use the same versions for all the dependencies, which minimises the conflicts. To install the development dependencies and then <code>SWMManywhere</code> in development mode, run:</p> <pre><code>pip install -e .[dev,doc]\n</code></pre>"},{"location":"CONTRIBUTING/#quality-assurance-and-linting","title":"Quality assurance and linting","text":"<p><code>SWMManywhere</code> uses a collection of tools that ensure that a specific code style and formatting is followed throughout the software. The tools we use for that are <code>ruff</code>, <code>markdownlint</code>, <code>mypy</code>, <code>refurb</code>, <code>codespell</code>, <code>pyproject-fmt</code>. You do not need to run them manually - unless you want to - but rather they are run automatically every time you make a commit thanks to <code>pre-commit</code>. If you want to run them manually before committing, you can do so with:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p><code>pre-commit</code> should already have been installed when installing the <code>dev</code> dependencies, if you followed the instructions above, but you need to activate the hooks that <code>git</code> will run when making a commit. To do that just run:</p> <pre><code>pre-commit install\n</code></pre> <p>You can customise the checks that <code>ruff</code>, <code>mypy</code>, and <code>refurb</code> will make with the settings in <code>pyproject.toml</code>. For <code>markdownlint</code>, you need to edit the arguments included in the .<code>pre-commit-config.yaml</code> file.</p>"},{"location":"CONTRIBUTING/#testing-and-coverage","title":"Testing and coverage","text":"<p><code>SWMManywhere</code> uses <code>pytests</code> as testing suite. You can run tests by navigating to the folder and running:</p> <pre><code>pytest # run all tests\npytest tests/test_file.py # run a specific file's tests\n</code></pre> <p>By default the <code>tests/tests_prepare_data.py</code> does not test the actual downloads themselves (since this relies on external APIs actually working at the time of testing), however downloads can be enabled when testing:</p> <pre><code>pytest tests/tests_prepare_data.py -m downloads\n</code></pre> <p>You can check the coverage for these tests by running:</p> <pre><code>coverage run -m pytest\ncoverage report\n</code></pre> <p>And generate a new coverage html site for the documentation with</p> <pre><code>coverage html\n</code></pre>"},{"location":"CONTRIBUTING/#changing-dependencies","title":"Changing dependencies","text":"<p>As the development process moves forward, you may find you need to add a new dependency. Just add it to the relevant section of the <code>pyproject.toml</code> file.</p> <p>Read the <code>pip-tools</code> documentation for more information on the process.</p>"},{"location":"HISTORY/","title":"History","text":""},{"location":"HISTORY/#010-date","title":"0.1.0 (date)","text":"<ul> <li>First release goes here</li> </ul>"},{"location":"config_guide/","title":"Configuration file guide","text":"<p>The <code>config</code> file is the intended way for users to interact with SWMManywhere, enabling a variety of features to customise the synthesis process, which we will describe in this guide. You can view an example configuration file that contains entries for all settable attributes at <code>demo_config.yml</code> and the schema that must be followed at <code>schema.yml</code>.</p>"},{"location":"config_guide/#minimum-viable-configuration","title":"Minimum viable configuration","text":"<p>The minimum requirements for a user to provide are simply:</p> <ul> <li>a base directory,</li> <li>a project name,</li> <li>a bounding box that specifies the latitude and longitude (EPSG:4326) of the bottom left and upper right corners of the region within which to create the Urban Drainage Model (UDM).</li> </ul> <p>We can define a simple configuration <code>.yml</code> file here:</p> <pre><code>base_dir: /path/to/base/directory\nproject: my_first_swmm\nbbox: [1.52740,42.50524,1.54273,42.51259]\n</code></pre>"},{"location":"config_guide/#customising-your-synthetic-udm","title":"Customising your synthetic UDM","text":"<p>Unless you are exceptionally lucky, it is likely that you will want to change something about a UDM synthesised by SWMManywhere. There are three key tools inside the SWMManywhere <code>config</code> file that can be helpful to do this, described in this section.</p>"},{"location":"config_guide/#changing-parameters","title":"Changing parameters","text":"<p>Changing parameter values is by far the easiest way to change your derived network. You can view available parameters and determine which ones may help to fix what you are unhappy with, for example, if you feel that there are too many manholes, then you may want to increase <code>max_street_length</code> (see source code of <code>SubcatchmentDerivation</code>).</p> <p>To change parameters via the <code>config</code> file, we can use the <code>parameter_overrides</code> field:</p> <pre><code>parameter_overrides:\n  subcatchment_derivation:\n    max_street_length: 40\n</code></pre> <p>Note that we must provide the parameter group for the parameter that we are changing (<code>subcatchment_derivation</code> above).</p> <p>If you want to understand how parameters are implemented in more detail, and in particular if you are creating new behaviours and need to add your own parameters, see our parameter guide.</p> <p>As our SWMManywhere paper link preprint demonstrates, you can capture an enormously wide range of UDM behaviours through changing parameters. However, if your system is particularly unusual, or you are testing out new behaviours then you may need to adopt a more elaborate approach.</p>"},{"location":"config_guide/#customise-graphfcns","title":"Customise <code>graphfcns</code>","text":"<p>Graph functions are the way that operations are applied to create a synthetic UDM in SWMManywhere. You can read more about them in the graphfcns guide, but a primary feature of the <code>config</code> file is to provide a <code>graphfcn_list</code>. By default <code>graphfcn_list</code> is selected from <code>demo_config.yml</code>. Although we believe that the default list makes sense, you may instead provide your own <code>graphfcn_list</code>, this is essential if you plan to add a <code>graphfcn</code>.</p> <p>Sometimes, it doesn't matter how clever your functionality is, because your initial graph is missing something, in which case you will need to...</p>"},{"location":"config_guide/#change-starting_graph","title":"Change <code>starting_graph</code>","text":"<p>By default SWMManywhere uses Open Street Map (OSM) data to create a starting graph, to which subsequent <code>graphfcns</code> are applied to. A key limitation of SWMManywhere is that the plausibility of a synthetic pipe being placed in a given location requires links to exist in the original <code>starting_graph</code>. If you are in a location where the quality of OSM is questionable, or perhaps you have knowledge that some pipes exist in unusual locations, then you can provide the address to a custom graph with the <code>starting_graph</code> entry in the <code>config</code> file. Note, for information on the format that this graph should take, see <code>save_graph</code>.</p> <p>If the default workflow is missing something that isn't to do with parameters, functionality, or the starting graph, then it is possible you will require additional data sources beyond those that are provided by default...</p>"},{"location":"config_guide/#use-your-own-data","title":"Use your own data","text":"<p>A user may want to change some of the key data files that underpin SWMManywhere, such as the base <code>elevation</code> file (i.e., a DEM from NASADEM) if you have higher resolution data for your region. You can explore the default file structure of a SWMManywhere project at <code>FilePaths</code>, but a user may provide their own file paths via the config file through the <code>address_overrides</code> entry, for example:</p> <pre><code>address_overrides:\n  elevation: /new/path/to/elevation.tif\n</code></pre> <p>We provide a more extensive demo to illustrate this in using custom data</p>"},{"location":"config_guide/#evaluating-your-synthetic-udm","title":"Evaluating your synthetic UDM","text":"<p>If you are lucky enough to have a pre-existing UDM for your region, then you may instead be using SWMManywhere to explore uncertainties. If this is the case then it is likely that you will be evaluating how the synthesised UDM compare to the pre-existing ones. To do this, you will need to specify the pre-existing (or 'real') UDM file paths in the <code>config</code> file, and the performance metrics to be calculated.</p>"},{"location":"config_guide/#specifying-the-real-udm","title":"Specifying the 'real' UDM","text":"<p>In SWMManywhere, a pre-existing UDM is referred to as the 'real' model (although if you are using SWMManywhere you are presumably aware that describing any UDM as real is tenuous). To enable SWMManywhere to compare against a real model, we use the <code>real</code> entry of the <code>config</code> file, see the <code>real</code> entry in <code>demo_config.yml</code> for example. The path to a <code>subcatchments</code> geometry file, and a <code>graph</code> file (see <code>save_graph</code> for format) must be provided - however this is temporary and will be unnecessary following the fixing of this. The user can then provide either an <code>inp</code> path to the SWMM <code>.inp</code> model file, or if the file has already been run, directly to the <code>results</code> file. If a <code>results</code> file is provided this will always be used for metric calculation. If <code>results</code> is not provided but <code>inp</code> is, then SWMManywhere will run the <code>inp</code> model file provided. Currently the user must ensure precipitation timeseries are aligned and comparable for both the real and synthetic networks.</p> <p>Once you have some real simulations to compare against your synthetic ones, you must specify how to evaluate the synthetic model...</p>"},{"location":"config_guide/#performance-metrics","title":"Performance metrics","text":"<p>The SWMManywhere package comes with a wide variety of performance metrics that can be used to make this comparison, explained in the metrics guide. In the <code>config</code> file you can specify which metrics should be calculated under the <code>metric_list</code> entry. The <code>demo_config.yml</code> <code>metric_list</code> contains all metrics that come with SWMManywhere, although you may want to choose a subselection of these if you have a very large network (say &gt;5000 nodes) because some of the graph-based metrics can be slow to calculate (anything starting with <code>nc</code> or containing <code>betweenness</code>). You may also be unsatisfied with the built in metrics, in which case you can add your own, although these must be specified under <code>metric_list</code> for them to be calculated.</p>"},{"location":"graphfcns_guide/","title":"Graph functions guide","text":"<p>SWMManywhere works by starting with a graph of plausible pipe locations (typically the street network) and iteratively applying functions to transform that network gradually into a UDM. A graph function is actually a class, of type <code>BaseGraphFunction</code>, that can be called with a function that takes a graph (and some arguments) and returns an updated graph.</p>"},{"location":"graphfcns_guide/#using-graph-functions","title":"Using graph functions","text":"<p>Let's look at a graph function that is simply a wrapper for <code>networkx.to_undirected</code>:</p> Source code in <code>swmmanywhere/graphfcns/network_cleaning_graphfcns.py</code> <pre><code>@register_graphfcn\nclass to_undirected(BaseGraphFunction):\n    \"\"\"to_undirected class.\"\"\"\n\n    def __call__(self, G: nx.Graph, **kwargs) -&gt; nx.Graph:\n        \"\"\"Convert the graph to an undirected graph.\n\n        Args:\n            G (nx.Graph): A graph\n            **kwargs: Additional keyword arguments are ignored.\n\n        Returns:\n            G (nx.Graph): An undirected graph\n        \"\"\"\n        # Don't use osmnx.to_undirected! It enables multigraph if the geometries\n        # are different, but we have already saved the street cover so don't\n        # want this!\n        return G.to_undirected()\n</code></pre> <p>We can see that this graph function is a class that can be called with a graph and returns a graph. Note that the class has been registered with <code>@register_graphfcn</code>.</p>"},{"location":"graphfcns_guide/#registered-graph-functions","title":"Registered graph functions","text":"<p>The <code>GraphFunctionRegistry</code> is a dictionary called <code>graphfcns</code> that contains all registered graph functions to be called from one place.</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.graph_utilities import graphfcns\n&gt;&gt;&gt; print(graphfcns.keys())\ndict_keys(['assign_id', 'remove_parallel_edges', 'remove_non_pipe_allowable_links', \n'calculate_streetcover', 'double_directed', 'to_undirected', 'split_long_edges', \n'merge_street_nodes', 'fix_geometries', 'clip_to_catchments', \n'calculate_contributing_area', 'set_elevation', 'set_surface_slope',\n'set_chahinian_slope', 'set_chahinian_angle', 'calculate_weights', 'identify_outlets',\n'derive_topology', 'pipe_by_pipe'])\n</code></pre> <p>We will later demonstrate how to add a new graph function to the registry.</p>"},{"location":"graphfcns_guide/#arguments","title":"Arguments","text":"<p>In the previous example, we saw that, in addition to a graph, the function takes <code>**kwargs</code>, which are ignored. While this graph function does not require any information that is not contained within the graph, most require parameters or file path information to be completed. A graph function can receive a <code>FilePaths</code> object or any number of parameter categories, which we will briefly explain below. A full explanation of these is outside scope of this guide, but for now you can view the <code>parameters</code> and <code>FilePaths</code> APIs.</p> <p>We can see an example of using a parameter category with this graph function:</p> Source code in <code>swmmanywhere/graphfcns/network_cleaning_graphfcns.py</code> <pre><code>@register_graphfcn\nclass remove_non_pipe_allowable_links(BaseGraphFunction):\n    \"\"\"remove_non_pipe_allowable_links class.\"\"\"\n\n    def __call__(\n        self, G: nx.Graph, topology_derivation: parameters.TopologyDerivation, **kwargs\n    ) -&gt; nx.Graph:\n        \"\"\"Remove non-pipe allowable links.\n\n        This function removes links that are not allowable for pipes. The non-\n        allowable links are specified in the `omit_edges` attribute of the\n        topology_derivation parameter. There two cases handled:\n\n        1. The `highway` property of the edge. In `osmnx`, `highway` is a category\n            that contains the road type, e.g., motorway, trunk, primary. If the\n            edge contains a value in the `highway` property that is in `omit_edges`,\n            the edge is removed.\n\n        2. Any other properties of the edge that are in `omit_edges`. If the\n            property is not null in the edge data, the edge is removed. e.g.,\n            if `bridge` is in `omit_edges` and the `bridge` entry of the edge\n            is NULL, then the edge is retained, if it is something like 'yes',\n            or 'viaduct' then the edge is removed.\n\n        Args:\n            G (nx.Graph): A graph\n            topology_derivation (parameters.TopologyDerivation): A TopologyDerivation\n                parameter object\n            **kwargs: Additional keyword arguments are ignored.\n\n        Returns:\n            G (nx.Graph): A graph\n        \"\"\"\n        edges_to_remove = set()\n        for u, v, keys, data in G.edges(data=True, keys=True):\n            for omit in topology_derivation.omit_edges:\n                if data.get(\"highway\", None) == omit:\n                    # Check whether the 'highway' property is 'omit'\n                    edges_to_remove.add((u, v, keys))\n                elif data.get(omit, None):\n                    # Check whether the 'omit' property of edge is not None\n                    edges_to_remove.add((u, v, keys))\n        for edges in edges_to_remove:\n            G.remove_edge(*edges)\n        return G\n</code></pre> <p>We can see that <code>remove_non_pipe_allowable_links</code> uses the <code>omit_edges</code> parameter, which is contained in the <code>parameters.TopologyDerivation</code> object that the graph function takes as an argument. Although we recommend changing parameter values in SWMManywhere with the configuration file we will give an example below explain how a parameter can be changed 'manually' to better understand what is happening at the graph function level.</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.examples.data import demo_graph as G\n&gt;&gt;&gt; from swmmanywhere.graph_utilities import graphfcns\n&gt;&gt;&gt; from swmmanywhere.parameters import TopologyDerivation\n&gt;&gt;&gt; G_ = graphfcns.remove_non_pipe_allowable_links(G, TopologyDerivation())\n&gt;&gt;&gt; print(f\"{len(G.edges) - len(G_.edges)} edges removed\")\n2 edges removed\n&gt;&gt;&gt; G_ = graphfcns.remove_non_pipe_allowable_links(G, \n        TopologyDerivation(omit_edges=[\"primary\", \"bridge\"])\n    )\n&gt;&gt;&gt; print(f\"{len(G.edges) - len(G_.edges)} edges removed\")\n16 edges removed\n</code></pre> <p>We can see that, by changing the parameter to remove more edge types, the graph function produced a different graph.</p>"},{"location":"graphfcns_guide/#lists-of-graph-functions","title":"Lists of graph functions","text":"<p>Graph functions are intended to be applied in a sequence, gradually transforming the graph. SWMManywhere provides a function to do this called <code>iterate_graphfcns</code>.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.examples.data import demo_graph as G\n&gt;&gt;&gt; from swmmanywhere.graph_utilities import iterate_graphfcns\n&gt;&gt;&gt; print(len(G.edges))\n22\n&gt;&gt;&gt; G = iterate_graphfcns(G, [\"assign_id\", \"remove_non_pipe_allowable_links\"])\n&gt;&gt;&gt; print(len(G.edges))\n20\n</code></pre> <p>We have applied a list of two graph functions to the graph <code>G</code>, which has made some changes (in this case checking the edge <code>id</code> and removing links as above).</p> <p>In the configuration file we can specify the list of graph functions to be applied as a <code>graphfcn_list</code>.</p> <p>In this example we do not provide <code>parameters.TopologyDerivation</code> argument, even though it is needed by <code>remove_non_pipe_allowable_links</code>. If parameters are not provided, <code>iterate_graphfcns</code> uses the default values for all <code>parameters</code>.</p>"},{"location":"graphfcns_guide/#validating-graph-functions","title":"Validating graph functions","text":"<p>Furthermore, this <code>graphfcn_list</code> also provides opportunities for validation. For example, see the following graph function:</p> Source code in <code>swmmanywhere/graphfcns/topology_graphfcns.py</code> <pre><code>@register_graphfcn\nclass set_surface_slope(\n    BaseGraphFunction,\n    required_node_attributes=[\"surface_elevation\"],\n    adds_edge_attributes=[\"surface_slope\"],\n):\n    \"\"\"set_surface_slope class.\"\"\"\n\n    def __call__(self, G: nx.Graph, **kwargs) -&gt; nx.Graph:\n        \"\"\"Set the surface slope for each edge.\n\n        This function sets the surface slope for each edge. The surface slope is\n        calculated from the elevation data.\n\n        Args:\n            G (nx.Graph): A graph\n            **kwargs: Additional keyword arguments are ignored.\n\n        Returns:\n            G (nx.Graph): A graph\n        \"\"\"\n        G = G.copy()\n        # Compute the slope for each edge\n        slope_dict = {\n            (u, v, k): (\n                G.nodes[u][\"surface_elevation\"] - G.nodes[v][\"surface_elevation\"]\n            )\n            / d[\"length\"]\n            for u, v, k, d in G.edges(data=True, keys=True)\n        }\n\n        # Set the 'surface_slope' attribute for all edges\n        nx.set_edge_attributes(G, slope_dict, \"surface_slope\")\n        return G\n</code></pre> <p>Critically, we can see that the <code>set_surface_slope</code> graph function has a parameter <code>required_node_attributes</code> (not shown above but see also <code>required_edge_attributes</code>), which specify that the node parameters <code>surface_elevation</code> are required to perform the graph function. Although providing this information does not guarantee that the graph function will behave as intended, if it is not provided then the graph function is guaranteed to fail. To check the feasibility of a set of graph functions a-priori, the parameter <code>adds_edge_attributes</code> (not shown above but see also <code>adds_node_attributes</code>), can be used to specify what, if any, parameters are added to the graph by the graph function.</p> <p>Let us inspect the <code>set_elevation</code> graph function: </p> Source code in <code>swmmanywhere/graphfcns/topology_graphfcns.py</code> <pre><code>@register_graphfcn\nclass set_elevation(\n    BaseGraphFunction,\n    required_node_attributes=[\"x\", \"y\"],\n    adds_node_attributes=[\"surface_elevation\"],\n):\n    \"\"\"set_elevation class.\"\"\"\n\n    def __call__(self, G: nx.Graph, addresses: FilePaths, **kwargs) -&gt; nx.Graph:\n        \"\"\"Set the elevation for each node.\n\n        This function sets the elevation for each node. The elevation is\n        calculated from the elevation data.\n\n        Args:\n            G (nx.Graph): A graph\n            addresses (FilePaths): An FilePaths parameter object\n            **kwargs: Additional keyword arguments are ignored.\n\n        Returns:\n            G (nx.Graph): A graph\n        \"\"\"\n        G = G.copy()\n        x = [d[\"x\"] for x, d in G.nodes(data=True)]\n        y = [d[\"y\"] for x, d in G.nodes(data=True)]\n        elevations = go.interpolate_points_on_raster(\n            x, y, addresses.bbox_paths.elevation\n        )\n        elevations_dict = {id_: elev for id_, elev in zip(G.nodes, elevations)}\n        nx.set_node_attributes(G, elevations_dict, \"surface_elevation\")\n        return G\n</code></pre> <p>We can see that <code>set_elevation</code> adds the node attribute <code>surface_elevation</code>, which is required for <code>set_surface_slope</code>. The default order of <code>graphfcn_list</code> has these graph functions in the appropriate order, but we can demonstrate the automatic validation in SWMManywhere by switching their order. We will copy the minimum viable config template and use a short <code>graphfcn_list</code> that places the <code>set_surface_slope</code> graph function before <code>set_elevation</code>.</p> <pre><code>base_dir: /path/to/base/directory\nproject: my_first_swmm\nbbox: [1.52740,42.50524,1.54273,42.51259]\ngraphfcn_list:\n  - set_surface_slope\n  - set_elevation\n</code></pre> <p>If we try to run this with:</p> <pre><code>python -m swmmanywhere --config_path=/path/to/file.yml\n</code></pre> <p>Before any graph functions are executed, we will receive the error message:</p> <pre><code>Traceback (most recent call last):\n  File \"&lt;frozen runpy&gt;\", line 198, in _run_module_as_main\n  ...\nValueError: Graphfcn set_surface_slope requires node attributes\n                ['surface_elevation']\n</code></pre>"},{"location":"graphfcns_guide/#add-a-new-graph-function","title":"Add a new graph function","text":"<p>Adding a custom graph function can be done by creating a graph function in the appropriate style, see below for example to create a new graph function and then specifying to use it with the <code>config</code> file.</p>"},{"location":"graphfcns_guide/#write-the-graph-function","title":"Write the graph function","text":"<p>You create a new module that can contain multiple graph functions. See below as a template of that module.</p> <pre><code>from __future__ import annotations\n\nimport networkx as nx\n\nfrom swmmanywhere.graph_utilities import BaseGraphFunction, register_graphfcn\n\n\n@register_graphfcn\nclass new_graphfcn(BaseGraphFunction, adds_edge_attributes=[\"new_attrib\"]):\n    \"\"\"New graphfcn class.\"\"\"\n\n    def __call__(self, G: nx.graph, **kwargs) -&gt; nx.Graph:\n        \"\"\"Adds new_attrib to the graph.\"\"\"\n        G = G.copy()\n        nx.set_edge_attributes(G, \"new_value\", \"new_attrib\")\n        return G\n</code></pre>"},{"location":"graphfcns_guide/#adjust-config-file","title":"Adjust config file","text":"<p>We will add the required lines to the minimum viable config template.</p> <pre><code>base_dir: /path/to/base/directory\nproject: my_first_swmm\nbbox: [1.52740,42.50524,1.54273,42.51259]\ncustom_graphfcn_modules: \n  - /path/to/custom_graphfcns.py\ngraphfcn_list: \n  - assign_id\n  - fix_geometries\n  - remove_non_pipe_allowable_links\n  - calculate_streetcover\n  - remove_parallel_edges\n  - to_undirected\n  - split_long_edges\n  - merge_street_nodes\n  - assign_id\n  - clip_to_catchments\n  - calculate_contributing_area\n  - set_elevation\n  - double_directed\n  - fix_geometries\n  - set_surface_slope\n  - set_chahinian_slope\n  - set_chahinian_angle\n  - calculate_weights\n  - identify_outlets\n  - derive_topology\n  - pipe_by_pipe\n  - fix_geometries\n  - assign_id\n  - new_graphfcn\n</code></pre> <p>We can see that we now provide the <code>graphfcn_list</code> with <code>new_graphfcn</code> in the list. This list (except for <code>new_graphfcn</code>) is reproduced from the <code>demo_config.yml</code>. Any number of new graph functions can be inserted at any points in the <code>graphfcn_list</code>. If deviating from the list in <code>demo_config.yml</code>, which provides the default <code>graphfcn_list</code>, then an entire (new) list must be provided.</p> <p>And we provide the path to the <code>custom_graphfcns.py</code> module that contains our <code>new_graphfcn</code> under the <code>custom_graphfcn_module</code> entry.</p>"},{"location":"metrics_guide/","title":"Metrics guide","text":"<p>If you have real data to compare against your synthesised UDM, you can take advantage of the multiple <code>metrics</code> implemented in SWMManywhere. Metrics are used to compare the similarity of either the synthesised UDM with the real, or the accompanying SWMM simulation results. Thus, a <code>metric</code> is a function that can take a variety of arguments and returns the metric value.</p>"},{"location":"metrics_guide/#using-metrics","title":"Using metrics","text":"<p>Let's look at a metric that is simply a wrapper for <code>netcomp.deltacon0</code>:</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef nc_deltacon0(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n    return nc_compare(synthetic_G, real_G, \"deltacon0\", eps=1e-10)\n</code></pre> <p>We can see that this metric requires the synthesised and real graphs as arguments, that is because it is a metric to compare the similarity of two graphs. Note that the function has been registered with <code>@metrics.register</code>.</p>"},{"location":"metrics_guide/#registered-metrics","title":"Registered metrics","text":"<p>The <code>MetricRegistry</code> is a dictionary subclass called <code>metrics</code> that contains all registered metrics to be called from one place.</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.metric_utilities import metrics\n&gt;&gt;&gt; print(metrics.keys())\ndict_keys(['outfall_nse_flow', 'outfall_kge_flow', 'outfall_relerror_flow',\n'outfall_relerror_length', 'outfall_relerror_npipes', 'outfall_relerror_nmanholes',\n'outfall_relerror_diameter', 'outfall_nse_flooding', 'outfall_kge_flooding',\n'outfall_relerror_flooding', 'grid_nse_flooding', 'grid_kge_flooding',\n'grid_relerror_flooding', 'subcatchment_nse_flooding',\n'subcatchment_kge_flooding', 'subcatchment_relerror_flooding', 'nc_deltacon0',\n'nc_laplacian_dist', 'nc_laplacian_norm_dist', 'nc_adjacency_dist',\n'nc_vertex_edge_distance', 'nc_resistance_distance', 'bias_flood_depth',\n'kstest_edge_betweenness', 'kstest_betweenness', 'outfall_kstest_diameters'])\n</code></pre> <p>We will later demonstrate how to add a new metric to the registry.</p>"},{"location":"metrics_guide/#arguments","title":"Arguments","text":"<p>In the previous example, we saw that, in addition to the synthesised and real graphs, the function takes <code>**kwargs</code>, which are ignored. While <code>nc_deltacon0</code> only requires <code>real_G</code> and <code>synthesised_G</code> to be calculated, any <code>metric</code> has access to a range of arguments for calculation:</p> <ul> <li>the synthesised and real graphs (<code>real_G</code> and <code>synthesised_G</code>),</li> <li>the synthesised and real simulation results (<code>real_results</code> and <code>synthesised_results</code>),</li> <li>the synthesised and real sub-catchments (<code>real_subs</code> and <code>synthesised_subs</code>),</li> <li>the <code>MetricEvaluation</code> parameters category.</li> </ul> <p>For example, see the following metric</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef outfall_kstest_diameters(\n    real_G: nx.Graph,\n    synthetic_G: nx.Graph,\n    real_results: pd.DataFrame,\n    real_subs: gpd.GeoDataFrame,\n    **kwargs,\n) -&gt; float:\n    \"\"\"Outfall KStest diameters.\n\n    Calculate the Kolmogorov-Smirnov statistic of the diameters in the subgraph\n    that drains to the dominant outfall node. The dominant outfall node of the\n    'real' network is calculated by dominant_outfall, while the dominant outfall\n    node of the 'synthetic' network is calculated by best_outfall_match.\n    \"\"\"\n    # Identify synthetic and real outfall arcs\n    sg_syn, _ = best_outfall_match(synthetic_G, real_subs)\n\n    if len(sg_syn.nodes) == 0:\n        # No overlap exists\n        return np.inf\n\n    sg_real, _ = dominant_outfall(real_G, real_results)\n\n    # Extract the diameters\n    syn_diameters = nx.get_edge_attributes(sg_syn, \"diameter\")\n    real_diameters = nx.get_edge_attributes(sg_real, \"diameter\")\n    return stats.ks_2samp(\n        list(syn_diameters.values()), list(real_diameters.values())\n    ).statistic\n</code></pre> <p>We can see that this metric also requires the real results (<code>real_results</code>) and real subcatchments (<code>real_subs</code>) to be evaluated, which are passed as arguments.</p>"},{"location":"metrics_guide/#lists-of-metrics","title":"Lists of metrics","text":"<p>Metrics are intended to be applied as part of a list, <code>metric_list</code> with the SWMManywhere function <code>iterate_metrics</code>.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.examples.data import demo_graph as G\n&gt;&gt;&gt; from swmmanywhere.metric_utilities import iterate_metrics\n&gt;&gt;&gt; iterate_metrics(\n...     real_G = G,\n...     synthetic_G = G, \n...     metric_list = ['nc_deltacon0','nc_resistance_distance']\n... )\n{'nc_deltacon0': 0.0, 'nc_resistance_distance': 0.0}\n</code></pre> <p>In this example only graph comparison metrics are included in <code>metric_list</code>, and so we only need to provide <code>synthesised_G</code>, <code>real_G</code> and <code>metric_list</code>. We see that the metrics have returned <code>0.0</code>, because the two graphs are identical.</p> <p>In the configuration file we can specify the list of metrics to be applied as a <code>metric_list</code>. By default this list will be populated from <code>demo_config.yml</code>.</p>"},{"location":"metrics_guide/#add-a-new-metric","title":"Add a new metric","text":"<p>Adding a custom metric can be done by creating a metric in the appropriate style, see below for example to create a new metric and then specifying to use it with the <code>config</code> file</p>"},{"location":"metrics_guide/#write-the-metric","title":"Write the metric","text":"<p>You create a new module that can contain multiple metrics. See below as a template of that module.</p> <pre><code>from __future__ import annotations\n\nimport networkx as nx\n\nfrom swmmanywhere.metric_utilities import metrics\n\n\n@metrics.register\ndef new_metric(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"New metric function.\"\"\"\n    return len(synthetic_G.edges) / len(real_G.edges)\n</code></pre>"},{"location":"metrics_guide/#adjust-config-file","title":"Adjust config file","text":"<p>We will add the required lines to the minimum viable config template.</p> <pre><code>base_dir: /path/to/base/directory\nproject: my_first_swmm\nbbox: [1.52740,42.50524,1.54273,42.51259]\nreal:\n  inp: /path/to/real/model.inp\n  graph: /path/to/real/graph.json\n  subcatchments: /path/to/real/subcatchments.geojson\n  results: null\ncustom_metric_modules: /path/to/custom_metrics.py\nmetric_list: \n  - new_metric\n</code></pre> <p>To enable metrics to be calculated we must provide information on the <code>real</code> UDM (reproduced from the <code>demo_config.yml</code> ).</p> <p>We can see that we now provide the <code>metric_list</code> with <code>new_metric</code> in the list. Any number of custom metrics may be provided across one or multiple modules. Only the metrics specified in <code>metric_list</code> will be calculated, use the metric registry to identify allowable metrics.</p> <p>And we provide the path to the <code>custom_metrics.py</code> module that contains our <code>new_metric</code> under the <code>custom_metric_modules</code> entry.</p>"},{"location":"metrics_guide/#generalised-behaviour-of-metrics","title":"Generalised behaviour of metrics","text":"<p>Because of the large number of potential metrics that can plausibly be calculated, owing to the wide number of variations that might be applied, a combination of approaches are used to streamline metric creation.</p>"},{"location":"metrics_guide/#metric-factory","title":"Metric factory","text":"<p>Metrics can be created as self-contained functions, as with the example earlier. However, most metrics are created with the <code>metric_factory</code>. This is a function that takes a metric as a <code>str</code> which contains the metric's <code>&lt;scale&gt;_&lt;coefficient&gt;_&lt;variable&gt;</code>. Coefficients and scales are explained below, while the <code>variable</code> is simply the name of the variable (whether timeseries or graph property) to be calculated. Let us create a metric with <code>metric_factory</code>:</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.metric_utilities import metric_factory\n&gt;&gt;&gt; metric_factory('outfall_nse_flow')\n&lt;function metric_factory.&lt;locals&gt;.new_metric at 0x000001EECEA7C220&gt;\n</code></pre> <p>We have created a function that is a valid metric, it calculates the Nash-Sutcliffe Efficiency (<code>nse</code>) value for <code>flow</code> timeseries at <code>outlet</code> scale. Note that creating the metric with the <code>metric_factory</code> does not automatically add it to the registry.</p> <p>We do not currently support adding new coefficient or scales via the configuration file. Thus, the following sections coefficients and scales will explain how to manually accommodate custom behaviour.</p>"},{"location":"metrics_guide/#coefficients","title":"Coefficients","text":"<p>The coefficient portion of a metric is the equation that is applied to two arrays. See for example the <code>nse</code>:</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_coef\ndef nse(y: np.ndarray, yhat: np.ndarray) -&gt; float:\n    r\"\"\"Calculate Nash-Sutcliffe efficiency (NSE).\n\n    Calculate the Nash-Sutcliffe efficiency (NSE):\n\n    $$\n    NSE = 1 - \\frac{\\sum_{i=1}^{n} (Q_{obs,i} - Q_{sim,i})^2}\n                   {\\sum_{i=1}^{n} (Q_{obs,i} - \\overline{Q}_{obs})^2}\n    $$\n\n    where:\n\n    - $Q_{obs,i}$ is the observed value at time $i$,\n    - $Q_{sim,i}$ is the simulated value at time $i$,\n    - $\\overline{Q}_{obs}$ is the mean observed value over the simulation period,\n    - $n$ is the number of time steps in the simulation period.\n\n    Args:\n        y (np.array): Observed data array.\n        yhat (np.array): Simulated data array.\n\n    Returns:\n        float: The NSE value.\n    \"\"\"\n    if np.std(y) == 0:\n        return np.inf\n    return 1 - np.sum(np.square(y - yhat)) / np.sum(np.square(y - np.mean(y)))\n</code></pre> <p>Coefficients are stored in a registry which is a dictionary containing all registered coefficients:</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.metric_utilities import coef_registry\n&gt;&gt;&gt; print(coef_registry.keys())\ndict_keys(['relerror', 'nse', 'kge'])\n</code></pre> <p>We can see here the registered coefficients. Thus, the <code>coefficient</code> portion of a string being passed to <code>metric_factory</code> must take one of these values.</p> <p>To register a new coefficient, we can use <code>register_coef</code>, and we can then use it in <code>metric_factory</code> to create a metric. Since this new metric is not included in <code>metrics</code> we can also register that.</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.metric_utilities import (\n...     register_coef, \n...     coef_registry,\n...     metric_factory,\n...     metrics\n... )\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; metric_factory('outfall_rmse_flow') # Try creating the metric\nTraceback (most recent call last):\n    ...\nKeyError: 'rmse'\n&gt;&gt;&gt; def rmse(y: np.array, yhat: np.array): np.sqrt(np.mean(np.pow(y-yhat,2)))\n... \n&gt;&gt;&gt; register_coef(rmse) # Register new coefficient\n&lt;function rmse at 0x000001DC38ABC540&gt;\n&gt;&gt;&gt; print(coef_registry.keys())\ndict_keys(['relerror', 'nse', 'kge', 'rmse'])\n&gt;&gt;&gt; metrics.register(metric_factory('outfall_rmse_flow')) # Create and register new metric\n&lt;function metric_factory.&lt;locals&gt;.new_metric at 0x00000227D219E020&gt;\n&gt;&gt;&gt; 'outfall_rmse_flow' in metrics # Check that the metric is available for use\nTrue\n</code></pre>"},{"location":"metrics_guide/#scales","title":"Scales","text":"<p>SWMManywhere supports a variety of spatial scales for which metrics may be calculated. As with coefficients, these are stored in a registry.</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.metric_utilities import scale_registry\n&gt;&gt;&gt; print(scale_registry.keys())\ndict_keys(['subcatchment', 'grid', 'outfall'])\n</code></pre> <p>For example, <code>subcatchment</code> aligns <code>real</code> and <code>synthesised</code> subcatchments together and calculates the coefficient for each subcatchment (returning the median coefficient value over all matched subcatchments).</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_scale\ndef subcatchment(\n    synthetic_results: pd.DataFrame,\n    synthetic_subs: gpd.GeoDataFrame,\n    synthetic_G: nx.Graph,\n    real_results: pd.DataFrame,\n    real_subs: gpd.GeoDataFrame,\n    real_G: nx.Graph,\n    metric_evaluation: MetricEvaluation,\n    var: str,\n    coef_func: Callable,\n):\n    \"\"\"Subcatchment scale metric.\n\n    Calculate the coefficient (coef_func) of a variable over time for aggregated\n    to real subcatchment scale. The metric produced is the median coef_func\n    across all subcatchments.\n\n    Args:\n        synthetic_results (pd.DataFrame): The synthetic results.\n        synthetic_subs (gpd.GeoDataFrame): The synthetic subcatchments.\n        synthetic_G (nx.Graph): The synthetic graph.\n        real_results (pd.DataFrame): The real results.\n        real_subs (gpd.GeoDataFrame): The real subcatchments.\n        real_G (nx.Graph): The real graph.\n        metric_evaluation (MetricEvaluation): The metric evaluation parameters.\n        var (str): The variable to calculate the coefficient for.\n        coef_func (Callable): The coefficient to calculate.\n\n    Returns:\n        float: The median coef_func value.\n    \"\"\"\n    results = align_by_shape(\n        var,\n        synthetic_results=synthetic_results,\n        real_results=real_results,\n        shapes=real_subs,\n        synthetic_G=synthetic_G,\n        real_G=real_G,\n    )\n\n    return median_coef_by_group(results, \"sub_id\", coef_func=coef_func)\n</code></pre> <p>You will have to read the API to understand the differences between scales. However, custom scales may be created in much the same way as custom coefficients, albeit with more arguments required and more complexity for the function to interpret different argument values.</p>"},{"location":"metrics_guide/#restrictions","title":"Restrictions","text":"<p>Because of the complexity in interpretation, a key element of the <code>metric_factory</code> is restrictions on certain combinations of scales/coefficients/variables.</p> <p>For example, conceptually it makes no sense to apply the <code>nse</code> coefficient to the <code>npipes</code> variable - as <code>nse</code> is used to compare timeseries while <code>npipes</code> is a description of the designed UDM.</p> <pre><code>&gt;&gt;&gt; from swmmanywhere.metric_utilities import metric_factory\n&gt;&gt;&gt; metric_factory('outfall_nse_npipes')\nTraceback (most recent call last):\n    ... , in restriction_on_metric\n    raise ValueError(f\"Variable {variable} only valid with relerror metric\")\nValueError: Variable npipes only valid with relerror metric\n</code></pre> <p>Restrictions are stored in a register as with coefficients and scales, and we can see that the restriction triggered above was the <code>restriction_on_metric</code>:</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_restriction\ndef restriction_on_metric(scale: str, metric: str, variable: str):\n    \"\"\"Restriction on metric.\n\n    Restrict the design variables to use 'relerror' only.\n\n    Args:\n        scale (str): The scale of the metric.\n        metric (str): The metric.\n        variable (str): The variable.\n    \"\"\"\n    if variable in (\"length\", \"nmanholes\", \"npipes\") and metric != \"relerror\":\n        raise ValueError(f\"Variable {variable} only valid with relerror metric\")\n</code></pre> <p>Custom restrictions can be added as with coefficients and scales.</p>"},{"location":"parameters_guide/","title":"Parameters guide","text":"<p>SWMManywhere is a deliberately highly parameterised workflow, with the goal of enabling users to create a diverse range of UDMs. This guide is to explain the logic of the implemented parameters and how to customise them, as what each parameter does is highly specific to the <code>graphfcn</code> that uses it. Instead, to understand specific parameter purposes, you can view all available parameters at the API.</p>"},{"location":"parameters_guide/#using-parameters","title":"Using parameters","text":"<p>Let's look at a parameter group, which is a group of parameters related to identifying outfall locations.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>@register_parameter_group(name=\"outfall_derivation\")\nclass OutfallDerivation(BaseModel):\n    \"\"\"Parameters for outfall derivation.\"\"\"\n\n    method: str = Field(\n        default=\"separate\",\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"\"\"Method to derive outfall locations, \n            can be 'separate' or 'withtopo'.\"\"\",\n    )\n\n    river_buffer_distance: float = Field(\n        default=150.0,\n        ge=10.0,\n        le=500.0,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Buffer distance to link rivers to streets.\",\n    )\n\n    outfall_length: float = Field(\n        default=40.0,\n        ge=0.0,\n        le=600.0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Weight to discourage street drainage into river buffers.\",\n    )\n</code></pre> <p>We can see here three related parameters and relevant metadata, grouped together in a <code>pydantic.BaseModel</code> object. Parameters in SWMManywhere are grouped together because <code>graphfcns</code> that need one of them tend to need the others. Let's look at <code>identify_outfalls</code>, which needs these parameters.</p> Source code in <code>swmmanywhere/graphfcns/outfall_graphfcns.py</code> <pre><code>@register_graphfcn\nclass identify_outfalls(\n    BaseGraphFunction,\n    required_edge_attributes=[\"length\", \"edge_type\"],\n    required_node_attributes=[\"x\", \"y\", \"surface_elevation\"],\n):\n    \"\"\"identify_outfalls class.\"\"\"\n\n    def __call__(\n        self, G: nx.Graph, outfall_derivation: parameters.OutfallDerivation, **kwargs\n    ) -&gt; nx.Graph:\n        \"\"\"Identify outfalls in a combined river-street graph.\n\n        This function identifies outfalls in a combined river-street graph. An\n        outfall is a node that is connected to a river and a street. Each street\n        node is paired with the nearest river node provided that it is within\n        a distance of outfall_derivation.river_buffer_distance - this provides a\n        large set of plausible outfalls. If there are no plausible outfalls for an\n        entire subgraph, then a dummy river node is created and the lowest\n        elevation node is paired with it. Any street-&gt;river/outfall link is given\n        a `weight` and `length` of outfall_derivation.outfall_length, this is to\n        ensure some penalty on the total number of outfalls selected.\n\n        Two methods are available for determining which plausible outfalls to\n        retain:\n\n        - `withtopo`: all plausible outfalls are retained, connected to a single\n        'waste' node and assumed to be later identified as part of the\n        `derive_topology` graphfcn.\n\n        - `separate`: the retained outfalls are those that are selected as part\n        of the minimum spanning tree (MST) of the combined street-river graph.\n        This method can be temporamental because the MST is undirected, because\n        rivers are inherently directed unusual outfall locations may be retained.\n\n        Args:\n            G (nx.Graph): A graph\n            outfall_derivation (parameters.OutfallDerivation): An OutfallDerivation\n                parameter object\n            **kwargs: Additional keyword arguments are ignored.\n\n        Returns:\n            G (nx.Graph): A graph\n        \"\"\"\n        G = G.copy()\n\n        river_points, street_points = _get_points(G)\n\n        G_ = _pair_rivers(\n            G,\n            river_points,\n            street_points,\n            outfall_derivation.river_buffer_distance,\n            outfall_derivation.outfall_length,\n        )\n\n        # Set the length of the river edges to 0 - from a design perspective\n        # once water is in the river we don't care about the length - since it\n        # costs nothing\n        for _, _, d in G_.edges(data=True):\n            if d[\"edge_type\"] == \"river\":\n                d[\"length\"] = 0\n                d[\"weight\"] = 0\n\n        # Add edges from the river nodes to a waste node\n        G_ = _root_nodes(G_)\n\n        if outfall_derivation.method == \"withtopo\":\n            # The outfalls can be derived as part of the shortest path calculations\n            return G_\n        elif outfall_derivation.method == \"separate\":\n            return _connect_mst_outfalls(G_, G)\n        else:\n            raise ValueError(f\"Unknown method {outfall_derivation.method}\")\n</code></pre> <p>When calling <code>iterate_graphfcns</code>, for more information see lists of graphfcns, SWMManywhere will automatically provide any parameters that have been registered to any graphfcn.</p>"},{"location":"parameters_guide/#registering-parameters","title":"Registering parameters","text":"<p>When you create a new parameter, it will need to belong to an existing or new parameter group.</p>"},{"location":"parameters_guide/#creating-a-new-parameter-groups","title":"Creating a new parameter group(s)","text":"<p>You create a new module(s) that can contain multiple parameter groups. See below as a template of such amodule.</p> <pre><code>from __future__ import annotations\n\nfrom swmmanywhere import parameters\n\n\n@parameters.register_parameter_group(name=\"new_params\")\nclass new_params(parameters.BaseModel):\n    \"\"\"New parameters.\"\"\"\n\n    new_param: int = parameters.Field(\n        default=1,\n        ge=0,\n        le=10,\n        unit=\"-\",\n        description=\"A new parameter.\",\n    )\n</code></pre>"},{"location":"parameters_guide/#adjust-config-file","title":"Adjust config file","text":"<p>We will add the required lines to the minimum viable config template.</p> <pre><code>base_dir: /path/to/base/directory\nproject: my_first_swmm\nbbox: [1.52740,42.50524,1.54273,42.51259]\ncustom_parameter_modules: \n  - /path/to/custom_parameters.py\n</code></pre> <p>Now when we run our <code>config</code> file, these parameters will be registered and any custom graphfcns will have access to them.</p>"},{"location":"parameters_guide/#changing-existing-parameter-groups","title":"Changing existing parameter groups","text":"<p>There may be cases where you want to change existing parameter groups, such as introducing new weights to the <code>calculate_weights</code> step so that they are minimized during the shortest path optimization. In this example, we want the <code>TopologyDerivation</code> group to include some new parameters. We can do this in a similar way to above, but being mindful to inherit from <code>TopologyDerivation</code> rather than <code>BaseModel</code>:</p> <pre><code>from swmmanywhere.parameters import register_parameter_group, TopologyDerivation, Field\n\n@register_parameter_group(\"topology_derivation\")\nclass NewTopologyDerivation(TopologyDerivation):\n    new_weight_scaling: float = Field(\n        default=1,\n        le=1,\n        ge=0,\n    )\n    new_weight_exponent: float = Field(\n        default=1,\n        le=2,\n        ge=0,\n    )\n</code></pre> <p>Now the <code>calculate_weights</code> function will have access to these new weighting parameters, as well as existing ones.</p> <p>Note, in this specific example of adding custom weights, you will also have to:</p> <ul> <li>Update the <code>weights</code> parameter in your <code>config</code> file, for example:</li> </ul> <pre><code>parameter_overrides:\n  topology_derviation:\n    weights:\n      - new_weight\n      - length\n</code></pre> <ul> <li>Create and register a <code>graphfcn</code> that adds the <code>new_weight</code> parameter to the graph.</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":"<p>SWMManywhere is a Python tool to synthesise Urban Drainage Models (UDM) anywhere in the world. It handles everything from data acquisition to running the UDM in the SWMM software.</p>"},{"location":"quickstart/#install-swmmanywhere","title":"Install SWMManywhere","text":"<p>Install SWMManywhere:</p> <pre><code>pip install swmmanywhere\n</code></pre>"},{"location":"quickstart/#run-swmmanywhere","title":"Run SWMManywhere","text":"<p>The intended use of SWMManywhere is via a Command Line Interface (CLI) that receives the path to a configuration file. You can copy the minimum viable configuration file and run SWMManywhere with the command below:</p> <pre><code>python -m swmmanywhere --config_path=/path/to/file.yml\n</code></pre> <p>which will create a SWMM input file (<code>.inp</code>) at the file location:</p> <pre><code>&lt;base_dir&gt;/&lt;project&gt;/bbox_1/model_1/model_1.inp\n</code></pre>"},{"location":"quickstart/#use-your-model","title":"Use your model","text":"<p>If you prefer GUIs then the easiest thing now is to download the SWMM software and load your model in there. The example above looks as follows:</p> <p></p> <p>From here you can run or edit your model.</p> <p>If you want to investigate your model in GIS, then the geospatial data that was formatted into the model file (<code>model_1.inp</code>) is also available at:</p> <pre><code>&lt;base_dir&gt;/&lt;project&gt;/bbox_1/model_1/nodes.geojson\n&lt;base_dir&gt;/&lt;project&gt;/bbox_1/model_1/edges.geojson\n&lt;base_dir&gt;/&lt;project&gt;/bbox_1/model_1/subcatchments.geojson\n</code></pre>"},{"location":"quickstart/#not-happy-with-your-model","title":"Not happy with your model?","text":"<p>Then it sounds like you want to explore the wide range of customisability that SWMManywhere offers! See our guides to understand what is going on in greater detail and how to create better synthetic UDMs.</p>"},{"location":"reference-defs/","title":"Reference for SWMManywhere/defs","text":""},{"location":"reference-defs/#demo-configuration-file","title":"Demo configuration file","text":"<pre><code>base_dir: /path/to/base/directory\nproject: demo\nbbox: [0.04020, 51.55759, 0.09826, 51.62050]\nrun_model: true\nrun_settings: \n  reporting_iters: 100\n  duration: 86400\n  storevars: [flooding, flow]\nreal:\n  inp: /path/to/real/model.inp\n  graph: /path/to/real/graph.json\n  subcatchments: /path/to/real/subcatchments.geojson\n  results: null\nstarting_graph: null\ngraphfcn_list:\n  - assign_id # Initial pass to ensure consistent 'id' and remove duplicates\n  - fix_geometries # Ensure consistent geometry directions\n  - remove_non_pipe_allowable_links # Filter out things like bridges/motorways\n  - calculate_streetcover # Create shapefile of impervious street cover\n  - remove_parallel_edges # Remove parallel edges retaining the shorter one\n  - to_undirected # Convert graph to undirected to facilitate cleanup\n  - split_long_edges # Set a maximum edge length\n  - merge_street_nodes # Merge street nodes that are too close together\n  - assign_id # Remove duplicates arising from merge_street_nodes\n  - clip_to_catchments # Clip graph to catchment subbasins\n  - calculate_contributing_area # Calculate runoff coefficient\n  - set_elevation # Set node elevation from DEM\n  - double_directed # Format as directed graph enabling travel in both directions\n  - fix_geometries # Ensure consistent geometries due to undirected-&gt;directed\n  - set_surface_slope # Calculate surface slope of edges\n  - set_chahinian_slope # Transform surface slope to more sensible slope for weights\n  - set_chahinian_angle # Transform edge angles to more sensible angle for weights\n  - calculate_weights # Calculate weights for each edge\n  - identify_outfalls # Identify potential street-&gt;river outfalls\n  - derive_topology # Shortest path to give network topology\n  - pipe_by_pipe # Design pipe diameters and depths\n  - fix_geometries # Ensure geometries present before printing\n  - assign_id # Final pass to ensure consistent 'id' and remove duplicates\nmetric_list:\n  - outfall_nse_flow\n  - outfall_kge_flow\n  - outfall_relerror_flow\n  - outfall_relerror_length\n  - outfall_relerror_npipes\n  - outfall_relerror_nmanholes\n  - outfall_relerror_diameter\n  - outfall_nse_flooding\n  - outfall_kge_flooding\n  - outfall_relerror_flooding\n  - grid_nse_flooding\n  - grid_kge_flooding\n  - grid_relerror_flooding\n  - subcatchment_nse_flooding\n  - subcatchment_kge_flooding\n  - subcatchment_relerror_flooding\n  - bias_flood_depth\n  - kstest_edge_betweenness\n  - kstest_betweenness\n  - outfall_kstest_diameters\n  - nc_deltacon0\n  - nc_laplacian_dist\n  - nc_vertex_edge_distance\n</code></pre>"},{"location":"reference-defs/#schema-for-configuration-file","title":"Schema for configuration file","text":"<pre><code>type: object\nproperties:\n  base_dir: {type: string}\n  project: {type: string}\n  bbox: {type: array, items: {type: number}, minItems: 4, maxItems: 4}\n  model_number: {type: integer}\n  run_model: {type: boolean}\n  run_settings:\n    type: object\n    properties:\n      reporting_iters: {type: integer, minimum: 1}\n      duration: {type: number}\n      storevars:\n        type: array\n        items: \n          type: string\n          enum: [flooding, flow, depth, runoff]\n  real:\n    type: ['object', 'null']\n    properties:\n      inp: {type: ['string', 'null']}\n      graph: {type: string}\n      subcatchments: {type: string}\n      results: {type: ['string', 'null']}\n    required: [graph, subcatchments]\n    anyOf:\n      - required: [inp]\n      - required: [results]\n  starting_graph: {type: ['string', 'null']}\n  graphfcn_list: {type: array, items: {type: string}}\n  metric_list: {type: array, items: {type: string}}\n  address_overrides: {type: ['object', 'null']}\n  parameter_overrides: {type: ['object', 'null']}\n  custom_metric_modules: {type: array, items: {type: string}}\n  custom_graphfcn_modules: {type: array, items: {type: string}}\n  custom_parameters_modules: {type: array, items: {type: string}}\nrequired: [base_dir, project, bbox]\n</code></pre>"},{"location":"reference-filepaths/","title":"Reference for SWMManywhere/filepaths.py","text":"<p>File paths module for SWMMAnywhere.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths","title":"<code>BBoxPaths</code>","text":"<p>Paths for the bounding box folder (within project folder).</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>class BBoxPaths:\n    \"\"\"Paths for the bounding box folder (within project folder).\"\"\"\n\n    def __init__(\n        self,\n        project_paths: ProjectPaths,\n        bbox_bounds: tuple[float, float, float, float],\n        bbox_number: int | None = None,\n        extension: str = \"parquet\",\n        **kwargs,\n    ):\n        \"\"\"Initialise the bounding box paths.\n\n        Args:\n            project_paths (ProjectPaths): The project paths.\n            bbox_bounds (tuple[float, float, float, float]): Bounding box\n                coordinates in the format (minx, miny, maxx, maxy).\n            bbox_number (int, optional): The bounding box number. Defaults to\n                None, in which case if the existing bounding box has already\n                been created it will be found, otherwise the next number will\n                be used.\n            extension (str, optional): The extension for the files. Defaults to\n                'parquet'.\n            **kwargs: Additional file paths to override.\n        \"\"\"\n        if not bbox_number:\n            bbox_number = get_next_bbox_number(bbox_bounds, project_paths.project)\n\n        self.base_dir = project_paths.project\n        self.bbox_number = bbox_number\n        self.extension = extension\n        self.bbox_bounds = bbox_bounds\n        self.overrides: dict[str, Path] = get_overrides(BBoxPaths, kwargs)\n\n        self.bbox.mkdir(exist_ok=True)\n        self.download.mkdir(exist_ok=True)\n\n        bounding_box_info = {\"bbox\": bbox_bounds, \"project\": project_paths.project_name}\n\n        bbox_info_file = self.bbox / \"bounding_box_info.json\"\n        if not bbox_info_file.exists():\n            with bbox_info_file.open(\"w\") as info_file:\n                json.dump(bounding_box_info, info_file, indent=2)\n\n    @property\n    def bbox(self):\n        \"\"\"The bounding box folder (specific to a bounding box).\"\"\"\n        return self.overrides.get(\"bbox\", self.base_dir / f\"bbox_{self.bbox_number}\")\n\n    @property\n    def download(self):\n        \"\"\"The download folder (for bbox specific downloaded data).\"\"\"\n        return self.overrides.get(\"download\", self.bbox / \"download\")\n\n    @property\n    def river(self):\n        \"\"\"The river graph for the bounding box.\"\"\"\n        return self.overrides.get(\"river\", self.download / f\"river.{self.extension}\")\n\n    @property\n    def street(self):\n        \"\"\"The street graph for the bounding box.\"\"\"\n        return self.overrides.get(\"street\", self.download / f\"street.{self.extension}\")\n\n    @property\n    def elevation(self):\n        \"\"\"The elevation file for the bounding box.\"\"\"\n        return self.overrides.get(\"elevation\", self.download / \"elevation.tif\")\n\n    @property\n    def building(self):\n        \"\"\"The building file for the bounding box (clipped from national scale).\"\"\"\n        return self.overrides.get(\n            \"building\", self.download / f\"building.geo{self.extension}\"\n        )\n\n    @property\n    def precipitation(self):\n        \"\"\"The precipitation data.\"\"\"\n        return self.overrides.get(\n            \"precipitation\", self.download / f\"precipitation.{self.extension}\"\n        )\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths.bbox","title":"<code>bbox</code>  <code>property</code>","text":"<p>The bounding box folder (specific to a bounding box).</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths.building","title":"<code>building</code>  <code>property</code>","text":"<p>The building file for the bounding box (clipped from national scale).</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths.download","title":"<code>download</code>  <code>property</code>","text":"<p>The download folder (for bbox specific downloaded data).</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths.elevation","title":"<code>elevation</code>  <code>property</code>","text":"<p>The elevation file for the bounding box.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths.precipitation","title":"<code>precipitation</code>  <code>property</code>","text":"<p>The precipitation data.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths.river","title":"<code>river</code>  <code>property</code>","text":"<p>The river graph for the bounding box.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths.street","title":"<code>street</code>  <code>property</code>","text":"<p>The street graph for the bounding box.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.BBoxPaths.__init__","title":"<code>__init__(project_paths, bbox_bounds, bbox_number=None, extension='parquet', **kwargs)</code>","text":"<p>Initialise the bounding box paths.</p> <p>Parameters:</p> Name Type Description Default <code>project_paths</code> <code>ProjectPaths</code> <p>The project paths.</p> required <code>bbox_bounds</code> <code>tuple[float, float, float, float]</code> <p>Bounding box coordinates in the format (minx, miny, maxx, maxy).</p> required <code>bbox_number</code> <code>int</code> <p>The bounding box number. Defaults to None, in which case if the existing bounding box has already been created it will be found, otherwise the next number will be used.</p> <code>None</code> <code>extension</code> <code>str</code> <p>The extension for the files. Defaults to 'parquet'.</p> <code>'parquet'</code> <code>**kwargs</code> <p>Additional file paths to override.</p> <code>{}</code> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def __init__(\n    self,\n    project_paths: ProjectPaths,\n    bbox_bounds: tuple[float, float, float, float],\n    bbox_number: int | None = None,\n    extension: str = \"parquet\",\n    **kwargs,\n):\n    \"\"\"Initialise the bounding box paths.\n\n    Args:\n        project_paths (ProjectPaths): The project paths.\n        bbox_bounds (tuple[float, float, float, float]): Bounding box\n            coordinates in the format (minx, miny, maxx, maxy).\n        bbox_number (int, optional): The bounding box number. Defaults to\n            None, in which case if the existing bounding box has already\n            been created it will be found, otherwise the next number will\n            be used.\n        extension (str, optional): The extension for the files. Defaults to\n            'parquet'.\n        **kwargs: Additional file paths to override.\n    \"\"\"\n    if not bbox_number:\n        bbox_number = get_next_bbox_number(bbox_bounds, project_paths.project)\n\n    self.base_dir = project_paths.project\n    self.bbox_number = bbox_number\n    self.extension = extension\n    self.bbox_bounds = bbox_bounds\n    self.overrides: dict[str, Path] = get_overrides(BBoxPaths, kwargs)\n\n    self.bbox.mkdir(exist_ok=True)\n    self.download.mkdir(exist_ok=True)\n\n    bounding_box_info = {\"bbox\": bbox_bounds, \"project\": project_paths.project_name}\n\n    bbox_info_file = self.bbox / \"bounding_box_info.json\"\n    if not bbox_info_file.exists():\n        with bbox_info_file.open(\"w\") as info_file:\n            json.dump(bounding_box_info, info_file, indent=2)\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.FilePaths","title":"<code>FilePaths</code>","text":"<p>File paths class (manager for project, bbox and model).</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>class FilePaths:\n    \"\"\"File paths class (manager for project, bbox and model).\"\"\"\n\n    def __init__(\n        self,\n        base_dir: Path,\n        project_name: str,\n        bbox_bounds: tuple[float, float, float, float],\n        bbox_number: int | None = None,\n        model_number: int | None = None,\n        extension: str = \"parquet\",\n        **kwargs,\n    ):\n        \"\"\"Initialise the file paths.\n\n        Args:\n            base_dir (Path): The base directory.\n            project_name (str): The name of the project.\n            bbox_bounds (tuple[float, float, float, float]): Bounding box\n                coordinates in the format (minx, miny, maxx, maxy).\n            bbox_number (int, optional): The bounding box number. Defaults to\n                None, in which case if the existing bounding box has already\n                been created it will be found, otherwise the next number will\n                be used.\n            model_number (int, optional): The model number. Defaults to None,\n                in which case the next number in the bbox directory will be used.\n            extension (str): The extension for the files.\n            **kwargs: Additional file paths.\n        \"\"\"\n        # Validate overrides and convert to paths\n        for p, value in kwargs.items():\n            value = Path(value)\n            if not value.exists():\n                logger.warning(f\"Override path for {p}, {value} does not yet exist.\")\n            kwargs[p] = value\n\n        # Create project paths and apply overrides\n        self.project_paths = ProjectPaths(base_dir, project_name, extension, **kwargs)\n\n        # Create bbox paths and apply overrides\n        self.bbox_paths = BBoxPaths(\n            self.project_paths, bbox_bounds, bbox_number, extension, **kwargs\n        )\n\n        # Create model paths and apply overrides\n        self.model_paths = ModelPaths(\n            self.bbox_paths, model_number, extension, **kwargs\n        )\n\n        self._overrides = kwargs\n\n    def to_yaml(self, f: Path):\n        \"\"\"Convert a file to json.\"\"\"\n        address_dict = {}\n        for attr in [\"model_paths\", \"bbox_paths\", \"project_paths\"]:\n            address_dict.update(getattr(self, attr).__dict__)\n            address_dict.update(**getattr(getattr(self, attr), \"overrides\"))\n        address_dict.update(self._overrides)\n        yaml_dump(address_dict, f.open(\"w\"))\n\n    def get_path(self, name: str) -&gt; Path:\n        \"\"\"Get a path from _overrides.\"\"\"\n        path = self._overrides.get(name, None)\n        if not path:\n            raise FileExistsError(f\"No file found for `{name}` attribute.\")\n        return path\n\n    def set_bbox_number(self, number):\n        \"\"\"Set the bounding box number.\"\"\"\n        self.bbox_paths.bbox_number = number\n        self.model_paths.base_dir = self.bbox_paths.bbox\n\n    def set_model_number(self, number):\n        \"\"\"Set the model number.\"\"\"\n        self.model_paths.model_number = number\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.FilePaths.__init__","title":"<code>__init__(base_dir, project_name, bbox_bounds, bbox_number=None, model_number=None, extension='parquet', **kwargs)</code>","text":"<p>Initialise the file paths.</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>Path</code> <p>The base directory.</p> required <code>project_name</code> <code>str</code> <p>The name of the project.</p> required <code>bbox_bounds</code> <code>tuple[float, float, float, float]</code> <p>Bounding box coordinates in the format (minx, miny, maxx, maxy).</p> required <code>bbox_number</code> <code>int</code> <p>The bounding box number. Defaults to None, in which case if the existing bounding box has already been created it will be found, otherwise the next number will be used.</p> <code>None</code> <code>model_number</code> <code>int</code> <p>The model number. Defaults to None, in which case the next number in the bbox directory will be used.</p> <code>None</code> <code>extension</code> <code>str</code> <p>The extension for the files.</p> <code>'parquet'</code> <code>**kwargs</code> <p>Additional file paths.</p> <code>{}</code> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def __init__(\n    self,\n    base_dir: Path,\n    project_name: str,\n    bbox_bounds: tuple[float, float, float, float],\n    bbox_number: int | None = None,\n    model_number: int | None = None,\n    extension: str = \"parquet\",\n    **kwargs,\n):\n    \"\"\"Initialise the file paths.\n\n    Args:\n        base_dir (Path): The base directory.\n        project_name (str): The name of the project.\n        bbox_bounds (tuple[float, float, float, float]): Bounding box\n            coordinates in the format (minx, miny, maxx, maxy).\n        bbox_number (int, optional): The bounding box number. Defaults to\n            None, in which case if the existing bounding box has already\n            been created it will be found, otherwise the next number will\n            be used.\n        model_number (int, optional): The model number. Defaults to None,\n            in which case the next number in the bbox directory will be used.\n        extension (str): The extension for the files.\n        **kwargs: Additional file paths.\n    \"\"\"\n    # Validate overrides and convert to paths\n    for p, value in kwargs.items():\n        value = Path(value)\n        if not value.exists():\n            logger.warning(f\"Override path for {p}, {value} does not yet exist.\")\n        kwargs[p] = value\n\n    # Create project paths and apply overrides\n    self.project_paths = ProjectPaths(base_dir, project_name, extension, **kwargs)\n\n    # Create bbox paths and apply overrides\n    self.bbox_paths = BBoxPaths(\n        self.project_paths, bbox_bounds, bbox_number, extension, **kwargs\n    )\n\n    # Create model paths and apply overrides\n    self.model_paths = ModelPaths(\n        self.bbox_paths, model_number, extension, **kwargs\n    )\n\n    self._overrides = kwargs\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.FilePaths.get_path","title":"<code>get_path(name)</code>","text":"<p>Get a path from _overrides.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def get_path(self, name: str) -&gt; Path:\n    \"\"\"Get a path from _overrides.\"\"\"\n    path = self._overrides.get(name, None)\n    if not path:\n        raise FileExistsError(f\"No file found for `{name}` attribute.\")\n    return path\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.FilePaths.set_bbox_number","title":"<code>set_bbox_number(number)</code>","text":"<p>Set the bounding box number.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def set_bbox_number(self, number):\n    \"\"\"Set the bounding box number.\"\"\"\n    self.bbox_paths.bbox_number = number\n    self.model_paths.base_dir = self.bbox_paths.bbox\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.FilePaths.set_model_number","title":"<code>set_model_number(number)</code>","text":"<p>Set the model number.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def set_model_number(self, number):\n    \"\"\"Set the model number.\"\"\"\n    self.model_paths.model_number = number\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.FilePaths.to_yaml","title":"<code>to_yaml(f)</code>","text":"<p>Convert a file to json.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def to_yaml(self, f: Path):\n    \"\"\"Convert a file to json.\"\"\"\n    address_dict = {}\n    for attr in [\"model_paths\", \"bbox_paths\", \"project_paths\"]:\n        address_dict.update(getattr(self, attr).__dict__)\n        address_dict.update(**getattr(getattr(self, attr), \"overrides\"))\n    address_dict.update(self._overrides)\n    yaml_dump(address_dict, f.open(\"w\"))\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths","title":"<code>ModelPaths</code>","text":"<p>Paths for the model folder (within bbox folder).</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>class ModelPaths:\n    \"\"\"Paths for the model folder (within bbox folder).\"\"\"\n\n    def __init__(\n        self,\n        bbox_paths: BBoxPaths,\n        model_number: int | None = None,\n        extension: str = \"parquet\",\n        **kwargs,\n    ):\n        \"\"\"Initialise the model paths.\n\n        Args:\n            bbox_paths (BBoxPaths): The bounding box paths.\n            model_number (int, None): The model number. Defaults to None, in\n                which case the next number in the bbox directory will be used.\n            extension (str): The extension for the files.\n            **kwargs: Additional file paths to override.\n        \"\"\"\n        if model_number is None:\n            model_number = next_directory(\"model\", bbox_paths.bbox)\n\n        self.base_dir = bbox_paths.bbox\n        self.model_number = model_number\n        self.extension = extension\n        self.overrides: dict[str, Path] = get_overrides(ModelPaths, kwargs)\n\n        self.model.mkdir(exist_ok=True)\n\n    @property\n    def model(self):\n        \"\"\"The model folder (one specific synthesised model).\"\"\"\n        return self.overrides.get(\"model\", self.base_dir / f\"model_{self.model_number}\")\n\n    @property\n    def inp(self):\n        \"\"\"The synthesised SWMM input file for the model.\"\"\"\n        return self.overrides.get(\"inp\", self.model / f\"model_{self.model_number}.inp\")\n\n    @property\n    def subcatchments(self):\n        \"\"\"The subcatchments file for the model.\"\"\"\n        return self.overrides.get(\n            \"subcatchments\", self.model / f\"subcatchments.geo{self.extension}\"\n        )\n\n    @property\n    def graph(self):\n        \"\"\"The graph file for the model.\"\"\"\n        return self.overrides.get(\"graph\", self.model / f\"graph.{self.extension}\")\n\n    @property\n    def nodes(self):\n        \"\"\"The nodes file for the model.\"\"\"\n        return self.overrides.get(\"nodes\", self.model / f\"nodes.geo{self.extension}\")\n\n    @property\n    def edges(self):\n        \"\"\"The edges file for the model.\"\"\"\n        return self.overrides.get(\"edges\", self.model / f\"edges.geo{self.extension}\")\n\n    @property\n    def streetcover(self):\n        \"\"\"The street cover file for the model.\"\"\"\n        return self.overrides.get(\n            \"streetcover\", self.model / f\"streetcover.geo{self.extension}\"\n        )\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>The edges file for the model.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths.graph","title":"<code>graph</code>  <code>property</code>","text":"<p>The graph file for the model.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths.inp","title":"<code>inp</code>  <code>property</code>","text":"<p>The synthesised SWMM input file for the model.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths.model","title":"<code>model</code>  <code>property</code>","text":"<p>The model folder (one specific synthesised model).</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>The nodes file for the model.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths.streetcover","title":"<code>streetcover</code>  <code>property</code>","text":"<p>The street cover file for the model.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths.subcatchments","title":"<code>subcatchments</code>  <code>property</code>","text":"<p>The subcatchments file for the model.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ModelPaths.__init__","title":"<code>__init__(bbox_paths, model_number=None, extension='parquet', **kwargs)</code>","text":"<p>Initialise the model paths.</p> <p>Parameters:</p> Name Type Description Default <code>bbox_paths</code> <code>BBoxPaths</code> <p>The bounding box paths.</p> required <code>model_number</code> <code>(int, None)</code> <p>The model number. Defaults to None, in which case the next number in the bbox directory will be used.</p> <code>None</code> <code>extension</code> <code>str</code> <p>The extension for the files.</p> <code>'parquet'</code> <code>**kwargs</code> <p>Additional file paths to override.</p> <code>{}</code> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def __init__(\n    self,\n    bbox_paths: BBoxPaths,\n    model_number: int | None = None,\n    extension: str = \"parquet\",\n    **kwargs,\n):\n    \"\"\"Initialise the model paths.\n\n    Args:\n        bbox_paths (BBoxPaths): The bounding box paths.\n        model_number (int, None): The model number. Defaults to None, in\n            which case the next number in the bbox directory will be used.\n        extension (str): The extension for the files.\n        **kwargs: Additional file paths to override.\n    \"\"\"\n    if model_number is None:\n        model_number = next_directory(\"model\", bbox_paths.bbox)\n\n    self.base_dir = bbox_paths.bbox\n    self.model_number = model_number\n    self.extension = extension\n    self.overrides: dict[str, Path] = get_overrides(ModelPaths, kwargs)\n\n    self.model.mkdir(exist_ok=True)\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ProjectPaths","title":"<code>ProjectPaths</code>","text":"<p>Paths for the project folder (within base_dir).</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>class ProjectPaths:\n    \"\"\"Paths for the project folder (within base_dir).\"\"\"\n\n    def __init__(\n        self, base_dir: Path, project_name: str, extension: str = \"parquet\", **kwargs\n    ):\n        \"\"\"Initialise the project paths.\n\n        Args:\n            base_dir (Path): The base directory.\n            project_name (str): The name of the project.\n            extension (str): The extension for the files.\n            **kwargs: Additional file paths to override.\n        \"\"\"\n        self.project_name = project_name\n        self.extension = extension\n        self.base_dir = base_dir\n        self.overrides: dict[str, Path] = get_overrides(ProjectPaths, kwargs)\n\n        self.project.mkdir(exist_ok=True)\n        self.national.mkdir(exist_ok=True)\n\n    @property\n    def project(self):\n        \"\"\"The project folder (sits in the base_dir).\"\"\"\n        return self.overrides.get(\"project\", self.base_dir / self.project_name)\n\n    @property\n    def national(self):\n        \"\"\"The national folder (for national scale downloads).\"\"\"\n        return self.overrides.get(\"national\", self.project / \"national\")\n\n    @property\n    def national_building(self):\n        \"\"\"The national scale building file.\"\"\"\n        return self.overrides.get(\n            \"national_building\", self.national / f\"building.{self.extension}\"\n        )\n\n    @property\n    def whiteboxtools_binaries_zip(self):\n        \"\"\"The zipped whitebox tools binaries folder.\"\"\"\n        return self.overrides.get(\n            \"whiteboxtools_binaries_zip\", self.project / \"whitebox_tools.zip\"\n        )\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ProjectPaths.national","title":"<code>national</code>  <code>property</code>","text":"<p>The national folder (for national scale downloads).</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ProjectPaths.national_building","title":"<code>national_building</code>  <code>property</code>","text":"<p>The national scale building file.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ProjectPaths.project","title":"<code>project</code>  <code>property</code>","text":"<p>The project folder (sits in the base_dir).</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ProjectPaths.whiteboxtools_binaries_zip","title":"<code>whiteboxtools_binaries_zip</code>  <code>property</code>","text":"<p>The zipped whitebox tools binaries folder.</p>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.ProjectPaths.__init__","title":"<code>__init__(base_dir, project_name, extension='parquet', **kwargs)</code>","text":"<p>Initialise the project paths.</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>Path</code> <p>The base directory.</p> required <code>project_name</code> <code>str</code> <p>The name of the project.</p> required <code>extension</code> <code>str</code> <p>The extension for the files.</p> <code>'parquet'</code> <code>**kwargs</code> <p>Additional file paths to override.</p> <code>{}</code> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def __init__(\n    self, base_dir: Path, project_name: str, extension: str = \"parquet\", **kwargs\n):\n    \"\"\"Initialise the project paths.\n\n    Args:\n        base_dir (Path): The base directory.\n        project_name (str): The name of the project.\n        extension (str): The extension for the files.\n        **kwargs: Additional file paths to override.\n    \"\"\"\n    self.project_name = project_name\n    self.extension = extension\n    self.base_dir = base_dir\n    self.overrides: dict[str, Path] = get_overrides(ProjectPaths, kwargs)\n\n    self.project.mkdir(exist_ok=True)\n    self.national.mkdir(exist_ok=True)\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.check_bboxes","title":"<code>check_bboxes(bbox, data_dir)</code>","text":"<p>Find the bounding box number.</p> <p>Check if the bounding box coordinates match any existing bounding box directories within data_dir.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>tuple[float, float, float, float]</code> <p>Bounding box coordinates in the format (minx, miny, maxx, maxy).</p> required <code>data_dir</code> <code>Path</code> <p>Path to the data directory.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int | bool</code> <p>Bounding box number if the coordinates match, else False.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def check_bboxes(bbox: tuple[float, float, float, float], data_dir: Path) -&gt; int | bool:\n    \"\"\"Find the bounding box number.\n\n    Check if the bounding box coordinates match any existing bounding box\n    directories within data_dir.\n\n    Args:\n        bbox (tuple[float, float, float, float]): Bounding box coordinates in\n            the format (minx, miny, maxx, maxy).\n        data_dir (Path): Path to the data directory.\n\n    Returns:\n        int: Bounding box number if the coordinates match, else False.\n    \"\"\"\n    # Find all bounding_box_info.json files\n    info_fids = data_dir.glob(\"*/*bounding_box_info.json\")\n\n    # Iterate over info files\n    for info_fid in info_fids:\n        # Read bounding_box_info.json\n        with info_fid.open(\"r\") as info_file:\n            bounding_info = json.load(info_file)\n        # Check if the bounding box coordinates match\n        if Counter(bounding_info.get(\"bbox\")) == Counter(bbox):\n            bbox_full_dir = info_fid.parent\n            bbox_dir = bbox_full_dir.name\n            bbox_number = int(bbox_dir.replace(\"bbox_\", \"\"))\n            return bbox_number\n\n    return False\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.filepaths_from_yaml","title":"<code>filepaths_from_yaml(f)</code>","text":"<p>Get file paths from a yaml file.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def filepaths_from_yaml(f: Path):\n    \"\"\"Get file paths from a yaml file.\"\"\"\n    address_dict = yaml_load(f.read_text())\n    address_dict[\"base_dir\"] = Path(address_dict[\"base_dir\"])\n    overrides = address_dict.pop(\"overrides\", {})\n    addresses = FilePaths(**address_dict, **overrides)\n    return addresses\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.get_next_bbox_number","title":"<code>get_next_bbox_number(bbox, data_dir)</code>","text":"<p>Get the next bounding box number.</p> <p>If there are existing bounding box directories, check within them to see if any have the same bounding box, otherwise find the next number. If there are no existing bounding box directories, return 1.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>tuple[float, float, float, float]</code> <p>Bounding box coordinates in the format (minx, miny, maxx, maxy).</p> required <code>data_dir</code> <code>Path</code> <p>Path to the data directory.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Next bounding box number.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def get_next_bbox_number(\n    bbox: tuple[float, float, float, float], data_dir: Path\n) -&gt; int:\n    \"\"\"Get the next bounding box number.\n\n    If there are existing bounding box directories, check within them to see if\n    any have the same bounding box, otherwise find the next number. If\n    there are no existing bounding box directories, return 1.\n\n    Args:\n        bbox (tuple[float, float, float, float]): Bounding box coordinates in\n            the format (minx, miny, maxx, maxy).\n        data_dir (Path): Path to the data directory.\n\n    Returns:\n        int: Next bounding box number.\n    \"\"\"\n    # Search for existing bounding box directories\n    bbox_number = check_bboxes(bbox, data_dir)\n    if not bbox_number:\n        return next_directory(\"bbox\", data_dir)\n    return bbox_number\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.get_overrides","title":"<code>get_overrides(klass, overrides)</code>","text":"<p>Get overrides for a class.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def get_overrides(klass: type, overrides: dict[str, Path]) -&gt; dict[str, Path]:\n    \"\"\"Get overrides for a class.\"\"\"\n    out = {}\n    for p in overrides.copy().keys():\n        if not hasattr(klass, p):\n            continue\n        out[p] = overrides.pop(p)\n    return out\n</code></pre>"},{"location":"reference-filepaths/#swmmanywhere.filepaths.next_directory","title":"<code>next_directory(keyword, directory)</code>","text":"<p>Find the next directory number.</p> <p>Find the next directory number within a directory with a _ in its name. <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>Keyword to search for in the directory name.</p> required <code>directory</code> <code>Path</code> <p>Path to the directory to search within.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Next directory number.</p> Source code in <code>swmmanywhere/filepaths.py</code> <pre><code>def next_directory(keyword: str, directory: Path) -&gt; int:\n    \"\"\"Find the next directory number.\n\n    Find the next directory number within a directory with a &lt;keyword&gt;_ in its\n    name.\n\n    Args:\n        keyword (str): Keyword to search for in the directory name.\n        directory (Path): Path to the directory to search within.\n\n    Returns:\n        int: Next directory number.\n    \"\"\"\n    existing_dirs = [int(d.name.split(\"_\")[-1]) for d in directory.glob(f\"{keyword}_*\")]\n    return 1 if not existing_dirs else max(existing_dirs) + 1\n</code></pre>"},{"location":"reference-geospatial-utilities/","title":"Reference for SWMManywhere/geospatial_utilities.py","text":"<p>Geospatial utilities module for SWMManywhere.</p> <p>A module containing functions to perform a variety of geospatial operations, such as reprojecting coordinates and handling raster data.</p>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.Grid","title":"<code>Grid</code>","text":"<p>A class to represent a grid.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>class Grid:\n    \"\"\"A class to represent a grid.\"\"\"\n\n    def __init__(self, affine: rst.Affine, shape: tuple, crs: int, bbox: tuple):\n        \"\"\"Initialize the Grid class.\n\n        Args:\n            affine (rst.Affine): The affine transformation.\n            shape (tuple): The shape of the grid.\n            crs (int): The CRS of the grid.\n            bbox (tuple): The bounding box of the grid.\n        \"\"\"\n        self.affine = affine\n        self.shape = shape\n        self.crs = crs\n        self.bbox = bbox\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.Grid.__init__","title":"<code>__init__(affine, shape, crs, bbox)</code>","text":"<p>Initialize the Grid class.</p> <p>Parameters:</p> Name Type Description Default <code>affine</code> <code>Affine</code> <p>The affine transformation.</p> required <code>shape</code> <code>tuple</code> <p>The shape of the grid.</p> required <code>crs</code> <code>int</code> <p>The CRS of the grid.</p> required <code>bbox</code> <code>tuple</code> <p>The bounding box of the grid.</p> required Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def __init__(self, affine: rst.Affine, shape: tuple, crs: int, bbox: tuple):\n    \"\"\"Initialize the Grid class.\n\n    Args:\n        affine (rst.Affine): The affine transformation.\n        shape (tuple): The shape of the grid.\n        crs (int): The CRS of the grid.\n        bbox (tuple): The bounding box of the grid.\n    \"\"\"\n    self.affine = affine\n    self.shape = shape\n    self.crs = crs\n    self.bbox = bbox\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.attach_unconnected_subareas","title":"<code>attach_unconnected_subareas(polys_gdf, unconnected_subareas)</code>","text":"<p>Attach unconnected subareas to the nearest polygon.</p> <p>Parameters:</p> Name Type Description Default <code>polys_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing polygons with columns: 'geometry', 'area', and 'id'.</p> required <code>unconnected_subareas</code> <code>List[Polygon]</code> <p>A list of subareas that are not attached to others.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame containing polygons.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def attach_unconnected_subareas(\n    polys_gdf: gpd.GeoDataFrame, unconnected_subareas: List[sgeom.Polygon]\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Attach unconnected subareas to the nearest polygon.\n\n    Args:\n        polys_gdf (gpd.GeoDataFrame): A GeoDataFrame containing polygons with\n            columns: 'geometry', 'area', and 'id'.\n        unconnected_subareas (List[sgeom.Polygon]): A list of subareas that are\n            not attached to others.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing polygons.\n    \"\"\"\n    tree = STRtree(polys_gdf.geometry)\n    for subarea in unconnected_subareas:\n        nearest_poly = tree.nearest(subarea)\n        ind = polys_gdf.index[nearest_poly]\n        new_poly = polys_gdf.loc[ind, \"geometry\"].union(subarea)\n        if hasattr(new_poly, \"geoms\"):\n            new_poly = max(new_poly.geoms, key=lambda x: x.area)\n        polys_gdf.at[ind, \"geometry\"] = new_poly\n    return polys_gdf\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.burn_shape_in_raster","title":"<code>burn_shape_in_raster(geoms, depth, raster_fid, new_raster_fid)</code>","text":"<p>Burn a depth into a raster along a list of shapely geometries.</p> <p>Parameters:</p> Name Type Description Default <code>geoms</code> <code>list</code> <p>List of Shapely geometries.</p> required <code>depth</code> <code>float</code> <p>Depth to carve.</p> required <code>raster_fid</code> <code>Path</code> <p>Filepath to input raster.</p> required <code>new_raster_fid</code> <code>Path</code> <p>Filepath to save the carved raster.</p> required Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def burn_shape_in_raster(\n    geoms: list[sgeom.LineString], depth: float, raster_fid: Path, new_raster_fid: Path\n) -&gt; None:\n    \"\"\"Burn a depth into a raster along a list of shapely geometries.\n\n    Args:\n        geoms (list): List of Shapely geometries.\n        depth (float): Depth to carve.\n        raster_fid (Path): Filepath to input raster.\n        new_raster_fid (Path): Filepath to save the carved raster.\n    \"\"\"\n    with rst.open(raster_fid) as src:\n        # read data\n        data = src.read(1)\n        data = data.astype(float)\n        data_mask = data != src.nodata\n        bool_mask = np.zeros(data.shape, dtype=bool)\n        for geom in geoms:\n            # Create a mask for the line\n            mask = features.geometry_mask(\n                [sgeom.mapping(geom)],\n                out_shape=src.shape,\n                transform=src.transform,\n                invert=True,\n            )\n            # modify masked data\n            bool_mask[mask] = True  # Adjust this multiplier as needed\n        # modify data\n        data[bool_mask &amp; data_mask] -= depth\n        # Create a new GeoTIFF with modified values\n        with rst.open(\n            new_raster_fid,\n            \"w\",\n            driver=\"GTiff\",\n            height=src.height,\n            width=src.width,\n            count=1,\n            dtype=data.dtype,\n            crs=src.crs,\n            transform=src.transform,\n            nodata=src.nodata,\n        ) as dest:\n            dest.write(data, 1)\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.calculate_angle","title":"<code>calculate_angle(point1, point2, point3)</code>","text":"<p>Calculate the angle between three points.</p> <p>Calculate the angle between the vectors formed by (point1, point2) and (point2, point3)</p> <p>Parameters:</p> Name Type Description Default <code>point1</code> <code>tuple</code> <p>The first point (x,y).</p> required <code>point2</code> <code>tuple</code> <p>The second point (x,y).</p> required <code>point3</code> <code>tuple</code> <p>The third point (x,y).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The angle between the three points in degrees.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def calculate_angle(\n    point1: tuple[float, float],\n    point2: tuple[float, float],\n    point3: tuple[float, float],\n) -&gt; float:\n    \"\"\"Calculate the angle between three points.\n\n    Calculate the angle between the vectors formed by (point1,\n    point2) and (point2, point3)\n\n    Args:\n        point1 (tuple): The first point (x,y).\n        point2 (tuple): The second point (x,y).\n        point3 (tuple): The third point (x,y).\n\n    Returns:\n        float: The angle between the three points in degrees.\n    \"\"\"\n    vector1 = (point1[0] - point2[0], point1[1] - point2[1])\n    vector2 = (point3[0] - point2[0], point3[1] - point2[1])\n\n    dot_product = vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    magnitude1 = math.sqrt(vector1[0] ** 2 + vector1[1] ** 2)\n    magnitude2 = math.sqrt(vector2[0] ** 2 + vector2[1] ** 2)\n\n    if magnitude1 * magnitude2 == 0:\n        # Avoid division by zero\n        return float(\"inf\")\n\n    cosine_angle = dot_product / (magnitude1 * magnitude2)\n\n    # Ensure the cosine value is within the valid range [-1, 1]\n    cosine_angle = min(max(cosine_angle, -1), 1)\n\n    # Calculate the angle in radians\n    angle_radians = math.acos(cosine_angle)\n\n    # Convert angle to degrees\n    angle_degrees = math.degrees(angle_radians)\n\n    return angle_degrees\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.calculate_slope","title":"<code>calculate_slope(polys_gdf, grid, cell_slopes)</code>","text":"<p>Calculate the average slope of each polygon.</p> <p>Parameters:</p> Name Type Description Default <code>polys_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing polygons with columns: 'geometry', 'area', and 'id'.</p> required <code>grid</code> <code>Grid</code> <p>Information of the raster (affine, shape, crs, bbox)</p> required <code>cell_slopes</code> <code>ndarray</code> <p>The slopes of each cell in the grid.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame containing polygons with an added 'slope' column.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def calculate_slope(\n    polys_gdf: gpd.GeoDataFrame, grid: Grid, cell_slopes: np.ndarray\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Calculate the average slope of each polygon.\n\n    Args:\n        polys_gdf (gpd.GeoDataFrame): A GeoDataFrame containing polygons with\n            columns: 'geometry', 'area', and 'id'.\n        grid (Grid): Information of the raster (affine, shape, crs, bbox)\n        cell_slopes (np.ndarray): The slopes of each cell in the grid.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing polygons with an added\n            'slope' column.\n    \"\"\"\n    polys_gdf[\"slope\"] = None\n    for idx, row in polys_gdf.iterrows():\n        mask = features.geometry_mask(\n            [row.geometry], grid.shape, grid.affine, invert=True\n        )\n        average_slope = cell_slopes[mask].mean().mean()\n        polys_gdf.loc[idx, \"slope\"] = max(float(average_slope), 0)\n    return polys_gdf\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.delineate_catchment_pyflwdir","title":"<code>delineate_catchment_pyflwdir(grid, flow_dir, G)</code>","text":"<p>Derive subcatchments from the nodes on a graph and a DEM.</p> <p>Uses the pyflwdir catchment delineation functionality. About a magnitude faster than delineate_catchment.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>Grid</code> <p>Information of the raster (affine, shape, crs, bbox).</p> required <code>flow_dir</code> <code>array</code> <p>Flow directions.</p> required <code>G</code> <code>Graph</code> <p>The input graph with nodes containing 'x' and 'y'.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame containing polygons with columns: 'geometry', 'area', 'id', 'width', and 'slope'.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def delineate_catchment_pyflwdir(\n    grid: Grid, flow_dir: np.array, G: nx.Graph\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Derive subcatchments from the nodes on a graph and a DEM.\n\n    Uses the pyflwdir catchment delineation functionality. About a magnitude\n    faster than delineate_catchment.\n\n    Args:\n        grid (Grid): Information of the raster (affine, shape, crs, bbox).\n        flow_dir (np.array): Flow directions.\n        G (nx.Graph): The input graph with nodes containing 'x' and 'y'.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing polygons with columns:\n            'geometry', 'area', 'id', 'width', and 'slope'.\n    \"\"\"\n    flw = pyflwdir.from_array(\n        flow_dir,\n        ftype=\"d8\",\n        check_ftype=False,\n        transform=grid.affine,\n    )\n    bbox = sgeom.box(*grid.bbox)\n    u, x, y = zip(\n        *[\n            (u, float(p[\"x\"]), float(p[\"y\"]))\n            for u, p in G.nodes(data=True)\n            if sgeom.Point(p[\"x\"], p[\"y\"]).within(bbox)\n        ]\n    )\n\n    subbasins = flw.basins(xy=(x, y))\n    gdf_bas = vectorize(\n        subbasins.astype(np.int32), 0, flw.transform, G.graph[\"crs\"], name=\"basin\"\n    )\n    gdf_bas[\"id\"] = [u[x - 1] for x in gdf_bas[\"basin\"]]\n    return gdf_bas\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.derive_rc","title":"<code>derive_rc(subcatchments, building_footprints, streetcover)</code>","text":"<p>Derive the Runoff Coefficient (RC) of each subcatchment.</p> <p>The runoff coefficient is the ratio of impervious area to total area. The impervious area is calculated by overlaying the subcatchments with building footprints and all edges in G buffered by their width parameter (i.e., to calculate road area).</p> <p>Parameters:</p> Name Type Description Default <code>subcatchments</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing polygons that represent subcatchments with columns: 'geometry', 'area', and 'id'.</p> required <code>building_footprints</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing building footprints with a 'geometry' column.</p> required <code>streetcover</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing street cover with a 'geometry' column.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame containing polygons with columns: 'geometry', 'area', 'id', 'impervious_area', and 'rc'.</p> Author <p>@cheginit, @barneydobson</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def derive_rc(\n    subcatchments: gpd.GeoDataFrame,\n    building_footprints: gpd.GeoDataFrame,\n    streetcover: gpd.GeoDataFrame,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Derive the Runoff Coefficient (RC) of each subcatchment.\n\n    The runoff coefficient is the ratio of impervious area to total area. The\n    impervious area is calculated by overlaying the subcatchments with building\n    footprints and all edges in G buffered by their width parameter (i.e., to\n    calculate road area).\n\n    Args:\n        subcatchments (gpd.GeoDataFrame): A GeoDataFrame containing polygons that\n            represent subcatchments with columns: 'geometry', 'area', and 'id'.\n        building_footprints (gpd.GeoDataFrame): A GeoDataFrame containing\n            building footprints with a 'geometry' column.\n        streetcover (gpd.GeoDataFrame): A GeoDataFrame containing street cover\n            with a 'geometry' column.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing polygons with columns:\n            'geometry', 'area', 'id', 'impervious_area', and 'rc'.\n\n    Author:\n        @cheginit, @barneydobson\n    \"\"\"\n    # Map buffered streets and buildings to subcatchments\n    subcat_tree = subcatchments.sindex\n    impervious = gpd.GeoDataFrame(\n        pd.concat([building_footprints[[\"geometry\"]], streetcover[[\"geometry\"]]]),\n        crs=building_footprints.crs,\n    )\n    bf_pidx, sb_pidx = subcat_tree.query(impervious.geometry, predicate=\"intersects\")\n    sb_idx = subcatchments.iloc[sb_pidx].index\n\n    # Calculate impervious area and runoff coefficient (rc)\n    subcatchments[\"impervious_area\"] = 0.0\n\n    # Calculate all intersection-impervious geometries\n    intersection_area = shapely.intersection(\n        subcatchments.iloc[sb_pidx].geometry.to_numpy(),\n        impervious.iloc[bf_pidx].geometry.to_numpy(),\n    )\n\n    # Indicate which catchment each intersection is part of\n    intersections = pd.DataFrame(\n        [\n            {\"sb_idx\": ix, \"impervious_geometry\": ia}\n            for ix, ia in zip(sb_idx, intersection_area)\n        ]\n    )\n\n    # Aggregate by catchment\n    areas = (\n        intersections.groupby(\"sb_idx\")\n        .apply(shapely.ops.unary_union)\n        .apply(shapely.area)\n    )\n\n    # Store as impervious area in subcatchments\n    subcatchments[\"impervious_area\"] = 0.0\n    subcatchments.loc[areas.index, \"impervious_area\"] = areas\n    subcatchments[\"rc\"] = (\n        subcatchments[\"impervious_area\"] / subcatchments.geometry.area * 100\n    )\n    return subcatchments\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.derive_subbasins_streamorder","title":"<code>derive_subbasins_streamorder(fid, streamorder=None, x=[], y=[], wbt_zip_path=None)</code>","text":"<p>Derive subbasins.</p> <p>Use the pyflwdir snap function to find the most downstream points in each subbasin. If streamorder is provided it will use that instead, although defaulting to snap if there are no cells of the correct streamorder.</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>Path</code> <p>Filepath to the DEM.</p> required <code>streamorder</code> <code>int</code> <p>The stream order to delineate subbasins for.</p> <code>None</code> <code>x</code> <code>list</code> <p>X coordinates.</p> <code>[]</code> <code>y</code> <code>list</code> <p>Y coordinates.</p> <code>[]</code> <code>wbt_zip_path</code> <code>Path</code> <p>Path to WhiteboxTools binaries. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame containing polygons.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def derive_subbasins_streamorder(\n    fid: Path,\n    streamorder: int | None = None,\n    x: list[float] = [],\n    y: list[float] = [],\n    wbt_zip_path: Path | None = None,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Derive subbasins.\n\n    Use the pyflwdir snap function to find the most downstream points in each\n    subbasin. If streamorder is provided it will use that instead, although\n    defaulting to snap if there are no cells of the correct streamorder.\n\n    Args:\n        fid (Path): Filepath to the DEM.\n        streamorder (int): The stream order to delineate subbasins for.\n        x (list): X coordinates.\n        y (list): Y coordinates.\n        wbt_zip_path (Path, optional): Path to WhiteboxTools binaries. Defaults to None.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing polygons.\n    \"\"\"\n    # Load and process the DEM\n    grid, flow_dir, _ = load_and_process_dem(fid, wbt_zip_path=wbt_zip_path)\n\n    flw = pyflwdir.from_array(\n        flow_dir,\n        ftype=\"d8\",\n        check_ftype=False,\n        transform=grid.affine,\n    )\n    xy = [\n        (x_, y_)\n        for x_, y_ in zip(x, y)\n        if (x_ &gt; grid.bbox[0])\n        and (x_ &lt; grid.bbox[2])\n        and (y_ &gt; grid.bbox[1])\n        and (y_ &lt; grid.bbox[3])\n    ]\n\n    idxs, _ = flw.snap(xy=list(zip(*xy)))\n    subbasins = flw.basins(idxs=np.unique(idxs))\n\n    if streamorder is not None:\n        # Identify stream order\n        subbasins_, _ = flw.subbasins_streamorder(min_sto=streamorder)\n\n        if np.unique(subbasins_).shape[0] == 1:\n            logger.warning(\n                \"\"\"No subbasins found in `derive_subbasins_streamorder`. \n                    Instead subbasins have been selected based on the most downstream \n                    points. But you should inspect `subbasins` and probably check your \n                    DEM.\"\"\"\n            )\n        else:\n            subbasins = subbasins_\n\n    gdf_bas = vectorize(\n        subbasins.astype(np.int32), 0, flw.transform, grid.crs, name=\"basin\"\n    )\n\n    return gdf_bas\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.derive_subcatchments","title":"<code>derive_subcatchments(G, fid, method='whitebox', wbt_zip_path=None)</code>","text":"<p>Derive subcatchments from the nodes on a graph and a DEM.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>The input graph with nodes containing 'x' and 'y'.</p> required <code>fid</code> <code>Path</code> <p>Filepath to the DEM.</p> required <code>method</code> <code>str</code> <p>The method to use for conditioning.</p> <code>'whitebox'</code> <code>wbt_zip_path</code> <code>Path</code> <p>Path to WhiteboxTools binaries. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame containing polygons with columns: 'geometry', 'area', 'id', 'width', and 'slope'.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def derive_subcatchments(\n    G: nx.Graph, fid: Path, method: str = \"whitebox\", wbt_zip_path: Path | None = None\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Derive subcatchments from the nodes on a graph and a DEM.\n\n    Args:\n        G (nx.Graph): The input graph with nodes containing 'x' and 'y'.\n        fid (Path): Filepath to the DEM.\n        method (str, optional): The method to use for conditioning.\n        wbt_zip_path (Path, optional): Path to WhiteboxTools binaries. Defaults to None.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing polygons with columns:\n            'geometry', 'area', 'id', 'width', and 'slope'.\n    \"\"\"\n    # Load and process the DEM\n    grid, flow_dir, cell_slopes = load_and_process_dem(\n        fid, method, wbt_zip_path=wbt_zip_path\n    )\n\n    # Delineate catchments\n    result_polygons = delineate_catchment_pyflwdir(grid, flow_dir, G)\n\n    # Convert to GeoDataFrame\n    polys_gdf = result_polygons.dropna(subset=[\"geometry\"])\n    polys_gdf = polys_gdf[~polys_gdf[\"geometry\"].is_empty]\n\n    # Remove zero area subareas and attach to nearest polygon\n    removed_subareas: List[sgeom.Polygon] = []  # needed for mypy\n\n    def remove_(mp):\n        return remove_zero_area_subareas(mp, removed_subareas)\n\n    polys_gdf[\"geometry\"] = polys_gdf[\"geometry\"].apply(remove_)\n    polys_gdf = attach_unconnected_subareas(polys_gdf, removed_subareas)\n\n    # Calculate area and slope\n    polys_gdf[\"area\"] = polys_gdf.geometry.area\n    polys_gdf = calculate_slope(polys_gdf, grid, cell_slopes)\n\n    # Calculate width\n    polys_gdf[\"width\"] = polys_gdf[\"area\"].div(np.pi).pow(0.5)\n    return polys_gdf\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.edges_to_features","title":"<code>edges_to_features(G)</code>","text":"<p>Convert a graph to a GeoJSON edge feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>The input graph.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A GeoJSON feature collection.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def edges_to_features(G: nx.Graph):\n    \"\"\"Convert a graph to a GeoJSON edge feature collection.\n\n    Args:\n        G (nx.Graph): The input graph.\n\n    Returns:\n        dict: A GeoJSON feature collection.\n    \"\"\"\n    features = []\n    for u, v, data in G.edges(data=True):\n        if \"geometry\" not in data:\n            geom = None\n        else:\n            geom = sgeom.mapping(data[\"geometry\"])\n            del data[\"geometry\"]\n        feature = {\n            \"type\": \"Feature\",\n            \"geometry\": geom,\n            \"properties\": {\"u\": u, \"v\": v, **data},\n        }\n        features.append(feature)\n    return features\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.flwdir_whitebox","title":"<code>flwdir_whitebox(fid, wbt_zip_path=None)</code>","text":"<p>Calculate flow direction using WhiteboxTools.</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>Path</code> <p>Filepath to the DEM.</p> required <code>wbt_zip_path</code> <code>Path</code> <p>Path to WhiteboxTools binaries. If the binaries are not present, they will be downloaded. If None, the binaries will be stored temporarily and removed after the function call. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: Flow directions.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def flwdir_whitebox(fid: Path, wbt_zip_path: Path | None = None) -&gt; np.array:\n    \"\"\"Calculate flow direction using WhiteboxTools.\n\n    Args:\n        fid (Path): Filepath to the DEM.\n        wbt_zip_path (Path, optional): Path to WhiteboxTools binaries. If the binaries\n            are not present, they will be downloaded. If None, the binaries will be\n            stored temporarily and removed after the function call. Defaults to None.\n\n\n    Returns:\n        np.array: Flow directions.\n    \"\"\"\n    # Initialize WhiteboxTools\n    with tempfile.TemporaryDirectory(dir=str(fid.parent)) as temp_dir:\n        temp_path = Path(temp_dir)\n\n        # Copy raster to working directory\n        dem = temp_path / \"dem.tif\"\n        shutil.copy(fid, dem)\n\n        wbt_root = temp_path / \"WBT\"\n\n        prepare_wbt(wbt_root, zip_path=wbt_zip_path)\n\n        # Condition\n        wbt_args = {\n            \"BreachDepressions\": [\"-i=dem.tif\", \"--fillpits\", \"-o=dem_corr.tif\"],\n            \"D8Pointer\": [\"-i=dem_corr.tif\", \"-o=fdir.tif\"],\n        }\n\n        whitebox_tools(\n            temp_path,\n            wbt_args,\n            save_dir=temp_path,\n            verbose=verbose(),\n            wbt_root=wbt_root,\n            zip_path=wbt_zip_path,\n            max_procs=1,\n        )\n\n        shutil.rmtree(wbt_root)\n\n        fdir = temp_path / \"fdir.tif\"\n        if not Path(fdir).exists():\n            raise ValueError(\"Flow direction raster not created.\")\n\n        with rst.open(fdir) as src:\n            flow_dir = src.read(1)\n\n    # Adjust mapping from WhiteboxTools to pyflwdir\n    mapping = {1: 128, 2: 1, 4: 2, 8: 4, 16: 8, 32: 16, 64: 32, 128: 64}\n    get_flow_dir = np.vectorize(mapping.get, excluded=[\"default\"])\n    flow_dir = get_flow_dir(flow_dir, 0)\n    return flow_dir\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.get_transformer","title":"<code>get_transformer(source_crs, target_crs)</code>","text":"<p>Get a transformer object for reprojection.</p> <p>Parameters:</p> Name Type Description Default <code>source_crs</code> <code>str</code> <p>Source CRS in EPSG format (e.g., EPSG:32630).</p> required <code>target_crs</code> <code>str</code> <p>Target CRS in EPSG format (e.g., EPSG:32630).</p> required <p>Returns:</p> Type Description <code>Transformer</code> <p>pyproj.Transformer: Transformer object for reprojection.</p> Example <p>transformer = get_transformer('EPSG:4326', 'EPSG:32630') x, y = transformer.transform(-0.1276, 51.5074) print(f\"{x:.6f}, {y:.6f}\") 699330.110690, 5710164.303007</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def get_transformer(source_crs: str, target_crs: str) -&gt; pyproj.Transformer:\n    \"\"\"Get a transformer object for reprojection.\n\n    Args:\n        source_crs (str): Source CRS in EPSG format (e.g., EPSG:32630).\n        target_crs (str): Target CRS in EPSG format (e.g., EPSG:32630).\n\n    Returns:\n        pyproj.Transformer: Transformer object for reprojection.\n\n    Example:\n        &gt;&gt;&gt; transformer = get_transformer('EPSG:4326', 'EPSG:32630')\n        &gt;&gt;&gt; x, y = transformer.transform(-0.1276, 51.5074)\n        &gt;&gt;&gt; print(f\"{x:.6f}, {y:.6f}\")\n        699330.110690, 5710164.303007\n    \"\"\"\n    return pyproj.Transformer.from_crs(source_crs, target_crs, always_xy=True)\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.get_utm_epsg","title":"<code>get_utm_epsg(x, y, crs='EPSG:4326', datum_name='WGS 84')</code>","text":"<p>Get the UTM CRS code for a given coordinate.</p> <p>Note, this function is taken from GeoPandas and modified to use for getting the UTM CRS code for a given coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Longitude in crs</p> required <code>y</code> <code>float</code> <p>Latitude in crs</p> required <code>crs</code> <code>str | int | CRS</code> <p>The CRS of the input coordinates. Defaults to 'EPSG:4326'.</p> <code>'EPSG:4326'</code> <code>datum_name</code> <code>str</code> <p>The datum name to use for the UTM CRS</p> <code>'WGS 84'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted EPSG code for the UTM zone.</p> Example <p>get_utm_epsg(-0.1276, 51.5074) 'EPSG:32630'</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def get_utm_epsg(\n    x: float,\n    y: float,\n    crs: str | int | pyproj.CRS = \"EPSG:4326\",\n    datum_name: str = \"WGS 84\",\n) -&gt; str:\n    \"\"\"Get the UTM CRS code for a given coordinate.\n\n    Note, this function is taken from GeoPandas and modified to use\n    for getting the UTM CRS code for a given coordinate.\n\n    Args:\n        x (float): Longitude in crs\n        y (float): Latitude in crs\n        crs (str | int | pyproj.CRS, optional): The CRS of the input\n            coordinates. Defaults to 'EPSG:4326'.\n        datum_name (str, optional): The datum name to use for the UTM CRS\n\n    Returns:\n        str: Formatted EPSG code for the UTM zone.\n\n    Example:\n        &gt;&gt;&gt; get_utm_epsg(-0.1276, 51.5074)\n        'EPSG:32630'\n    \"\"\"\n    if not isinstance(x, float) or not isinstance(y, float):\n        raise TypeError(\"x and y must be floats\")\n\n    try:\n        crs = pyproj.CRS(crs)\n    except pyproj.exceptions.CRSError:\n        raise ValueError(\"Invalid CRS\")\n\n    # ensure using geographic coordinates\n    if pyproj.CRS(crs).is_geographic:\n        lon = x\n        lat = y\n    else:\n        transformer = TransformerFromCRS(crs, \"EPSG:4326\", always_xy=True)\n        lon, lat = transformer.transform(x, y)\n    utm_crs_list = pyproj.database.query_utm_crs_info(\n        datum_name=datum_name,\n        area_of_interest=pyproj.aoi.AreaOfInterest(\n            west_lon_degree=lon,\n            south_lat_degree=lat,\n            east_lon_degree=lon,\n            north_lat_degree=lat,\n        ),\n    )\n    return f\"{utm_crs_list[0].auth_name}:{utm_crs_list[0].code}\"\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.graph_to_geojson","title":"<code>graph_to_geojson(graph, fid_nodes, fid_edges, crs)</code>","text":"<p>Write a graph to a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>The input graph.</p> required <code>fid_nodes</code> <code>Path</code> <p>The filepath to save the nodes GeoJSON file.</p> required <code>fid_edges</code> <code>Path</code> <p>The filepath to save the edges GeoJSON file.</p> required <code>crs</code> <code>str</code> <p>The CRS of the graph.</p> required Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def graph_to_geojson(graph: nx.Graph, fid_nodes: Path, fid_edges: Path, crs: str):\n    \"\"\"Write a graph to a GeoJSON file.\n\n    Args:\n        graph (nx.Graph): The input graph.\n        fid_nodes (Path): The filepath to save the nodes GeoJSON file.\n        fid_edges (Path): The filepath to save the edges GeoJSON file.\n        crs (str): The CRS of the graph.\n    \"\"\"\n    graph = graph.copy()\n    nodes = nodes_to_features(graph)\n    edges = edges_to_features(graph)\n\n    for iterable, fid in zip([nodes, edges], [fid_nodes, fid_edges]):\n        geojson = {\n            \"type\": \"FeatureCollection\",\n            \"features\": iterable,\n            \"crs\": {\n                \"type\": \"name\",\n                \"properties\": {\n                    \"name\": \"urn:ogc:def:crs:{0}\".format(crs.replace(\":\", \"::\"))\n                },\n            },\n        }\n\n        with fid.open(\"w\") as output_file:\n            json.dump(geojson, output_file, indent=2)\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.interp_with_nans","title":"<code>interp_with_nans(xy, interp, grid, values)</code>","text":"<p>Wrap the interpolation function to handle NaNs.</p> <p>Picks the nearest non NaN grid point if the interpolated value is NaN, otherwise returns the interpolated value.</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>tuple</code> <p>Coordinate of interest</p> required <code>interp</code> <code>RegularGridInterpolator</code> <p>The interpolator object.</p> required <code>grid</code> <code>ndarray</code> <p>List of xy coordinates of the grid points.</p> required <code>values</code> <code>list</code> <p>The list of values at each point in the grid.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interpolated value.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def interp_with_nans(\n    xy: tuple[float, float],\n    interp: RegularGridInterpolator,\n    grid: np.ndarray,\n    values: list[float],\n) -&gt; float:\n    \"\"\"Wrap the interpolation function to handle NaNs.\n\n    Picks the nearest non NaN grid point if the interpolated value is NaN,\n    otherwise returns the interpolated value.\n\n    Args:\n        xy (tuple): Coordinate of interest\n        interp (RegularGridInterpolator): The interpolator object.\n        grid (np.ndarray): List of xy coordinates of the grid points.\n        values (list): The list of values at each point in the grid.\n\n    Returns:\n        float: The interpolated value.\n    \"\"\"\n    # Call the interpolator\n    val = float(interp(xy))\n    # If the value is NaN, we need to pick nearest non nan grid point\n    if np.isnan(val):\n        # Get the distances to all grid points\n        distances = np.linalg.norm(grid - xy, axis=1)\n        # Get the indices of the grid points sorted by distance\n        indices = np.argsort(distances)\n        # Iterate over the grid points in order of increasing distance\n        for index in indices:\n            # If the value at this grid point is not NaN, return it\n            if not np.isnan(values[index]):\n                return values[index]\n    else:\n        return val\n\n    raise ValueError(\"No non NaN values found in grid.\")\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.interpolate_points_on_raster","title":"<code>interpolate_points_on_raster(x, y, elevation_fid)</code>","text":"<p>Interpolate points on a raster.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>X coordinates.</p> required <code>y</code> <code>list</code> <p>Y coordinates.</p> required <code>elevation_fid</code> <code>Path</code> <p>Filepath to elevation raster.</p> required <p>Returns:</p> Name Type Description <code>elevation</code> <code>float</code> <p>Elevation at point.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def interpolate_points_on_raster(\n    x: list[float], y: list[float], elevation_fid: Path\n) -&gt; list[float]:\n    \"\"\"Interpolate points on a raster.\n\n    Args:\n        x (list): X coordinates.\n        y (list): Y coordinates.\n        elevation_fid (Path): Filepath to elevation raster.\n\n    Returns:\n        elevation (float): Elevation at point.\n    \"\"\"\n    with rst.open(elevation_fid) as src:\n        # Read the raster data\n        data = src.read(1).astype(float)  # Assuming it's a single-band raster\n        data[data == src.nodata] = None\n\n        # Get the raster's coordinates\n        x_grid = np.linspace(src.bounds.left, src.bounds.right, src.width)\n        y_grid = np.linspace(src.bounds.bottom, src.bounds.top, src.height)\n\n        # Define grid\n        xx, yy = np.meshgrid(x_grid, y_grid)\n        grid = np.vstack([xx.ravel(), yy.ravel()]).T\n        values = data.ravel()\n\n        # Define interpolator\n        interp = RegularGridInterpolator(\n            (y_grid, x_grid),\n            np.flipud(data),\n            method=\"linear\",\n            bounds_error=False,\n            fill_value=None,\n        )\n        # Interpolate for x,y\n        return [\n            interp_with_nans((y_, x_), interp, grid, values) for x_, y_ in zip(x, y)\n        ]\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.load_and_process_dem","title":"<code>load_and_process_dem(fid, method='whitebox', wbt_zip_path=None)</code>","text":"<p>Load and condition a DEM.</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>Path</code> <p>Filepath to the DEM.</p> required <code>method</code> <code>str</code> <p>The method to use for conditioning. Defaults to \"whitebox\".</p> <code>'whitebox'</code> <code>wbt_zip_path</code> <code>Path</code> <p>Path to WhiteboxTools binaries. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Grid, array, array]</code> <p>A tuple containing the grid, flow directions, and cell slopes.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def load_and_process_dem(\n    fid: Path,\n    method: str = \"whitebox\",\n    wbt_zip_path: Path | None = None,\n) -&gt; tuple[Grid, np.array, np.array]:\n    \"\"\"Load and condition a DEM.\n\n    Args:\n        fid (Path): Filepath to the DEM.\n        method (str, optional): The method to use for conditioning. Defaults to\n            \"whitebox\".\n        wbt_zip_path (Path, optional): Path to WhiteboxTools binaries. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the grid, flow directions, and cell slopes.\n    \"\"\"\n    with rst.open(fid, \"r\") as src:\n        elevtn = src.read(1).astype(float)\n        nodata = float(src.nodata)\n        transform = src.transform\n        crs = src.crs\n\n    if method not in (\"whitebox\", \"pyflwdir\"):\n        raise ValueError(\"Method must be 'whitebox' or 'pyflwdir'.\")\n\n    if method == \"whitebox\":\n        flow_dir = flwdir_whitebox(fid, wbt_zip_path=wbt_zip_path)\n    elif method == \"pyflwdir\":\n        flw = pyflwdir.from_dem(\n            data=elevtn,\n            nodata=nodata,\n            transform=transform,\n            latlon=crs.is_geographic,\n        )\n        flow_dir = flw.to_array(ftype=\"d8\").astype(int)\n\n    cell_slopes = pyflwdir.dem.slope(\n        elevtn,\n        nodata=nodata,\n        transform=transform,\n        latlon=crs.is_geographic,\n    )\n\n    grid = Grid(transform, elevtn.shape, crs, src.bounds)\n\n    return grid, flow_dir, cell_slopes\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.merge_points","title":"<code>merge_points(coordinates, threshold)</code>","text":"<p>Merge points that are within a threshold distance.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>list</code> <p>List of coordinates as tuples.</p> required <code>threshold</code> <code>float</code> <p>The threshold distance for merging points.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping the original point index to the merged point and new coordinate.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def merge_points(coordinates: list[tuple[float, float]], threshold: float) -&gt; dict:\n    \"\"\"Merge points that are within a threshold distance.\n\n    Args:\n        coordinates (list): List of coordinates as tuples.\n        threshold(float): The threshold distance for merging points.\n\n    Returns:\n        dict: A dictionary mapping the original point index to the merged point\n            and new coordinate.\n    \"\"\"\n    # Create a KDTtree to pair together points within thresholds\n    tree = KDTree(coordinates)\n    pairs = tree.query_pairs(threshold)\n\n    # Merge pairs into families of points that are all nearby\n    families: list = []\n\n    for pair in pairs:\n        matched_families = [\n            family for family in families if pair[0] in family or pair[1] in family\n        ]\n\n        if matched_families:\n            # Merge all matched families and add the current pair\n            new_family = set(pair)\n            for family in matched_families:\n                new_family.update(family)\n\n            # Remove the old families and add the newly formed one\n            for family in matched_families:\n                families.remove(family)\n            families.append(new_family)\n        else:\n            # No matching family found, so create a new one\n            families.append(set(pair))\n\n    # Create a mapping of the original point to the merged point\n    mapping = {}\n    for family in families:\n        average_point = np.mean([coordinates[i] for i in family], axis=0)\n        family_head = min(list(family))\n        for i in family:\n            mapping[i] = {\"maps_to\": family_head, \"coordinate\": tuple(average_point)}\n    return mapping\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.nearest_node_buffer","title":"<code>nearest_node_buffer(points1, points2, threshold)</code>","text":"<p>Find the nearest node within a given buffer threshold.</p> <p>Parameters:</p> Name Type Description Default <code>points1</code> <code>dict</code> <p>A dictionary where keys are labels and values are Shapely points geometries.</p> required <code>points2</code> <code>dict</code> <p>A dictionary where keys are labels and values are Shapely points geometries.</p> required <code>threshold</code> <code>float</code> <p>The maximum distance for a node to be considered 'nearest'. If no nodes are within this distance, the node is not included in the output.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary where keys are labels from points1 and values are labels from points2 of the nearest nodes within the threshold.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def nearest_node_buffer(\n    points1: dict[str, sgeom.Point], points2: dict[str, sgeom.Point], threshold: float\n) -&gt; dict:\n    \"\"\"Find the nearest node within a given buffer threshold.\n\n    Args:\n        points1 (dict): A dictionary where keys are labels and values are\n            Shapely points geometries.\n        points2 (dict): A dictionary where keys are labels and values are\n            Shapely points geometries.\n        threshold (float): The maximum distance for a node to be considered\n            'nearest'. If no nodes are within this distance, the node is not\n            included in the output.\n\n    Returns:\n        dict: A dictionary where keys are labels from points1 and values are\n            labels from points2 of the nearest nodes within the threshold.\n    \"\"\"\n    if not points1 or not points2:\n        return {}\n\n    # Convert the keys of points2 to a list\n    labels2 = list(points2.keys())\n\n    # Create a spatial index\n    tree = STRtree(list(points2.values()))\n\n    # Initialize an empty dictionary to store the matching nodes\n    matching = {}\n\n    # Iterate over points1\n    for key, geom in points1.items():\n        # Find the nearest node in the spatial index to the current geometry\n        nearest = tree.nearest(geom)\n        nearest_geom = points2[labels2[nearest]]\n\n        # If the nearest node is within the threshold, add it to the\n        # matching dictionary\n        if geom.buffer(threshold).intersects(nearest_geom):\n            matching[key] = labels2[nearest]\n\n    # Return the matching dictionary\n    return matching\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.nodes_to_features","title":"<code>nodes_to_features(G)</code>","text":"<p>Convert a graph to a GeoJSON node feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>The input graph.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A GeoJSON feature collection.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def nodes_to_features(G: nx.Graph):\n    \"\"\"Convert a graph to a GeoJSON node feature collection.\n\n    Args:\n        G (nx.Graph): The input graph.\n\n    Returns:\n        dict: A GeoJSON feature collection.\n    \"\"\"\n    features = []\n    for node, data in G.nodes(data=True):\n        feature = {\n            \"type\": \"Feature\",\n            \"geometry\": sgeom.mapping(sgeom.Point(data[\"x\"], data[\"y\"])),\n            \"properties\": {\"id\": node, **data},\n        }\n        features.append(feature)\n    return features\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.remove_intersections","title":"<code>remove_intersections(polys)</code>","text":"<p>Remove intersections from a GeoDataFrame of polygons.</p> <p>Subcatchments are derived for a given point, and so larger subcatchments will contain smaller ones. This function removes the smaller subcatchments from the larger ones.</p> <p>Parameters:</p> Name Type Description Default <code>polys</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing polygons with columns: 'geometry', 'area', and 'id'.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame containing polygons with no intersections.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def remove_intersections(polys: gpd.GeoDataFrame) -&gt; gpd.GeoDataFrame:\n    \"\"\"Remove intersections from a GeoDataFrame of polygons.\n\n    Subcatchments are derived for a given point, and so larger subcatchments\n    will contain smaller ones. This function removes the smaller subcatchments\n    from the larger ones.\n\n    Args:\n        polys (gpd.GeoDataFrame): A GeoDataFrame containing polygons with\n            columns: 'geometry', 'area', and 'id'.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing polygons with no\n            intersections.\n    \"\"\"\n    result_polygons = polys.copy()\n\n    # Sort the polygons by area (smallest first)\n    result_polygons = (\n        result_polygons.assign(area=result_polygons.geometry.area)\n        .sort_values(\"area\", ascending=True)\n        .reset_index(drop=True)\n    )\n\n    # Store the area of 'trimmed' polygons into a combined geometry, starting\n    # with the smallest area polygon\n    minimal_geom = result_polygons.iloc[0][\"geometry\"]\n    for idx, row in tqdm(\n        result_polygons.iloc[1:].iterrows(),\n        total=result_polygons.shape[0] - 1,\n        disable=not verbose(),\n    ):\n        # Trim the polygon by the combined geometry\n        result_polygons.at[idx, \"geometry\"] = row[\"geometry\"].difference(minimal_geom)\n\n        # Update the combined geometry with the new polygon\n        minimal_geom = minimal_geom.union(row[\"geometry\"])\n\n    # Sort the polygons by area (largest first) - this is just to conform to\n    # the unit test and is not strictly essential\n    result_polygons = result_polygons.sort_values(\"area\", ascending=False).drop(\n        \"area\", axis=1\n    )\n\n    return result_polygons\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.remove_zero_area_subareas","title":"<code>remove_zero_area_subareas(mp, removed_subareas)</code>","text":"<p>Remove subareas with zero area from a multipolygon.</p> <p>Parameters:</p> Name Type Description Default <code>mp</code> <code>MultiPolygon</code> <p>A multipolygon.</p> required <code>removed_subareas</code> <code>List[Polygon]</code> <p>A list of removed subareas.</p> required <p>Returns:</p> Type Description <code>MultiPolygon</code> <p>sgeom.MultiPolygon: A multipolygon with zero area subareas removed.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def remove_zero_area_subareas(\n    mp: sgeom.MultiPolygon, removed_subareas: List[sgeom.Polygon]\n) -&gt; sgeom.MultiPolygon:\n    \"\"\"Remove subareas with zero area from a multipolygon.\n\n    Args:\n        mp (sgeom.MultiPolygon): A multipolygon.\n        removed_subareas (List[sgeom.Polygon]): A list of removed subareas.\n\n    Returns:\n        sgeom.MultiPolygon: A multipolygon with zero area subareas removed.\n    \"\"\"\n    if not hasattr(mp, \"geoms\"):\n        return mp\n\n    largest = max(mp.geoms, key=lambda x: x.area)\n    removed = [subarea for subarea in mp.geoms if subarea != largest]\n    removed_subareas.extend(removed)\n    return largest\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.reproject_df","title":"<code>reproject_df(df, source_crs, target_crs)</code>","text":"<p>Reproject the coordinates in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame with columns 'longitude' and 'latitude'.</p> required <code>source_crs</code> <code>str</code> <p>Source CRS in EPSG format (e.g., EPSG:4326).</p> required <code>target_crs</code> <code>str</code> <p>Target CRS in EPSG format (e.g., EPSG:32630).</p> required Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def reproject_df(df: pd.DataFrame, source_crs: str, target_crs: str) -&gt; pd.DataFrame:\n    \"\"\"Reproject the coordinates in a DataFrame.\n\n    Args:\n        df (pd.DataFrame): DataFrame with columns 'longitude' and 'latitude'.\n        source_crs (str): Source CRS in EPSG format (e.g., EPSG:4326).\n        target_crs (str): Target CRS in EPSG format (e.g., EPSG:32630).\n    \"\"\"\n    # Function to transform coordinates\n    pts = gpd.points_from_xy(df[\"longitude\"], df[\"latitude\"], crs=source_crs).to_crs(\n        target_crs\n    )\n    df = df.copy()\n    df[\"x\"] = pts.x\n    df[\"y\"] = pts.y\n    return df\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.reproject_graph","title":"<code>reproject_graph(G, source_crs, target_crs)</code>","text":"<p>Reproject the coordinates in a graph.</p> <p>osmnx.projection.project_graph might be suitable if some other behaviour needs to be captured, but it currently fails the tests so I will ignore for now.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph with nodes containing 'x' and 'y' properties.</p> required <code>source_crs</code> <code>str</code> <p>Source CRS in EPSG format (e.g., EPSG:4326).</p> required <code>target_crs</code> <code>str</code> <p>Target CRS in EPSG format (e.g., EPSG:32630).</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>nx.Graph: Graph with nodes containing 'x' and 'y' properties.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def reproject_graph(G: nx.Graph, source_crs: str, target_crs: str) -&gt; nx.Graph:\n    \"\"\"Reproject the coordinates in a graph.\n\n    osmnx.projection.project_graph might be suitable if some other behaviour\n    needs to be captured, but it currently fails the tests so I will ignore for\n    now.\n\n    Args:\n        G (nx.Graph): Graph with nodes containing 'x' and 'y' properties.\n        source_crs (str): Source CRS in EPSG format (e.g., EPSG:4326).\n        target_crs (str): Target CRS in EPSG format (e.g., EPSG:32630).\n\n    Returns:\n        nx.Graph: Graph with nodes containing 'x' and 'y' properties.\n    \"\"\"\n    # Create a PyProj transformer for CRS conversion\n    transformer = get_transformer(source_crs, target_crs)\n\n    # Create a new graph with the converted nodes and edges\n    G_new = G.copy()\n\n    # Convert and add nodes with 'x', 'y' properties\n    for node, data in G_new.nodes(data=True):\n        x, y = transformer.transform(data[\"x\"], data[\"y\"])\n        data[\"x\"] = x\n        data[\"y\"] = y\n\n    # Convert and add edges with 'geometry' property\n    for u, v, data in G_new.edges(data=True):\n        if \"geometry\" in data.keys():\n            data[\"geometry\"] = sgeom.LineString(\n                itertools.starmap(transformer.transform, data[\"geometry\"].coords)\n            )\n        else:\n            data[\"geometry\"] = sgeom.LineString(\n                [\n                    [G_new.nodes[u][\"x\"], G_new.nodes[u][\"y\"]],\n                    [G_new.nodes[v][\"x\"], G_new.nodes[v][\"y\"]],\n                ]\n            )\n    G_new.graph[\"crs\"] = target_crs\n    return G_new\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.reproject_raster","title":"<code>reproject_raster(target_crs, fid, new_fid=None)</code>","text":"<p>Reproject a raster to a new CRS.</p> <p>Parameters:</p> Name Type Description Default <code>target_crs</code> <code>str</code> <p>Target CRS in EPSG format (e.g., EPSG:32630).</p> required <code>fid</code> <code>Path</code> <p>Filepath to the raster to reproject.</p> required <code>new_fid</code> <code>Path</code> <p>Filepath to save the reprojected raster. Defaults to None, which will just use fid with '_reprojected'.</p> <code>None</code> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def reproject_raster(\n    target_crs: str, fid: Path, new_fid: Optional[Path] = None\n) -&gt; None:\n    \"\"\"Reproject a raster to a new CRS.\n\n    Args:\n        target_crs (str): Target CRS in EPSG format (e.g., EPSG:32630).\n        fid (Path): Filepath to the raster to reproject.\n        new_fid (Path, optional): Filepath to save the reprojected raster.\n            Defaults to None, which will just use fid with '_reprojected'.\n    \"\"\"\n    # Open the raster\n    with rioxarray.open_rasterio(fid) as raster:\n        # Reproject the raster\n        reprojected = raster.rio.reproject(target_crs)\n\n        # Define the output filepath\n        if new_fid is None:\n            new_fid = Path(str(fid.with_suffix(\"\")) + \"_reprojected.tif\")\n\n        # Save the reprojected raster\n        reprojected.rio.to_raster(new_fid)\n</code></pre>"},{"location":"reference-geospatial-utilities/#swmmanywhere.geospatial_utilities.vectorize","title":"<code>vectorize(data, nodata, transform, crs, name='value')</code>","text":"<p>Vectorize raster data into a geodataframe.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>The raster data.</p> required <code>nodata</code> <code>float</code> <p>The nodata value.</p> required <code>transform</code> <code>Affine</code> <p>The affine transformation.</p> required <code>crs</code> <code>int</code> <p>The CRS of the data.</p> required <code>name</code> <code>str</code> <p>The name of the data. Defaults to \"value\".</p> <code>'value'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame containing the vectorized data.</p> Source code in <code>swmmanywhere/geospatial_utilities.py</code> <pre><code>def vectorize(\n    data: np.ndarray,\n    nodata: float,\n    transform: rst.Affine,\n    crs: int,\n    name: str = \"value\",\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Vectorize raster data into a geodataframe.\n\n    Args:\n        data (np.ndarray): The raster data.\n        nodata (float): The nodata value.\n        transform (rst.Affine): The affine transformation.\n        crs (int): The CRS of the data.\n        name (str, optional): The name of the data. Defaults to \"value\".\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing the vectorized data.\n    \"\"\"\n    feats_gen = features.shapes(\n        data,\n        mask=data != nodata,\n        transform=transform,\n        connectivity=8,\n    )\n    feats = [\n        {\"geometry\": geom, \"properties\": {name: val}} for geom, val in list(feats_gen)\n    ]\n\n    # parse to geopandas for plotting / writing to file\n    gdf = gpd.GeoDataFrame.from_features(feats, crs=crs)\n    gdf[name] = gdf[name].astype(data.dtype)\n    return gdf\n</code></pre>"},{"location":"reference-graph-utilities/","title":"Reference for SWMManywhere/graph_utilities.py","text":"<p>Graph utilities module for SWMManywhere.</p> <p>A module to contain graphfcns, the graphfcn registry object, and other graph utilities (such as save/load functions).</p>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.BaseGraphFunction","title":"<code>BaseGraphFunction</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for graph functions.</p> <p>On a SWMManywhere project the intention is to iterate over a number of graph functions. Each graph function may require certain attributes to be present in the graph. Each graph function may add attributes to the graph. This class provides a framework for graph functions to check their requirements and additions a-priori when the list is provided.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>class BaseGraphFunction(ABC):\n    \"\"\"Base class for graph functions.\n\n    On a SWMManywhere project the intention is to iterate over a number of\n    graph functions. Each graph function may require certain attributes to\n    be present in the graph. Each graph function may add attributes to the\n    graph. This class provides a framework for graph functions to check\n    their requirements and additions a-priori when the list is provided.\n    \"\"\"\n\n    required_edge_attributes: List[str] = []\n    adds_edge_attributes: List[str] = []\n    required_node_attributes: List[str] = []\n    adds_node_attributes: List[str] = []\n\n    def __init_subclass__(\n        cls,\n        required_edge_attributes: Optional[List[str]] = None,\n        adds_edge_attributes: Optional[List[str]] = None,\n        required_node_attributes: Optional[List[str]] = None,\n        adds_node_attributes: Optional[List[str]] = None,\n    ):\n        \"\"\"Set the required and added attributes for the subclass.\"\"\"\n        cls.required_edge_attributes = required_edge_attributes or []\n        cls.adds_edge_attributes = adds_edge_attributes or []\n        cls.required_node_attributes = required_node_attributes or []\n        cls.adds_node_attributes = adds_node_attributes or []\n\n    @abstractmethod\n    def __call__(self, G: nx.Graph, *args, **kwargs) -&gt; nx.Graph:\n        \"\"\"Run the graph function.\"\"\"\n        return G\n\n    def validate_requirements(self, edge_attributes: set, node_attributes: set) -&gt; None:\n        \"\"\"Validate that the graph has the required attributes.\"\"\"\n        for attribute in self.required_edge_attributes:\n            assert attribute in edge_attributes, f\"{attribute} not in edge attributes\"\n\n        for attribute in self.required_node_attributes:\n            assert attribute in node_attributes, f\"{attribute} not in node attributes\"\n\n    def add_graphfcn(\n        self, edge_attributes: set, node_attributes: set\n    ) -&gt; tuple[set, set]:\n        \"\"\"Add the attributes that the graph function adds.\"\"\"\n        self.validate_requirements(edge_attributes, node_attributes)\n        edge_attributes = edge_attributes.union(self.adds_edge_attributes)\n        node_attributes = node_attributes.union(self.adds_node_attributes)\n        return edge_attributes, node_attributes\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.BaseGraphFunction.__call__","title":"<code>__call__(G, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Run the graph function.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>@abstractmethod\ndef __call__(self, G: nx.Graph, *args, **kwargs) -&gt; nx.Graph:\n    \"\"\"Run the graph function.\"\"\"\n    return G\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.BaseGraphFunction.__init_subclass__","title":"<code>__init_subclass__(required_edge_attributes=None, adds_edge_attributes=None, required_node_attributes=None, adds_node_attributes=None)</code>","text":"<p>Set the required and added attributes for the subclass.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def __init_subclass__(\n    cls,\n    required_edge_attributes: Optional[List[str]] = None,\n    adds_edge_attributes: Optional[List[str]] = None,\n    required_node_attributes: Optional[List[str]] = None,\n    adds_node_attributes: Optional[List[str]] = None,\n):\n    \"\"\"Set the required and added attributes for the subclass.\"\"\"\n    cls.required_edge_attributes = required_edge_attributes or []\n    cls.adds_edge_attributes = adds_edge_attributes or []\n    cls.required_node_attributes = required_node_attributes or []\n    cls.adds_node_attributes = adds_node_attributes or []\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.BaseGraphFunction.add_graphfcn","title":"<code>add_graphfcn(edge_attributes, node_attributes)</code>","text":"<p>Add the attributes that the graph function adds.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def add_graphfcn(\n    self, edge_attributes: set, node_attributes: set\n) -&gt; tuple[set, set]:\n    \"\"\"Add the attributes that the graph function adds.\"\"\"\n    self.validate_requirements(edge_attributes, node_attributes)\n    edge_attributes = edge_attributes.union(self.adds_edge_attributes)\n    node_attributes = node_attributes.union(self.adds_node_attributes)\n    return edge_attributes, node_attributes\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.BaseGraphFunction.validate_requirements","title":"<code>validate_requirements(edge_attributes, node_attributes)</code>","text":"<p>Validate that the graph has the required attributes.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def validate_requirements(self, edge_attributes: set, node_attributes: set) -&gt; None:\n    \"\"\"Validate that the graph has the required attributes.\"\"\"\n    for attribute in self.required_edge_attributes:\n        assert attribute in edge_attributes, f\"{attribute} not in edge attributes\"\n\n    for attribute in self.required_node_attributes:\n        assert attribute in node_attributes, f\"{attribute} not in node attributes\"\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.GraphFunctionRegistry","title":"<code>GraphFunctionRegistry</code>","text":"<p>               Bases: <code>dict</code></p> <p>Registry object.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>class GraphFunctionRegistry(dict):\n    \"\"\"Registry object.\"\"\"\n\n    def register(self, cls):\n        \"\"\"Register a graph function.\"\"\"\n        if cls.__name__ in self:\n            raise ValueError(f\"{cls.__name__} already in the graph functions registry!\")\n\n        self[cls.__name__] = cls()\n        return cls\n\n    def __getattr__(self, name):\n        \"\"\"Get a graph function from the graphfcn dict.\"\"\"\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError(f\"{name} NOT in the graph functions registry!\")\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.GraphFunctionRegistry.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Get a graph function from the graphfcn dict.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"Get a graph function from the graphfcn dict.\"\"\"\n    try:\n        return self[name]\n    except KeyError:\n        raise AttributeError(f\"{name} NOT in the graph functions registry!\")\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.GraphFunctionRegistry.register","title":"<code>register(cls)</code>","text":"<p>Register a graph function.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def register(self, cls):\n    \"\"\"Register a graph function.\"\"\"\n    if cls.__name__ in self:\n        raise ValueError(f\"{cls.__name__} already in the graph functions registry!\")\n\n    self[cls.__name__] = cls()\n    return cls\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.filter_streets","title":"<code>filter_streets(G)</code>","text":"<p>Filter streets.</p> <p>This function removes non streets from a graph.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>A graph</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>A graph of only street edges</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def filter_streets(G):\n    \"\"\"Filter streets.\n\n    This function removes non streets from a graph.\n\n    Args:\n        G (nx.Graph): A graph\n\n    Returns:\n       (nx.Graph): A graph of only street edges\n    \"\"\"\n    G = G.copy()\n    # Remove non-street edges/nodes and unconnected nodes\n    nodes_to_remove = []\n    for u, v, d in G.edges(data=True):\n        if d[\"edge_type\"] != \"street\":\n            if d[\"edge_type\"] == \"outfall\":\n                nodes_to_remove.append(v)\n            else:\n                nodes_to_remove.extend((u, v))\n    G.remove_nodes_from(nodes_to_remove)\n    return G\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.iterate_graphfcns","title":"<code>iterate_graphfcns(G, graphfcn_list, params=parameters.get_full_parameters(), addresses=temp_addresses)</code>","text":"<p>Iterate a list of graph functions over a graph.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>The graph to iterate over.</p> required <code>graphfcn_list</code> <code>list[str]</code> <p>A list of graph functions to iterate.</p> required <code>params</code> <code>dict</code> <p>A dictionary of parameters to pass to the graph functions.</p> <code>get_full_parameters()</code> <code>addresses</code> <code>FilePaths</code> <p>A FilePaths parameter object</p> <code>temp_addresses</code> <p>Returns:</p> Type Description <code>Graph</code> <p>nx.Graph: The graph after the graph functions have been applied.</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def iterate_graphfcns(\n    G: nx.Graph,\n    graphfcn_list: list[str],\n    params: dict = parameters.get_full_parameters(),\n    addresses: FilePaths = temp_addresses,\n) -&gt; nx.Graph:\n    \"\"\"Iterate a list of graph functions over a graph.\n\n    Args:\n        G (nx.Graph): The graph to iterate over.\n        graphfcn_list (list[str]): A list of graph functions to iterate.\n        params (dict): A dictionary of parameters to pass to the graph\n            functions.\n        addresses (FilePaths): A FilePaths parameter object\n\n    Returns:\n        nx.Graph: The graph after the graph functions have been applied.\n    \"\"\"\n    validate_graphfcn_list(graphfcn_list)\n\n    for function in graphfcn_list:\n        G = graphfcns[function](G, addresses=addresses, **params)\n        if len(filter_streets(G).edges) == 0:\n            logger.warning(\n                f\"\"\"graphfcn: {function} removed all edges, \n                           returning graph.\"\"\"\n            )\n            return G\n        else:\n            logger.info(f\"graphfcn: {function} completed.\")\n\n        if verbose():\n            save_graph(G, addresses.model_paths.model / f\"{function}_graph.json\")\n            go.graph_to_geojson(\n                graphfcns.fix_geometries(G),\n                addresses.model_paths.model / f\"{function}_nodes.geojson\",\n                addresses.model_paths.model / f\"{function}_edges.geojson\",\n                G.graph[\"crs\"],\n            )\n    return G\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.load_graph","title":"<code>load_graph(fid)</code>","text":"<p>Load a graph from a file saved with save_graph.</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>Path</code> <p>The path to the file</p> required <p>Returns:</p> Name Type Description <code>G</code> <code>Graph</code> <p>A graph</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def load_graph(fid: Path) -&gt; nx.Graph:\n    \"\"\"Load a graph from a file saved with save_graph.\n\n    Args:\n        fid (Path): The path to the file\n\n    Returns:\n        G (nx.Graph): A graph\n    \"\"\"\n    json_data = json.loads(fid.read_text())\n\n    G = nx.node_link_graph(json_data, directed=True)\n    for u, v, data in G.edges(data=True):\n        if \"geometry\" in data:\n            geometry_coords = data[\"geometry\"]\n            line_string = shapely.LineString(shapely.wkt.loads(geometry_coords))\n            data[\"geometry\"] = line_string\n    return G\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.register_graphfcn","title":"<code>register_graphfcn(cls)</code>","text":"<p>Register a graph function.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Callable</code> <p>A class that inherits from BaseGraphFunction</p> required <p>Returns:</p> Name Type Description <code>cls</code> <code>Callable</code> <p>The same class</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def register_graphfcn(cls) -&gt; Callable:\n    \"\"\"Register a graph function.\n\n    Args:\n        cls (Callable): A class that inherits from BaseGraphFunction\n\n    Returns:\n        cls (Callable): The same class\n    \"\"\"\n    graphfcns.register(cls)\n    return cls\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.save_graph","title":"<code>save_graph(G, fid)</code>","text":"<p>Save a graph to a file.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>A graph</p> required <code>fid</code> <code>Path</code> <p>The path to the file</p> required Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def save_graph(G: nx.Graph, fid: Path) -&gt; None:\n    \"\"\"Save a graph to a file.\n\n    Args:\n        G (nx.Graph): A graph\n        fid (Path): The path to the file\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", FutureWarning)\n        json_data = nx.node_link_data(G)\n\n    with fid.open(\"w\") as file:\n        json.dump(json_data, file, default=_serialize_line_string)\n</code></pre>"},{"location":"reference-graph-utilities/#swmmanywhere.graph_utilities.validate_graphfcn_list","title":"<code>validate_graphfcn_list(graphfcn_list, starting_graph=None)</code>","text":"<p>Validate that the graph functions are registered.</p> <p>Tests that the graph functions are registered.</p> <p>Tests that the graph functions have the required attributes in the graph and updates the attributes that are added to the graph. <code>required_edge_attributes</code> and <code>required_node_attributes</code> currently only specify that one element in the graph must have the attribute (e.g., if a graphfcn has <code>required_node_attributes=['id']</code>, and only one node in the graph has the <code>id</code> attribute, then it will be valid).</p> <p>Parameters:</p> Name Type Description Default <code>graphfcn_list</code> <code>list[str]</code> <p>A list of graph functions</p> required <code>starting_graph</code> <code>Graph</code> <p>A graph to check the starting attributes of. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a graph function is not registered</p> <code>ValueError</code> <p>If a graph function requires an attribute that is not in the graph</p> Source code in <code>swmmanywhere/graph_utilities.py</code> <pre><code>def validate_graphfcn_list(\n    graphfcn_list: list[str], starting_graph: nx.Graph | None = None\n) -&gt; None:\n    \"\"\"Validate that the graph functions are registered.\n\n    Tests that the graph functions are registered.\n\n    Tests that the graph functions have the required attributes in the graph\n    and updates the attributes that are added to the graph.\n    `required_edge_attributes` and `required_node_attributes` currently only\n    specify that one element in the graph must have the attribute (e.g., if a\n    graphfcn has `required_node_attributes=['id']`, and only one node in the\n    graph has the `id` attribute, then it will be valid).\n\n    Args:\n        graphfcn_list (list[str]): A list of graph functions\n        starting_graph (nx.Graph, optional): A graph to check the starting\n            attributes of. Defaults to None.\n\n    Raises:\n        ValueError: If a graph function is not registered\n        ValueError: If a graph function requires an attribute that is not in\n            the graph\n    \"\"\"\n    # Check that the graph functions are registered\n    not_exists = [g for g in graphfcn_list if g not in graphfcns]\n    if not_exists:\n        raise ValueError(f\"Graphfcns are not registered:\\n{', '.join(not_exists)}\")\n\n    if starting_graph is None:\n        return\n\n    # Get starting graph attributes\n    edge_attributes: set = set()\n    for u, v, data in starting_graph.edges(data=True):\n        edge_attributes = edge_attributes.union(data.keys())\n\n    node_attributes: set = set()\n    for node, data in starting_graph.nodes(data=True):\n        node_attributes = node_attributes.union(data.keys())\n\n    # Iterate over graphfcn_list and check that the required attributes are\n    # present in the graph, updating the add attributes\n    for graphfcn in graphfcn_list:\n        if node_attributes.intersection(\n            graphfcns[graphfcn].required_node_attributes\n        ) != set(graphfcns[graphfcn].required_node_attributes):\n            raise ValueError(\n                f\"\"\"Graphfcn {graphfcn} requires node attributes \n                {graphfcns[graphfcn].required_node_attributes}\"\"\"\n            )\n        if edge_attributes.intersection(\n            graphfcns[graphfcn].required_edge_attributes\n        ) != set(graphfcns[graphfcn].required_edge_attributes):\n            raise ValueError(\n                f\"\"\"Graphfcn {graphfcn} requires edge attributes \n                {graphfcns[graphfcn].required_edge_attributes}\"\"\"\n            )\n\n        edge_attributes = edge_attributes.union(\n            graphfcns[graphfcn].adds_edge_attributes\n        )\n        node_attributes = node_attributes.union(\n            graphfcns[graphfcn].adds_node_attributes\n        )\n</code></pre>"},{"location":"reference-logging/","title":"Reference for SWMManywhere/logging.py","text":"<p>Logging module for SWMManywhere.</p> <p>Example: <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ[\"SWMMANYWHERE_VERBOSE\"] = \"true\"\n&gt;&gt;&gt; # logging is now enabled in any swmmanywhere module\n&gt;&gt;&gt; from swmmanywhere.logging import logger # You can now log yourself\n&gt;&gt;&gt; logger.add(\"file.log\") # Add a log file\n&gt;&gt;&gt; logger.info(\"This is an info message.\") # Write to stdout and file.log\nThis is an info message.\n&gt;&gt;&gt; os.environ[\"SWMMANYWHERE_VERBOSE\"] = \"false\" # Disable logging\n</code></pre></p>"},{"location":"reference-logging/#swmmanywhere.logging.dynamic_filter","title":"<code>dynamic_filter(record)</code>","text":"<p>A dynamic filter.</p> Source code in <code>swmmanywhere/logging.py</code> <pre><code>def dynamic_filter(record):\n    \"\"\"A dynamic filter.\"\"\"\n    return verbose()\n</code></pre>"},{"location":"reference-logging/#swmmanywhere.logging.get_logger","title":"<code>get_logger()</code>","text":"<p>Get a logger.</p> Source code in <code>swmmanywhere/logging.py</code> <pre><code>def get_logger() -&gt; loguru.logger:\n    \"\"\"Get a logger.\"\"\"\n    logger = loguru.logger\n    logger.configure(\n        handlers=[\n            {\n                \"sink\": sys.stdout,\n                \"filter\": dynamic_filter,\n                \"colorize\": True,\n                \"format\": \" | \".join(\n                    [\n                        \"&lt;cyan&gt;{time:YYYY/MM/DD HH:mm:ss}&lt;/&gt;\",\n                        \"{message}\",\n                    ]\n                ),\n            }\n        ]\n    )\n    return logger\n</code></pre>"},{"location":"reference-logging/#swmmanywhere.logging.new_add","title":"<code>new_add(sink, **kwargs)</code>","text":"<p>A new add method to wrap existing one but with the filter.</p> Source code in <code>swmmanywhere/logging.py</code> <pre><code>def new_add(sink, **kwargs):\n    \"\"\"A new add method to wrap existing one but with the filter.\"\"\"\n    # Include the dynamic filter in the kwargs if not already specified\n    if \"filter\" not in kwargs:\n        kwargs[\"filter\"] = dynamic_filter\n    # Call the original add method with the updated kwargs\n    return original_add(sink, **kwargs)\n</code></pre>"},{"location":"reference-logging/#swmmanywhere.logging.set_verbose","title":"<code>set_verbose(verbose)</code>","text":"<p>Set the verbosity.</p> Source code in <code>swmmanywhere/logging.py</code> <pre><code>def set_verbose(verbose: bool):\n    \"\"\"Set the verbosity.\"\"\"\n    os.environ[\"SWMMANYWHERE_VERBOSE\"] = str(verbose).lower()\n</code></pre>"},{"location":"reference-logging/#swmmanywhere.logging.verbose","title":"<code>verbose()</code>","text":"<p>Get the verbosity.</p> Source code in <code>swmmanywhere/logging.py</code> <pre><code>def verbose() -&gt; bool:\n    \"\"\"Get the verbosity.\"\"\"\n    return os.getenv(\"SWMMANYWHERE_VERBOSE\", \"false\").lower() == \"true\"\n</code></pre>"},{"location":"reference-metric-utilities/","title":"Reference for SWMManywhere/metric_utilties.py","text":"<p>Metric utilities module for SWMManywhere.</p> <p>A module for metrics, the metrics registry object and utilities for calculating metrics (such as NSE or timeseries data alignment) used in SWMManywhere.</p>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.MetricRegistry","title":"<code>MetricRegistry</code>","text":"<p>               Bases: <code>dict</code></p> <p>Registry object.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>class MetricRegistry(dict):\n    \"\"\"Registry object.\"\"\"\n\n    def _log_completion(self, func):\n        def _wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            logger.info(f\"{func.__name__} completed\")\n            return result\n\n        return _wrapper\n\n    def register(self, func: Callable) -&gt; Callable:\n        \"\"\"Register a metric.\"\"\"\n        if func.__name__ in self:\n            raise ValueError(f\"{func.__name__} already in the metric registry!\")\n\n        allowable_params = {\n            \"synthetic_results\": pd.DataFrame,\n            \"real_results\": pd.DataFrame,\n            \"synthetic_subs\": gpd.GeoDataFrame,\n            \"real_subs\": gpd.GeoDataFrame,\n            \"synthetic_G\": nx.Graph,\n            \"real_G\": nx.Graph,\n            \"metric_evaluation\": MetricEvaluation,\n        }\n\n        # Use get_type_hints to resolve annotations,\n        # considering 'from __future__ import annotations'\n        type_hints = get_type_hints(func)\n\n        for param, annotation in type_hints.items():\n            if param in (\"kwargs\", \"return\"):\n                continue\n            if param not in allowable_params:\n                raise ValueError(f\"{param} of {func.__name__} not allowed.\")\n            if annotation != allowable_params[param]:\n                raise ValueError(\n                    f\"\"\"{param} of {func.__name__} should be of\n                                 type {allowable_params[param]}, not \n                                 {annotation}.\"\"\"\n                )\n        self[func.__name__] = self._log_completion(func)\n        return func\n\n    def __getattr__(self, name):\n        \"\"\"Get a metric from the graphfcn dict.\"\"\"\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError(f\"{name} NOT in the metric registry!\")\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.MetricRegistry.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Get a metric from the graphfcn dict.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"Get a metric from the graphfcn dict.\"\"\"\n    try:\n        return self[name]\n    except KeyError:\n        raise AttributeError(f\"{name} NOT in the metric registry!\")\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.MetricRegistry.register","title":"<code>register(func)</code>","text":"<p>Register a metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def register(self, func: Callable) -&gt; Callable:\n    \"\"\"Register a metric.\"\"\"\n    if func.__name__ in self:\n        raise ValueError(f\"{func.__name__} already in the metric registry!\")\n\n    allowable_params = {\n        \"synthetic_results\": pd.DataFrame,\n        \"real_results\": pd.DataFrame,\n        \"synthetic_subs\": gpd.GeoDataFrame,\n        \"real_subs\": gpd.GeoDataFrame,\n        \"synthetic_G\": nx.Graph,\n        \"real_G\": nx.Graph,\n        \"metric_evaluation\": MetricEvaluation,\n    }\n\n    # Use get_type_hints to resolve annotations,\n    # considering 'from __future__ import annotations'\n    type_hints = get_type_hints(func)\n\n    for param, annotation in type_hints.items():\n        if param in (\"kwargs\", \"return\"):\n            continue\n        if param not in allowable_params:\n            raise ValueError(f\"{param} of {func.__name__} not allowed.\")\n        if annotation != allowable_params[param]:\n            raise ValueError(\n                f\"\"\"{param} of {func.__name__} should be of\n                             type {allowable_params[param]}, not \n                             {annotation}.\"\"\"\n            )\n    self[func.__name__] = self._log_completion(func)\n    return func\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.align_by_id","title":"<code>align_by_id(synthetic_results, real_results, variable, syn_ids, real_ids)</code>","text":"<p>Align and interpolate data by id.</p> <p>Aggregate synthetic and real results by date for specifics ids (i.e., sum up over all ids - so we are only comparing timeseries for one aggregation). Align the synthetic and real dates. In cases where the synthetic data is does not overlap the real data, the value is interpolated.</p> <p>Parameters:</p> Name Type Description Default <code>synthetic_results</code> <code>DataFrame</code> <p>The synthetic results.</p> required <code>real_results</code> <code>DataFrame</code> <p>The real results.</p> required <code>variable</code> <code>str</code> <p>The variable to align and calculate coef_func for.</p> required <code>syn_ids</code> <code>list</code> <p>The ids of the synthetic data to subselect for.</p> required <code>real_ids</code> <code>list</code> <p>The ids of the real data to subselect for.</p> required <code>coef_func</code> <code>Callable</code> <p>The coefficient to calculate. Defaults to nse.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: The aligned and interpolated data.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def align_by_id(\n    synthetic_results: pd.DataFrame,\n    real_results: pd.DataFrame,\n    variable: str,\n    syn_ids: list,\n    real_ids: list,\n):\n    \"\"\"Align and interpolate data by id.\n\n    Aggregate synthetic and real results by date for specifics ids (i.e., sum\n    up over all ids - so we are only comparing timeseries for one aggregation).\n    Align the synthetic and real dates. In cases where the synthetic\n    data is does not overlap the real data, the value is interpolated.\n\n    Args:\n        synthetic_results (pd.DataFrame): The synthetic results.\n        real_results (pd.DataFrame): The real results.\n        variable (str): The variable to align and calculate coef_func for.\n        syn_ids (list): The ids of the synthetic data to subselect for.\n        real_ids (list): The ids of the real data to subselect for.\n        coef_func (Callable, optional): The coefficient to calculate.\n            Defaults to nse.\n\n    Returns:\n        pd.DataFrame: The aligned and interpolated data.\n    \"\"\"\n    synthetic_results = synthetic_results.copy()\n    real_results = real_results.copy()\n\n    # Format dates\n    synthetic_results[\"date\"] = pd.to_datetime(synthetic_results[\"date\"])\n    real_results[\"date\"] = pd.to_datetime(real_results[\"date\"])\n\n    # Help alignment\n    synthetic_results[\"id\"] = synthetic_results[\"id\"].astype(str)\n    real_results[\"id\"] = real_results[\"id\"].astype(str)\n    syn_ids = [str(x) for x in syn_ids]\n    real_ids = [str(x) for x in real_ids]\n\n    # Extract data\n    syn_data = extract_var(synthetic_results, variable)\n    syn_data = syn_data.loc[syn_data[\"id\"].isin(syn_ids)]\n    syn_data = syn_data.groupby(\"date\").value.sum()\n\n    real_data = extract_var(real_results, variable)\n    real_data = real_data.loc[real_data[\"id\"].isin(real_ids)]\n    real_data = real_data.groupby(\"date\").value.sum()\n\n    # Align data\n    df = pd.merge(\n        syn_data,\n        real_data,\n        left_index=True,\n        right_index=True,\n        suffixes=(\"_syn\", \"_real\"),\n        how=\"outer\",\n    ).sort_index()\n\n    # Interpolate to time in real data\n    df[\"value_syn\"] = df.value_syn.interpolate().to_numpy()\n    df = df.dropna(subset=[\"value_real\"])\n\n    return df\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.align_by_shape","title":"<code>align_by_shape(var, synthetic_results, real_results, shapes, synthetic_G, real_G, key='sub_id')</code>","text":"<p>Align by subcatchment.</p> <p>Align synthetic and real results by shape and return the results. If multiple ids exist in the same shape, these are aggregated by sum.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>The variable to align.</p> required <code>synthetic_results</code> <code>DataFrame</code> <p>The synthetic results.</p> required <code>real_results</code> <code>DataFrame</code> <p>The real results.</p> required <code>shapes</code> <code>GeoDataFrame</code> <p>The shapes to align by (e.g., grid or real_subs).</p> required <code>synthetic_G</code> <code>Graph</code> <p>The synthetic graph.</p> required <code>real_G</code> <code>Graph</code> <p>The real graph.</p> required <code>key</code> <code>str</code> <p>The column to align by.</p> <code>'sub_id'</code> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def align_by_shape(\n    var,\n    synthetic_results: pd.DataFrame,\n    real_results: pd.DataFrame,\n    shapes: gpd.GeoDataFrame,\n    synthetic_G: nx.Graph,\n    real_G: nx.Graph,\n    key: str = \"sub_id\",\n) -&gt; pd.DataFrame:\n    \"\"\"Align by subcatchment.\n\n    Align synthetic and real results by shape and return the results. If multiple\n    ids exist in the same shape, these are aggregated by sum.\n\n    Args:\n        var (str): The variable to align.\n        synthetic_results (pd.DataFrame): The synthetic results.\n        real_results (pd.DataFrame): The real results.\n        shapes (gpd.GeoDataFrame): The shapes to align by (e.g., grid or real_subs).\n        synthetic_G (nx.Graph): The synthetic graph.\n        real_G (nx.Graph): The real graph.\n        key (str): The column to align by.\n    \"\"\"\n    synthetic_joined = nodes_to_subs(synthetic_G, shapes)\n    real_joined = nodes_to_subs(real_G, shapes)\n\n    # Extract data\n    real_results = extract_var(real_results, var)\n    synthetic_results = extract_var(synthetic_results, var)\n\n    # Format to help alignment\n    real_results[\"id\"] = real_results[\"id\"].astype(str)\n    synthetic_results[\"id\"] = synthetic_results[\"id\"].astype(str)\n    real_joined[\"id\"] = real_joined[\"id\"].astype(str)\n    synthetic_joined[\"id\"] = synthetic_joined[\"id\"].astype(str)\n\n    # Align data\n    synthetic_results = pd.merge(\n        synthetic_results, synthetic_joined[[\"id\", key]], on=\"id\"\n    )\n    synthetic_gb = synthetic_results.groupby([\"date\", key]).value.sum().reset_index()\n    real_results = pd.merge(real_results, real_joined[[\"id\", key]], on=\"id\")\n    real_gb = real_results.groupby([\"date\", key]).value.sum().reset_index()\n    results = pd.merge(\n        real_gb[[\"date\", key, \"value\"]],\n        synthetic_gb[[\"date\", key, \"value\"]],\n        on=[\"date\", key],\n        suffixes=(\"_real\", \"_syn\"),\n        how=\"outer\",\n    )\n\n    syn_interp = (\n        results.groupby(key)\n        .apply(func=lambda x: x.set_index(\"date\")[[\"value_syn\"]].interpolate())\n        .reset_index()\n    )\n    results = pd.merge(\n        results.drop(\"value_syn\", axis=1), syn_interp, on=[\"sub_id\", \"date\"]\n    )\n    results = results.dropna(subset=[\"value_real\"])\n\n    return results\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.apply_warmup","title":"<code>apply_warmup(results, warmup)</code>","text":"<p>Apply warmup to results.</p> <p>Apply a warmup period to the results dataframe. Removes all data during the warmup period.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>DataFrame</code> <p>The results dataframe.</p> required <code>warmup</code> <code>float</code> <p>The warmup period as a fraction of the total time period.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The results dataframe with the warmup period applied.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def apply_warmup(results: pd.DataFrame, warmup: float) -&gt; pd.DataFrame:\n    \"\"\"Apply warmup to results.\n\n    Apply a warmup period to the results dataframe. Removes all data during the\n    warmup period.\n\n\n    Args:\n        results (pd.DataFrame): The results dataframe.\n        warmup (float): The warmup period as a fraction of the total time period.\n\n    Returns:\n        pd.DataFrame: The results dataframe with the warmup period applied.\n    \"\"\"\n    return results.loc[\n        results.date\n        &gt;= (results.date.min() + warmup * (results.date.max() - results.date.min()))\n    ]\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.best_outfall_match","title":"<code>best_outfall_match(synthetic_G, real_subs)</code>","text":"<p>Best outfall match.</p> <p>Identify the outfall with the most nodes within the real_subs and return the subgraph of the synthetic graph of nodes that drain to that outfall.</p> <p>Parameters:</p> Name Type Description Default <code>synthetic_G</code> <code>Graph</code> <p>The synthetic graph.</p> required <code>real_subs</code> <code>GeoDataFrame</code> <p>The real subcatchments.</p> required <p>Returns:</p> Name Type Description <code>Graph</code> <p>nx.Graph: The subgraph of the synthetic graph for the outfall with the most nodes within the real_subs. Empty if no match is made.</p> <code>int</code> <code>int | None</code> <p>The id of the outfall. None if no outfall is found.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def best_outfall_match(\n    synthetic_G: nx.Graph, real_subs: gpd.GeoDataFrame\n) -&gt; tuple[nx.Graph, int | None]:\n    \"\"\"Best outfall match.\n\n    Identify the outfall with the most nodes within the real_subs and return the\n    subgraph of the synthetic graph of nodes that drain to that outfall.\n\n    Args:\n        synthetic_G (nx.Graph): The synthetic graph.\n        real_subs (gpd.GeoDataFrame): The real subcatchments.\n\n    Returns:\n        nx.Graph: The subgraph of the synthetic graph for the outfall with the\n            most nodes within the real_subs. Empty if no match is made.\n        int: The id of the outfall. None if no outfall is found.\n    \"\"\"\n    nodes_joined = nodes_to_subs(synthetic_G, real_subs)\n\n    if nodes_joined.shape[0] == 0:\n        return (nx.Graph(), None)\n\n    # Select the most common outfall\n    outfall = nodes_joined.outfall.value_counts().idxmax()\n\n    # Subselect the matching graph\n    outfall_nodes = [\n        n for n, d in synthetic_G.nodes(data=True) if d.get(\"outfall\", None) == outfall\n    ]\n    sg = create_subgraph(synthetic_G, outfall_nodes)\n    return sg, outfall\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.bias_flood_depth","title":"<code>bias_flood_depth(synthetic_results, real_results, synthetic_subs, real_subs, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef bias_flood_depth(\n    synthetic_results: pd.DataFrame,\n    real_results: pd.DataFrame,\n    synthetic_subs: gpd.GeoDataFrame,\n    real_subs: gpd.GeoDataFrame,\n    **kwargs,\n) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n\n    def _f(x):\n        return np.trapz(x.value, x.duration)\n\n    syn_flooding = extract_var(synthetic_results, \"flooding\").groupby(\"id\").apply(_f)\n    syn_area = synthetic_subs.impervious_area.sum()\n    syn_tot = syn_flooding.sum() / syn_area\n\n    real_flooding = extract_var(real_results, \"flooding\").groupby(\"id\").apply(_f)\n    real_area = real_subs.impervious_area.sum()\n    real_tot = real_flooding.sum() / real_area\n\n    return (syn_tot - real_tot) / real_tot\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.create_grid","title":"<code>create_grid(bbox, scale)</code>","text":"<p>Create a grid of polygons.</p> <p>Create a grid of polygons based on the bounding box and scale.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>tuple</code> <p>The bounding box coordinates in the format (minx, miny, maxx, maxy).</p> required <code>scale</code> <code>float | tuple</code> <p>The scale of the grid. If a tuple, the scale is (dx, dy). Otherwise, the scale is dx = dy = scale.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A geodataframe of the grid.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def create_grid(bbox: tuple, scale: float | tuple[float, float]) -&gt; gpd.GeoDataFrame:\n    \"\"\"Create a grid of polygons.\n\n    Create a grid of polygons based on the bounding box and scale.\n\n    Args:\n        bbox (tuple): The bounding box coordinates in the format (minx, miny,\n            maxx, maxy).\n        scale (float | tuple): The scale of the grid. If a tuple, the scale is\n            (dx, dy). Otherwise, the scale is dx = dy = scale.\n\n    Returns:\n        gpd.GeoDataFrame: A geodataframe of the grid.\n    \"\"\"\n    minx, miny, maxx, maxy = bbox\n\n    if isinstance(scale, tuple):\n        if len(scale) != 2:\n            raise ValueError(\n                f\"\"\"Scale must be a float or a tuple of length 2., \n                              instead of length: {len(scale)}\"\"\"\n            )\n        dx, dy = scale\n    elif isinstance(scale, float) | isinstance(scale, int):\n        dx = dy = scale\n    else:\n        raise ValueError(\n            f\"\"\"Scale must be a float or a tuple of length 2, \n                         instead of type {type(scale)}\"\"\"\n        )\n    xmins = np.arange(minx, maxx, dx)\n    ymins = np.arange(miny, maxy, dy)\n    grid = [\n        {\"geometry\": shapely.box(x, y, x + dx, y + dy), \"sub_id\": i}\n        for i, (x, y) in enumerate(product(xmins, ymins))\n    ]\n\n    return gpd.GeoDataFrame(grid)\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.create_subgraph","title":"<code>create_subgraph(G, nodes)</code>","text":"<p>Create a subgraph.</p> <p>Create a subgraph of G based on the nodes list. Taken from networkx documentation: https://networkx.org/documentation/stable/reference/classes/generated/networkx.Graph.subgraph.html</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>The original graph.</p> required <code>nodes</code> <code>list</code> <p>The list of nodes to include in the subgraph.</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>nx.Graph: The subgraph.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def create_subgraph(G: nx.Graph, nodes: list) -&gt; nx.Graph:\n    \"\"\"Create a subgraph.\n\n    Create a subgraph of G based on the nodes list. Taken from networkx\n    documentation: https://networkx.org/documentation/stable/reference/classes/generated/networkx.Graph.subgraph.html\n\n    Args:\n        G (nx.Graph): The original graph.\n        nodes (list): The list of nodes to include in the subgraph.\n\n    Returns:\n        nx.Graph: The subgraph.\n    \"\"\"\n    # Create a subgraph SG based on a (possibly multigraph) G\n    SG = G.__class__()\n    SG.add_nodes_from((n, G.nodes[n]) for n in nodes)\n    if SG.is_multigraph():\n        SG.add_edges_from(\n            (n, nbr, key, d)\n            for n, nbrs in G.adj.items()\n            if n in nodes\n            for nbr, keydict in nbrs.items()\n            if nbr in nodes\n            for key, d in keydict.items()\n        )\n    else:\n        SG.add_edges_from(\n            (n, nbr, d)\n            for n, nbrs in G.adj.items()\n            if n in nodes\n            for nbr, d in nbrs.items()\n            if nbr in nodes\n        )\n    SG.graph.update(G.graph)\n    return SG\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.dominant_outfall","title":"<code>dominant_outfall(G, results)</code>","text":"<p>Dominant outfall.</p> <p>Identify the outfall with highest flow along it and return the subgraph of the graph of nodes that drain to that outfall.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>DiGraph</code> <p>The graph.</p> required <code>results</code> <code>DataFrame</code> <p>The results, which include a 'flow' and 'id' column.</p> required <p>Returns:</p> Name Type Description <code>DiGraph</code> <p>nx.Graph: The subgraph of nodes/arcs that the reach max flow outfall</p> <code>int</code> <code>int</code> <p>The id of the outfall.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def dominant_outfall(G: nx.DiGraph, results: pd.DataFrame) -&gt; tuple[nx.DiGraph, int]:\n    \"\"\"Dominant outfall.\n\n    Identify the outfall with highest flow along it and return the\n    subgraph of the graph of nodes that drain to that outfall.\n\n    Args:\n        G (nx.DiGraph): The graph.\n        results (pd.DataFrame): The results, which include a 'flow' and 'id'\n            column.\n\n    Returns:\n        nx.Graph: The subgraph of nodes/arcs that the reach max flow outfall\n        int: The id of the outfall.\n    \"\"\"\n    # Identify outfalls of the graph\n    outfalls = [n for n, outdegree in G.out_degree() if outdegree == 0]\n    outfall_arcs = [d[\"id\"] for u, v, d in G.edges(data=True) if v in outfalls]\n\n    # Identify the outfall with the highest flow\n    outfall_flows = results.loc[\n        (results.variable == \"flow\") &amp; (results[\"id\"].isin(outfall_arcs))\n    ]\n    max_outfall_arc = outfall_flows.groupby(\"id\").value.median().idxmax()\n    max_outfall = [v for u, v, d in G.edges(data=True) if d[\"id\"] == max_outfall_arc][0]\n\n    # Subselect the matching graph\n    sg = create_subgraph(G, nx.ancestors(G, max_outfall) | {max_outfall})\n    return sg, max_outfall\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.edge_betweenness_centrality","title":"<code>edge_betweenness_centrality(G, normalized=True, weight='weight', njobs=-1)</code>","text":"<p>Parallel betweenness centrality function.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def edge_betweenness_centrality(\n    G: nx.Graph,\n    normalized: bool = True,\n    weight: Optional[str] = \"weight\",\n    njobs: int = -1,\n):\n    \"\"\"Parallel betweenness centrality function.\"\"\"\n    njobs = 1  # joblib.cpu_count(True) if njobs == -1 else njobs #TODO hotfix\n    node_chunks = tlz.partition_all(G.order() // njobs, G.nodes())\n    bt_func = tlz.partial(\n        nx.edge_betweenness_centrality_subset, G=G, normalized=normalized, weight=weight\n    )\n    bt_sc = joblib.Parallel(n_jobs=njobs)(\n        joblib.delayed(bt_func)(sources=nodes, targets=G.nodes())\n        for nodes in node_chunks\n    )\n\n    # Merge the betweenness centrality results\n    bt_c: dict[int, float] = defaultdict(float)\n    for bt in bt_sc:\n        for n, v in bt.items():\n            bt_c[n] += v\n    return bt_c\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.extract_var","title":"<code>extract_var(df, var)</code>","text":"<p>Extract var from a dataframe.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def extract_var(df: pd.DataFrame, var: str) -&gt; pd.DataFrame:\n    \"\"\"Extract var from a dataframe.\"\"\"\n    df_ = df.loc[df.variable == var].copy()\n    df_.loc[:, \"duration\"] = (df_.date - df_.date.min()).dt.total_seconds()\n    return df_\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.grid","title":"<code>grid(synthetic_results, synthetic_subs, synthetic_G, real_results, real_subs, real_G, metric_evaluation, var, coef_func)</code>","text":"<p>Grid scale metric.</p> <p>Classify synthetic nodes to a grid and calculate the coef_func of a variable over time for each grid cell. The metric produced is the median coef_func across all grid cells.</p> <p>Parameters:</p> Name Type Description Default <code>synthetic_results</code> <code>DataFrame</code> <p>The synthetic results.</p> required <code>synthetic_subs</code> <code>GeoDataFrame</code> <p>The synthetic subcatchments.</p> required <code>synthetic_G</code> <code>Graph</code> <p>The synthetic graph.</p> required <code>real_results</code> <code>DataFrame</code> <p>The real results.</p> required <code>real_subs</code> <code>GeoDataFrame</code> <p>The real subcatchments.</p> required <code>real_G</code> <code>Graph</code> <p>The real graph.</p> required <code>metric_evaluation</code> <code>MetricEvaluation</code> <p>The metric evaluation parameters.</p> required <code>var</code> <code>str</code> <p>The variable to calculate the coefficient for.</p> required <code>coef_func</code> <code>Callable</code> <p>The coefficient to calculate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The median coef_func value.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_scale\ndef grid(\n    synthetic_results: pd.DataFrame,\n    synthetic_subs: gpd.GeoDataFrame,\n    synthetic_G: nx.Graph,\n    real_results: pd.DataFrame,\n    real_subs: gpd.GeoDataFrame,\n    real_G: nx.Graph,\n    metric_evaluation: MetricEvaluation,\n    var: str,\n    coef_func: Callable,\n):\n    \"\"\"Grid scale metric.\n\n    Classify synthetic nodes to a grid and calculate the coef_func of a variable over\n    time for each grid cell. The metric produced is the median coef_func across all\n    grid cells.\n\n    Args:\n        synthetic_results (pd.DataFrame): The synthetic results.\n        synthetic_subs (gpd.GeoDataFrame): The synthetic subcatchments.\n        synthetic_G (nx.Graph): The synthetic graph.\n        real_results (pd.DataFrame): The real results.\n        real_subs (gpd.GeoDataFrame): The real subcatchments.\n        real_G (nx.Graph): The real graph.\n        metric_evaluation (MetricEvaluation): The metric evaluation parameters.\n        var (str): The variable to calculate the coefficient for.\n        coef_func (Callable): The coefficient to calculate.\n\n    Returns:\n        float: The median coef_func value.\n    \"\"\"\n    # Create a grid (GeoDataFrame of polygons)\n    scale = metric_evaluation.grid_scale\n    grid = create_grid(real_subs.total_bounds, scale)\n    grid.crs = real_subs.crs\n\n    # Align results\n    results = align_by_shape(\n        var,\n        synthetic_results=synthetic_results,\n        real_results=real_results,\n        shapes=grid,\n        synthetic_G=synthetic_G,\n        real_G=real_G,\n    )\n    # Calculate coefficient\n    return median_coef_by_group(results, \"sub_id\", coef_func=coef_func)\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.iterate_metrics","title":"<code>iterate_metrics(synthetic_results=None, synthetic_subs=None, synthetic_G=None, real_results=None, real_subs=None, real_G=None, metric_list=None, metric_evaluation=None)</code>","text":"<p>Iterate a list of metrics over a graph.</p> <p>Parameters:</p> Name Type Description Default <code>synthetic_results</code> <code>DataFrame | None</code> <p>The synthetic results.</p> <code>None</code> <code>synthetic_subs</code> <code>GeoDataFrame | None</code> <p>The synthetic subcatchments.</p> <code>None</code> <code>synthetic_G</code> <code>Graph | None</code> <p>The synthetic graph.</p> <code>None</code> <code>real_results</code> <code>DataFrame | None</code> <p>The real results.</p> <code>None</code> <code>real_subs</code> <code>GeoDataFrame | None</code> <p>The real subcatchments.</p> <code>None</code> <code>real_G</code> <code>Graph | None</code> <p>The real graph.</p> <code>None</code> <code>metric_list</code> <code>list[str] | None</code> <p>A list of metrics to iterate.</p> <code>None</code> <code>metric_evaluation</code> <code>MetricEvaluation | None</code> <p>The metric evaluation parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: The results of the metrics.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def iterate_metrics(\n    synthetic_results: pd.DataFrame | None = None,\n    synthetic_subs: gpd.GeoDataFrame | None = None,\n    synthetic_G: nx.Graph | None = None,\n    real_results: pd.DataFrame | None = None,\n    real_subs: gpd.GeoDataFrame | None = None,\n    real_G: nx.Graph | None = None,\n    metric_list: list[str] | None = None,\n    metric_evaluation: MetricEvaluation | None = None,\n) -&gt; dict[str, float]:\n    \"\"\"Iterate a list of metrics over a graph.\n\n    Args:\n        synthetic_results (pd.DataFrame | None): The synthetic results.\n        synthetic_subs (gpd.GeoDataFrame | None): The synthetic subcatchments.\n        synthetic_G (nx.Graph | None): The synthetic graph.\n        real_results (pd.DataFrame | None): The real results.\n        real_subs (gpd.GeoDataFrame | None): The real subcatchments.\n        real_G (nx.Graph | None): The real graph.\n        metric_list (list[str] | None): A list of metrics to iterate.\n        metric_evaluation (MetricEvaluation | None): The metric evaluation parameters.\n\n    Returns:\n        dict[str, float]: The results of the metrics.\n    \"\"\"\n    if metric_list is None:\n        return {}\n\n    validate_metric_list(metric_list)\n\n    if (metric_evaluation is not None) and (synthetic_results is not None):\n        synthetic_results = apply_warmup(synthetic_results, metric_evaluation.warmup)\n\n    kwargs = {\n        \"synthetic_results\": synthetic_results,\n        \"synthetic_subs\": synthetic_subs,\n        \"synthetic_G\": synthetic_G,\n        \"real_results\": real_results,\n        \"real_subs\": real_subs,\n        \"real_G\": real_G,\n        \"metric_evaluation\": metric_evaluation,\n    }\n\n    return {m: metrics[m](**kwargs) for m in metric_list}\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.kge","title":"<code>kge(y, yhat)</code>","text":"<p>Calculate the Kling-Gupta Efficiency (KGE) between simulated and observed data.</p> <p>Calculate KGE with the 2009 formulation: $$ KGE = 1 -     \\sqrt{ (r - 1)^2 +            (\\frac{\\sigma_{sim}}{\\sigma_{obs}} - 1)^2 +            (\\frac{\\mu_{sim}}{\\mu_{obs}} - 1)^2     } $$</p> <p>where:</p> <ul> <li>\\(r\\) is the correlation coefficient between observed and simulated value,</li> <li>\\(\\sigma_{sim}\\) and \\(\\sigma_{obs}\\) are the standard deviations of the     simulated and observed value, respectively,</li> <li>\\(\\mu_{sim}\\) and \\(\\mu_{obs}\\) are the means of the simulated and observed     value, respectively.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>array</code> <p>Observed data array.</p> required <code>yhat</code> <code>array</code> <p>Simulated data array.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The KGE value.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_coef\ndef kge(y: np.ndarray, yhat: np.ndarray) -&gt; float:\n    r\"\"\"Calculate the Kling-Gupta Efficiency (KGE) between simulated and observed data.\n\n    Calculate KGE with the 2009 formulation:\n    $$\n    KGE = 1 -\n        \\sqrt{ (r - 1)^2 +\n               (\\frac{\\sigma_{sim}}{\\sigma_{obs}} - 1)^2 +\n               (\\frac{\\mu_{sim}}{\\mu_{obs}} - 1)^2\n        }\n    $$\n\n    where:\n\n    - $r$ is the correlation coefficient between observed and simulated value,\n    - $\\sigma_{sim}$ and $\\sigma_{obs}$ are the standard deviations of the\n        simulated and observed value, respectively,\n    - $\\mu_{sim}$ and $\\mu_{obs}$ are the means of the simulated and observed\n        value, respectively.\n\n\n    Args:\n        y (np.array): Observed data array.\n        yhat (np.array): Simulated data array.\n\n    Returns:\n        float: The KGE value.\n    \"\"\"\n    if (np.std(y) == 0) | (np.mean(y) == 0):\n        return np.inf\n    if np.std(yhat) == 0:\n        r = 0\n    else:\n        r = np.corrcoef(yhat, y)[0, 1]\n    alpha = np.std(yhat) / np.std(y)\n    beta = np.mean(yhat) / np.mean(y)\n    kge = 1 - np.sqrt((r - 1) ** 2 + (alpha - 1) ** 2 + (beta - 1) ** 2)\n    return kge\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.kstest_betweenness","title":"<code>kstest_betweenness(synthetic_G, real_G, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef kstest_betweenness(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n    syn_betweenness = nx.betweenness_centrality(synthetic_G, weight=None)\n    real_betweenness = nx.betweenness_centrality(real_G, weight=None)\n\n    # TODO does it make more sense to use statistic or pvalue?\n    return stats.ks_2samp(\n        list(syn_betweenness.values()), list(real_betweenness.values())\n    ).statistic\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.kstest_edge_betweenness","title":"<code>kstest_edge_betweenness(synthetic_G, real_G, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef kstest_edge_betweenness(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n    syn_betweenness = edge_betweenness_centrality(synthetic_G, weight=None)\n    real_betweenness = edge_betweenness_centrality(real_G, weight=None)\n\n    # TODO does it make more sense to use statistic or pvalue?\n    return stats.ks_2samp(\n        list(syn_betweenness.values()), list(real_betweenness.values())\n    ).statistic\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.median_coef_by_group","title":"<code>median_coef_by_group(results, gb_key, coef_func=nse)</code>","text":"<p>Median coef_func value by group.</p> <p>Calculate the median coef_func value of a variable over time for each group in the results dataframe, and return the median of these values. Assumes that the results dataframe has a 'value_real' and 'value_syn' and that these properly line up.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>DataFrame</code> <p>The results dataframe.</p> required <code>gb_key</code> <code>str</code> <p>The column to group by.</p> required <code>coef_func</code> <code>Callable</code> <p>The coefficient to calculate. Default is nse.</p> <code>nse</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The median coef_func value.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def median_coef_by_group(\n    results: pd.DataFrame, gb_key: str, coef_func: Callable = nse\n) -&gt; float:\n    \"\"\"Median coef_func value by group.\n\n    Calculate the median coef_func value of a variable over time\n    for each group in the results dataframe, and return the median of these\n    values. Assumes that the results dataframe has a 'value_real' and 'value_syn'\n    and that these properly line up.\n\n    Args:\n        results (pd.DataFrame): The results dataframe.\n        gb_key (str): The column to group by.\n        coef_func (Callable): The coefficient to calculate. Default is nse.\n\n    Returns:\n        float: The median coef_func value.\n    \"\"\"\n    val = results.groupby(gb_key).apply(lambda x: coef_func(x.value_real, x.value_syn))\n    val = val[np.isfinite(val)]\n    return val.median()\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.metric_factory","title":"<code>metric_factory(name)</code>","text":"<p>Create a metric function.</p> <p>A factory function to create a metric function based on the name. The first part of the name is the scale, the second part is the metric, and the third part is the variable. For example, 'grid_nse_flooding' is a metric function that calculates the NSE of flooding at the grid scale.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metric.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <p>The metric function.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def metric_factory(name: str):\n    \"\"\"Create a metric function.\n\n    A factory function to create a metric function based on the name. The first\n    part of the name is the scale, the second part is the metric, and the third\n    part is the variable. For example, 'grid_nse_flooding' is a metric function\n    that calculates the NSE of flooding at the grid scale.\n\n    Args:\n        name (str): The name of the metric.\n\n    Returns:\n        Callable: The metric function.\n    \"\"\"\n    # Split the name\n    parts = name.split(\"_\")\n    if len(parts) != 3:\n        raise ValueError(\"Invalid metric name. Expected 'scale_metric_variable'\")\n    scale, metric, variable = parts\n\n    # Get coefficient\n    coef_func = coef_registry[metric]\n\n    # Get scale\n    func = scale_registry[scale]\n\n    # Validate the metric\n    for restriction in restriction_registry.values():\n        restriction(scale, metric, variable)\n\n    # Create the metric function\n    def new_metric(**kwargs):\n        return func(coef_func=coef_func, var=variable, **kwargs)\n\n    new_metric.__name__ = name\n    return new_metric\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nc_adjacency_dist","title":"<code>nc_adjacency_dist(synthetic_G, real_G, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef nc_adjacency_dist(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n    return nc_compare(\n        synthetic_G.to_undirected(),\n        real_G.to_undirected(),\n        \"lambda_dist\",\n        k=None,\n        kind=\"adjacency\",\n    )\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nc_compare","title":"<code>nc_compare(G1, G2, funcname, **kw)</code>","text":"<p>Compare two graphs using netcomp.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def nc_compare(G1, G2, funcname, **kw):\n    \"\"\"Compare two graphs using netcomp.\"\"\"\n    A1, A2 = [nx.adjacency_matrix(G) for G in (G1, G2)]\n    return getattr(netcomp, funcname)(A1, A2, **kw)\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nc_deltacon0","title":"<code>nc_deltacon0(synthetic_G, real_G, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef nc_deltacon0(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n    return nc_compare(synthetic_G, real_G, \"deltacon0\", eps=1e-10)\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nc_laplacian_dist","title":"<code>nc_laplacian_dist(synthetic_G, real_G, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef nc_laplacian_dist(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n    return nc_compare(synthetic_G, real_G, \"lambda_dist\", k=None, kind=\"laplacian\")\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nc_laplacian_norm_dist","title":"<code>nc_laplacian_norm_dist(synthetic_G, real_G, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef nc_laplacian_norm_dist(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n    return nc_compare(\n        synthetic_G.to_undirected(),\n        real_G.to_undirected(),\n        \"lambda_dist\",\n        k=None,\n        kind=\"laplacian_norm\",\n    )\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nc_resistance_distance","title":"<code>nc_resistance_distance(synthetic_G, real_G, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef nc_resistance_distance(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\"\"\"\n    return nc_compare(\n        synthetic_G,\n        real_G,\n        \"resistance_distance\",\n        check_connected=False,\n        renormalized=True,\n    )\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nc_vertex_edge_distance","title":"<code>nc_vertex_edge_distance(synthetic_G, real_G, **kwargs)</code>","text":"<p>Run the evaluated metric.</p> <p>Do '1 -' because this metric is similarity not distance.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef nc_vertex_edge_distance(synthetic_G: nx.Graph, real_G: nx.Graph, **kwargs) -&gt; float:\n    \"\"\"Run the evaluated metric.\n\n    Do '1 -' because this metric is similarity not distance.\n    \"\"\"\n    return 1 - nc_compare(synthetic_G, real_G, \"vertex_edge_distance\")\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nodes_to_subs","title":"<code>nodes_to_subs(G, subs)</code>","text":"<p>Nodes to subcatchments.</p> <p>Classify the nodes of the graph to the subcatchments of the subs dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>The graph.</p> required <code>subs</code> <code>GeoDataFrame</code> <p>The subcatchments.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A dataframe from the nodes and data, and the subcatchment information, distinguished by the column 'sub_id'.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def nodes_to_subs(G: nx.Graph, subs: gpd.GeoDataFrame) -&gt; gpd.GeoDataFrame:\n    \"\"\"Nodes to subcatchments.\n\n    Classify the nodes of the graph to the subcatchments of the subs dataframe.\n\n    Args:\n        G (nx.Graph): The graph.\n        subs (gpd.GeoDataFrame): The subcatchments.\n\n    Returns:\n        gpd.GeoDataFrame: A dataframe from the nodes and data, and the\n            subcatchment information, distinguished by the column 'sub_id'.\n    \"\"\"\n    nodes_df = pd.DataFrame([{\"id\": x, **d} for x, d in G.nodes(data=True)])\n    nodes_joined = gpd.GeoDataFrame(\n        nodes_df,\n        geometry=gpd.points_from_xy(nodes_df.x, nodes_df.y),\n        crs=G.graph[\"crs\"],\n    ).sjoin(subs.rename(columns={\"id\": \"sub_id\"}), how=\"inner\", predicate=\"within\")\n    return nodes_joined\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.nse","title":"<code>nse(y, yhat)</code>","text":"<p>Calculate Nash-Sutcliffe efficiency (NSE).</p> <p>Calculate the Nash-Sutcliffe efficiency (NSE):</p> \\[ NSE = 1 - \\frac{\\sum_{i=1}^{n} (Q_{obs,i} - Q_{sim,i})^2}                {\\sum_{i=1}^{n} (Q_{obs,i} - \\overline{Q}_{obs})^2} \\] <p>where:</p> <ul> <li>\\(Q_{obs,i}\\) is the observed value at time \\(i\\),</li> <li>\\(Q_{sim,i}\\) is the simulated value at time \\(i\\),</li> <li>\\(\\overline{Q}_{obs}\\) is the mean observed value over the simulation period,</li> <li>\\(n\\) is the number of time steps in the simulation period.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>array</code> <p>Observed data array.</p> required <code>yhat</code> <code>array</code> <p>Simulated data array.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NSE value.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_coef\ndef nse(y: np.ndarray, yhat: np.ndarray) -&gt; float:\n    r\"\"\"Calculate Nash-Sutcliffe efficiency (NSE).\n\n    Calculate the Nash-Sutcliffe efficiency (NSE):\n\n    $$\n    NSE = 1 - \\frac{\\sum_{i=1}^{n} (Q_{obs,i} - Q_{sim,i})^2}\n                   {\\sum_{i=1}^{n} (Q_{obs,i} - \\overline{Q}_{obs})^2}\n    $$\n\n    where:\n\n    - $Q_{obs,i}$ is the observed value at time $i$,\n    - $Q_{sim,i}$ is the simulated value at time $i$,\n    - $\\overline{Q}_{obs}$ is the mean observed value over the simulation period,\n    - $n$ is the number of time steps in the simulation period.\n\n    Args:\n        y (np.array): Observed data array.\n        yhat (np.array): Simulated data array.\n\n    Returns:\n        float: The NSE value.\n    \"\"\"\n    if np.std(y) == 0:\n        return np.inf\n    return 1 - np.sum(np.square(y - yhat)) / np.sum(np.square(y - np.mean(y)))\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.outfall","title":"<code>outfall(synthetic_results, synthetic_subs, synthetic_G, real_results, real_subs, real_G, metric_evaluation, var, coef_func)</code>","text":"<p>Outfall scale metric.</p> <p>Calculate the coefficient of a variable for the subgraph that drains to the dominant outfall node. The dominant outfall node of the 'real' network is calculated by dominant_outfall, while the dominant outfall node of the 'synthetic' network is calculated by best_outfall_match.</p> <p>Parameters:</p> Name Type Description Default <code>synthetic_results</code> <code>DataFrame</code> <p>The synthetic results.</p> required <code>synthetic_subs</code> <code>GeoDataFrame</code> <p>The synthetic subcatchments.</p> required <code>synthetic_G</code> <code>Graph</code> <p>The synthetic graph.</p> required <code>real_results</code> <code>DataFrame</code> <p>The real results.</p> required <code>real_subs</code> <code>GeoDataFrame</code> <p>The real subcatchments.</p> required <code>real_G</code> <code>Graph</code> <p>The real graph.</p> required <code>metric_evaluation</code> <code>MetricEvaluation</code> <p>The metric evaluation parameters.</p> required <code>var</code> <code>str</code> <p>The variable to calculate the coefficient for.</p> required <code>coef_func</code> <code>Callable</code> <p>The coefficient to calculate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The median coef_func value.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_scale\ndef outfall(\n    synthetic_results: pd.DataFrame,\n    synthetic_subs: gpd.GeoDataFrame,\n    synthetic_G: nx.Graph,\n    real_results: pd.DataFrame,\n    real_subs: gpd.GeoDataFrame,\n    real_G: nx.Graph,\n    metric_evaluation: MetricEvaluation,\n    var: str,\n    coef_func: Callable,\n):\n    \"\"\"Outfall scale metric.\n\n    Calculate the coefficient of a variable for the subgraph that\n    drains to the dominant outfall node. The dominant outfall node of the 'real'\n    network is calculated by dominant_outfall, while the dominant outfall node of\n    the 'synthetic' network is calculated by best_outfall_match.\n\n    Args:\n        synthetic_results (pd.DataFrame): The synthetic results.\n        synthetic_subs (gpd.GeoDataFrame): The synthetic subcatchments.\n        synthetic_G (nx.Graph): The synthetic graph.\n        real_results (pd.DataFrame): The real results.\n        real_subs (gpd.GeoDataFrame): The real subcatchments.\n        real_G (nx.Graph): The real graph.\n        metric_evaluation (MetricEvaluation): The metric evaluation parameters.\n        var (str): The variable to calculate the coefficient for.\n        coef_func (Callable): The coefficient to calculate.\n\n    Returns:\n        float: The median coef_func value.\n    \"\"\"\n    # Identify synthetic and real arcs that flow into the best outfall node\n    sg_syn, syn_outfall = best_outfall_match(synthetic_G, real_subs)\n    if len(sg_syn.nodes) == 0:\n        # No overlap exists\n        return np.inf\n\n    sg_real, real_outfall = dominant_outfall(real_G, real_results)\n\n    allowable_var = [\"nmanholes\", \"diameter\", \"npipes\", \"length\", \"flow\", \"flooding\"]\n    if var not in allowable_var:\n        raise ValueError(f\"Invalid variable {var}. Can be {allowable_var}\")\n\n    if var == \"nmanholes\":\n        # Calculate the coefficient based on the number of manholes\n        return coef_func(\n            np.atleast_1d(sg_real.number_of_nodes()),\n            np.atleast_1d(sg_syn.number_of_nodes()),\n        )\n    if var == \"npipes\":\n        # Calculate the coefficient based on the number of pipes\n        return coef_func(\n            np.atleast_1d(sg_real.number_of_edges()),\n            np.atleast_1d(sg_syn.number_of_edges()),\n        )\n    if var == \"length\":\n        # Calculate the coefficient based on the total length of the pipes\n        return coef_func(\n            np.array(sum(nx.get_edge_attributes(sg_real, var).values())),\n            np.array(sum(nx.get_edge_attributes(sg_syn, var).values())),\n        )\n    if var == \"diameter\":\n        # Calculate the coefficient based on the average diameter of the pipes\n        return coef_func(\n            np.array(list(nx.get_edge_attributes(sg_real, var).values())),\n            np.array(list(nx.get_edge_attributes(sg_syn, var).values())),\n        )\n    if var == \"flow\":\n        # Identify synthetic and real arcs that flow into the best outfall node\n        syn_arc = [\n            d[\"id\"] for u, v, d in synthetic_G.edges(data=True) if v == syn_outfall\n        ]\n        real_arc = [d[\"id\"] for u, v, d in real_G.edges(data=True) if v == real_outfall]\n    elif var == \"flooding\":\n        # Use all nodes in the subgraphs\n        syn_arc = list(sg_syn.nodes)\n        real_arc = list(sg_real.nodes)\n\n    # Calculate the coefficient\n    df = align_by_id(synthetic_results, real_results, var, syn_arc, real_arc)\n    return coef_func(df.value_real, df.value_syn)\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.outfall_kstest_diameters","title":"<code>outfall_kstest_diameters(real_G, synthetic_G, real_results, real_subs, **kwargs)</code>","text":"<p>Outfall KStest diameters.</p> <p>Calculate the Kolmogorov-Smirnov statistic of the diameters in the subgraph that drains to the dominant outfall node. The dominant outfall node of the 'real' network is calculated by dominant_outfall, while the dominant outfall node of the 'synthetic' network is calculated by best_outfall_match.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@metrics.register\ndef outfall_kstest_diameters(\n    real_G: nx.Graph,\n    synthetic_G: nx.Graph,\n    real_results: pd.DataFrame,\n    real_subs: gpd.GeoDataFrame,\n    **kwargs,\n) -&gt; float:\n    \"\"\"Outfall KStest diameters.\n\n    Calculate the Kolmogorov-Smirnov statistic of the diameters in the subgraph\n    that drains to the dominant outfall node. The dominant outfall node of the\n    'real' network is calculated by dominant_outfall, while the dominant outfall\n    node of the 'synthetic' network is calculated by best_outfall_match.\n    \"\"\"\n    # Identify synthetic and real outfall arcs\n    sg_syn, _ = best_outfall_match(synthetic_G, real_subs)\n\n    if len(sg_syn.nodes) == 0:\n        # No overlap exists\n        return np.inf\n\n    sg_real, _ = dominant_outfall(real_G, real_results)\n\n    # Extract the diameters\n    syn_diameters = nx.get_edge_attributes(sg_syn, \"diameter\")\n    real_diameters = nx.get_edge_attributes(sg_real, \"diameter\")\n    return stats.ks_2samp(\n        list(syn_diameters.values()), list(real_diameters.values())\n    ).statistic\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.register_coef","title":"<code>register_coef(coef_func)</code>","text":"<p>Register a coefficient function.</p> <p>Register a coefficient function to the coef_registry. The function should take two arguments, 'y' and 'yhat', and return a float. The function should be registered with the '@register_coef' decorator.</p> <p>Parameters:</p> Name Type Description Default <code>coef_func</code> <code>Callable</code> <p>The coefficient function to register.</p> required Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def register_coef(coef_func: Callable):\n    \"\"\"Register a coefficient function.\n\n    Register a coefficient function to the coef_registry. The function should\n    take two arguments, 'y' and 'yhat', and return a float. The function should\n    be registered with the '@register_coef' decorator.\n\n    Args:\n        coef_func (Callable): The coefficient function to register.\n    \"\"\"\n    name = coef_func.__name__\n\n    # Check if the function is already registered\n    if name in coef_registry:\n        raise ValueError(f\"Coefficient function '{name}' already registered.\")\n\n    # Validate the function\n    args = list(get_type_hints(coef_func).keys())\n    if \"y\" != args[0] or \"yhat\" != args[1]:\n        raise ValueError(f\"Coef {coef_func.__name__} requires args ('y', 'yhat').\")\n\n    # Add the function to the registry\n    coef_registry[name] = coef_func\n    return coef_func\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.register_restriction","title":"<code>register_restriction(restriction_func)</code>","text":"<p>Register a restriction function.</p> <p>Register a restriction function to the restriction_registry. A restriction allows for the restriction of certain combinations of variables within the metric_factory. The function should take three arguments, 'scale', 'metric', and 'variable', and should raise a ValueError if the combination is not allowed. The function should be registered with the '@register_restriction'.</p> <p>Parameters:</p> Name Type Description Default <code>restriction_func</code> <code>Callable</code> <p>The restriction function to register.</p> required Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def register_restriction(restriction_func: Callable):\n    \"\"\"Register a restriction function.\n\n    Register a restriction function to the restriction_registry. A restriction\n    allows for the restriction of certain combinations of variables within the\n    metric_factory. The function should take three arguments, 'scale', 'metric',\n    and 'variable', and should raise a ValueError if the combination is not\n    allowed. The function should be registered with the '@register_restriction'.\n\n    Args:\n        restriction_func (Callable): The restriction function to register.\n    \"\"\"\n    name = restriction_func.__name__\n\n    # Check if the function is already registered\n    if name in restriction_registry:\n        raise ValueError(f\"Restriction function '{name}' already registered.\")\n\n    # Validate the restriction\n    args = list(get_type_hints(restriction_func).keys())\n    if args != [\"scale\", \"metric\", \"variable\"]:\n        raise ValueError(\n            f\"\"\"Restriction {restriction_func.__name__} requires \n                         args ('scale', 'metric', 'variable').\"\"\"\n        )\n\n    # Add the function to the registry\n    restriction_registry[name] = restriction_func\n    return restriction_func\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.register_scale","title":"<code>register_scale(scale_func)</code>","text":"<p>Register a scale function.</p> <p>Register a scale function to the scale_registry. The function should take the same arguments as the scale functions and return a float. The function should be registered with the '@register_scale' decorator. A scale function is called as a metric, but with some additional arguments provided (i.e., the variable name and the coefficient function to use). The function should return a float.</p> <p>Parameters:</p> Name Type Description Default <code>scale_func</code> <code>Callable</code> <p>The scale function to register.</p> required Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def register_scale(scale_func: Callable):\n    \"\"\"Register a scale function.\n\n    Register a scale function to the scale_registry. The function should\n    take the same arguments as the scale functions and return a float. The\n    function should be registered with the '@register_scale' decorator. A scale\n    function is called as a metric, but with some additional arguments provided\n    (i.e., the variable name and the coefficient function to use). The function\n    should return a float.\n\n    Args:\n        scale_func (Callable): The scale function to register.\n    \"\"\"\n    name = scale_func.__name__\n\n    # Check if the function is already registered\n    if name in scale_registry:\n        raise ValueError(f\"Scale function '{name}' already registered.\")\n\n    # Validate the function\n    args = list(get_type_hints(scale_func).keys())\n    if args != [\n        \"synthetic_results\",\n        \"synthetic_subs\",\n        \"synthetic_G\",\n        \"real_results\",\n        \"real_subs\",\n        \"real_G\",\n        \"metric_evaluation\",\n        \"var\",\n        \"coef_func\",\n    ]:\n        raise ValueError(\n            f\"\"\"Scale {scale_func.__name__} requires args \n                         ('synthetic_results', 'synthetic_subs', 'synthetic_G', \n                         'real_results', 'real_subs', 'real_G', \n                         'metric_evaluation', 'var', 'coef_func').\"\"\"\n        )\n\n    # Add the function to the registry\n    scale_registry[name] = scale_func\n    return scale_func\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.relerror","title":"<code>relerror(y, yhat)</code>","text":"<p>Relative error, relerror.</p> <p>Calculate the relative error:</p> \\[ relerror = \\frac{mean(synthetic) - mean(real)}              {mean(real)} \\] <p>where:</p> <ul> <li>\\(synthetic\\) is the synthetic data,</li> <li>\\(real\\) is the real data,</li> </ul> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>The real data.</p> required <code>yhat</code> <code>ndarray</code> <p>The synthetic data.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The relerror value.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_coef\ndef relerror(y: np.ndarray, yhat: np.ndarray) -&gt; float:\n    r\"\"\"Relative error, relerror.\n\n    Calculate the relative error:\n\n    $$\n    relerror = \\frac{mean(synthetic) - mean(real)}\n                 {mean(real)}\n    $$\n\n    where:\n\n    - \\(synthetic\\) is the synthetic data,\n    - \\(real\\) is the real data,\n\n\n    Args:\n        y (np.ndarray): The real data.\n        yhat (np.ndarray): The synthetic data.\n\n    Returns:\n        float: The relerror value.\n    \"\"\"\n    total_observed = y.mean()\n    if total_observed == 0:\n        return np.inf\n    return (yhat.mean() - total_observed) / total_observed\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.restriction_on_metric","title":"<code>restriction_on_metric(scale, metric, variable)</code>","text":"<p>Restriction on metric.</p> <p>Restrict the design variables to use 'relerror' only.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>str</code> <p>The scale of the metric.</p> required <code>metric</code> <code>str</code> <p>The metric.</p> required <code>variable</code> <code>str</code> <p>The variable.</p> required Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_restriction\ndef restriction_on_metric(scale: str, metric: str, variable: str):\n    \"\"\"Restriction on metric.\n\n    Restrict the design variables to use 'relerror' only.\n\n    Args:\n        scale (str): The scale of the metric.\n        metric (str): The metric.\n        variable (str): The variable.\n    \"\"\"\n    if variable in (\"length\", \"nmanholes\", \"npipes\") and metric != \"relerror\":\n        raise ValueError(f\"Variable {variable} only valid with relerror metric\")\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.restriction_on_scale","title":"<code>restriction_on_scale(scale, metric, variable)</code>","text":"<p>Restriction on scale.</p> <p>Restrict the design variables to the outfall scale if the metric is 'relerror'.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>str</code> <p>The scale of the metric.</p> required <code>metric</code> <code>str</code> <p>The metric.</p> required <code>variable</code> <code>str</code> <p>The variable.</p> required Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_restriction\ndef restriction_on_scale(scale: str, metric: str, variable: str):\n    \"\"\"Restriction on scale.\n\n    Restrict the design variables to the outfall scale if the metric is 'relerror'.\n\n    Args:\n        scale (str): The scale of the metric.\n        metric (str): The metric.\n        variable (str): The variable.\n    \"\"\"\n    if variable in (\"length\", \"nmanholes\", \"npipes\") and scale != \"outfall\":\n        raise ValueError(f\"Variable {variable} only supported at the outfall scale\")\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.subcatchment","title":"<code>subcatchment(synthetic_results, synthetic_subs, synthetic_G, real_results, real_subs, real_G, metric_evaluation, var, coef_func)</code>","text":"<p>Subcatchment scale metric.</p> <p>Calculate the coefficient (coef_func) of a variable over time for aggregated to real subcatchment scale. The metric produced is the median coef_func across all subcatchments.</p> <p>Parameters:</p> Name Type Description Default <code>synthetic_results</code> <code>DataFrame</code> <p>The synthetic results.</p> required <code>synthetic_subs</code> <code>GeoDataFrame</code> <p>The synthetic subcatchments.</p> required <code>synthetic_G</code> <code>Graph</code> <p>The synthetic graph.</p> required <code>real_results</code> <code>DataFrame</code> <p>The real results.</p> required <code>real_subs</code> <code>GeoDataFrame</code> <p>The real subcatchments.</p> required <code>real_G</code> <code>Graph</code> <p>The real graph.</p> required <code>metric_evaluation</code> <code>MetricEvaluation</code> <p>The metric evaluation parameters.</p> required <code>var</code> <code>str</code> <p>The variable to calculate the coefficient for.</p> required <code>coef_func</code> <code>Callable</code> <p>The coefficient to calculate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The median coef_func value.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>@register_scale\ndef subcatchment(\n    synthetic_results: pd.DataFrame,\n    synthetic_subs: gpd.GeoDataFrame,\n    synthetic_G: nx.Graph,\n    real_results: pd.DataFrame,\n    real_subs: gpd.GeoDataFrame,\n    real_G: nx.Graph,\n    metric_evaluation: MetricEvaluation,\n    var: str,\n    coef_func: Callable,\n):\n    \"\"\"Subcatchment scale metric.\n\n    Calculate the coefficient (coef_func) of a variable over time for aggregated\n    to real subcatchment scale. The metric produced is the median coef_func\n    across all subcatchments.\n\n    Args:\n        synthetic_results (pd.DataFrame): The synthetic results.\n        synthetic_subs (gpd.GeoDataFrame): The synthetic subcatchments.\n        synthetic_G (nx.Graph): The synthetic graph.\n        real_results (pd.DataFrame): The real results.\n        real_subs (gpd.GeoDataFrame): The real subcatchments.\n        real_G (nx.Graph): The real graph.\n        metric_evaluation (MetricEvaluation): The metric evaluation parameters.\n        var (str): The variable to calculate the coefficient for.\n        coef_func (Callable): The coefficient to calculate.\n\n    Returns:\n        float: The median coef_func value.\n    \"\"\"\n    results = align_by_shape(\n        var,\n        synthetic_results=synthetic_results,\n        real_results=real_results,\n        shapes=real_subs,\n        synthetic_G=synthetic_G,\n        real_G=real_G,\n    )\n\n    return median_coef_by_group(results, \"sub_id\", coef_func=coef_func)\n</code></pre>"},{"location":"reference-metric-utilities/#swmmanywhere.metric_utilities.validate_metric_list","title":"<code>validate_metric_list(metric_list)</code>","text":"<p>Validate a list of metrics.</p> <p>Validate that all metrics in the metric list are registered.</p> <p>Parameters:</p> Name Type Description Default <code>metric_list</code> <code>list[str]</code> <p>A list of metrics to validate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a metric is not registered.</p> Source code in <code>swmmanywhere/metric_utilities.py</code> <pre><code>def validate_metric_list(metric_list: list[str]) -&gt; None:\n    \"\"\"Validate a list of metrics.\n\n    Validate that all metrics in the metric list are registered.\n\n    Args:\n        metric_list (list[str]): A list of metrics to validate.\n\n    Raises:\n        ValueError: If a metric is not registered.\n    \"\"\"\n    not_exists = [m for m in metric_list if m not in metrics]\n    if not_exists:\n        raise ValueError(f\"Metrics are not registered:\\n{', '.join(not_exists)}\")\n</code></pre>"},{"location":"reference-overview/","title":"Reference","text":"<p>Different API sections are documented separately.</p> <ul> <li>SWMManywhere</li> <li>Graph utilities</li> <li>Geospatial utilities</li> <li>Metric utilities</li> <li>Logging</li> <li>Parameters</li> <li>Post processing</li> <li>Preprocessing</li> </ul>"},{"location":"reference-parameters/","title":"Reference for SWMManywhere/parameters.py","text":"<p>Parameters module for SWMManywhere.</p>"},{"location":"reference-parameters/#swmmanywhere.parameters.HydraulicDesign","title":"<code>HydraulicDesign</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters for hydraulic design.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>@register_parameter_group(\"hydraulic_design\")\nclass HydraulicDesign(BaseModel):\n    \"\"\"Parameters for hydraulic design.\"\"\"\n\n    diameters: list = Field(\n        default=np.linspace(0.15, 3, int((3 - 0.15) / 0.075) + 1).tolist(),\n        min_length=1,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"\"\"Diameters to consider in \n                            pipe by pipe method\"\"\",\n    )\n    max_fr: float = Field(\n        default=0.8,\n        le=1,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Maximum filling ratio in pipe by pipe method\",\n    )\n    min_shear: float = Field(\n        default=2,\n        le=3,\n        ge=0,\n        json_schema_extra={\"unit\": \"Pa\"},\n        description=\"Minimum wall shear stress in pipe by pipe method\",\n    )\n    min_v: float = Field(\n        default=0.75,\n        le=2,\n        ge=0,\n        json_schema_extra={\"unit\": \"m/s\"},\n        description=\"Minimum velocity in pipe by pipe method\",\n    )\n    max_v: float = Field(\n        default=5,\n        le=10,\n        ge=3,\n        json_schema_extra={\"unit\": \"m/s\"},\n        description=\"Maximum velocity in pipe by pipe method\",\n    )\n    min_depth: float = Field(\n        default=0.5,\n        le=1,\n        ge=0,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Minimum excavation depth in pipe by pipe method\",\n    )\n    max_depth: float = Field(\n        default=5,\n        le=10,\n        ge=2,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Maximum excavation depth in pipe by pipe method\",\n    )\n    precipitation: float = Field(\n        default=0.006,\n        le=0.010,\n        ge=0.001,\n        description=\"Depth of design storm in pipe by pipe method\",\n        json_schema_extra={\"unit\": \"m\"},\n    )\n    depth_nbins: int = Field(\n        default=10,\n        ge=1,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Number of bins to discretise depth for in pipe by pipe method\",\n    )\n    edge_design_parameters: list[str] = Field(\n        default=[\"diameter\", \"cost_usd\"],\n        min_length=1,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"\"\"Edge parameters calculated by the design process to retain in the\n                    graph after the pipe_by_pipe graphfcn has been applied.\"\"\",\n    )\n</code></pre>"},{"location":"reference-parameters/#swmmanywhere.parameters.MetricEvaluation","title":"<code>MetricEvaluation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters for metric evaluation.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>@register_parameter_group(name=\"metric_evaluation\")\nclass MetricEvaluation(BaseModel):\n    \"\"\"Parameters for metric evaluation.\"\"\"\n\n    grid_scale: float = Field(\n        default=100,\n        le=5000,\n        ge=10,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Scale of the grid for metric evaluation\",\n    )\n\n    warmup: float = Field(\n        default=0,\n        ge=0,\n        lt=1,\n        json_schema_extra={\"unit\": \"fraction\"},\n        description=\"\"\"Warmup period as a fraction of the total simulation time. This\n            is used to exclude the initial part of the simulation from the metric\n            calculations.\"\"\",\n    )\n</code></pre>"},{"location":"reference-parameters/#swmmanywhere.parameters.OutfallDerivation","title":"<code>OutfallDerivation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters for outfall derivation.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>@register_parameter_group(name=\"outfall_derivation\")\nclass OutfallDerivation(BaseModel):\n    \"\"\"Parameters for outfall derivation.\"\"\"\n\n    method: str = Field(\n        default=\"separate\",\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"\"\"Method to derive outfall locations, \n            can be 'separate' or 'withtopo'.\"\"\",\n    )\n\n    river_buffer_distance: float = Field(\n        default=150.0,\n        ge=10.0,\n        le=500.0,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Buffer distance to link rivers to streets.\",\n    )\n\n    outfall_length: float = Field(\n        default=40.0,\n        ge=0.0,\n        le=600.0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Weight to discourage street drainage into river buffers.\",\n    )\n</code></pre>"},{"location":"reference-parameters/#swmmanywhere.parameters.SubcatchmentDerivation","title":"<code>SubcatchmentDerivation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters for subcatchment derivation.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>@register_parameter_group(name=\"subcatchment_derivation\")\nclass SubcatchmentDerivation(BaseModel):\n    \"\"\"Parameters for subcatchment derivation.\"\"\"\n\n    subbasin_streamorder: int = Field(\n        default=None,\n        ge=1,\n        le=20,\n        description=\"Stream order for subbasin derivation.\",\n        json_schema_extra={\"unit\": \"-\"},\n    )\n\n    subbasin_membership: float = Field(\n        default=0.5,\n        ge=0,\n        le=1,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Membership threshold for subbasin derivation.\",\n    )\n\n    subbasin_clip_method: str = Field(\n        default=\"subbasin\",\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Method to clip subbasins, can be `subbasin` or `community`.\",\n    )\n\n    lane_width: float = Field(\n        default=3.5,\n        ge=2.0,\n        le=5.0,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Width of a road lane.\",\n    )\n\n    carve_depth: float = Field(\n        default=2.0,\n        ge=1.0,\n        le=3.0,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Depth of road/river carve for flow accumulation.\",\n    )\n\n    max_street_length: float = Field(\n        default=60.0,\n        ge=40.0,\n        le=100.0,\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Distance to split streets into segments.\",\n    )\n\n    node_merge_distance: float = Field(\n        default=10,\n        ge=1,\n        le=39.9,  # should be less than max_street_length\n        json_schema_extra={\"unit\": \"m\"},\n        description=\"Distance within which to merge street nodes.\",\n    )\n</code></pre>"},{"location":"reference-parameters/#swmmanywhere.parameters.TopologyDerivation","title":"<code>TopologyDerivation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters for topology derivation.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>@register_parameter_group(name=\"topology_derivation\")\nclass TopologyDerivation(BaseModel):\n    \"\"\"Parameters for topology derivation.\"\"\"\n\n    allowable_networks: list = Field(\n        default=[\"walk\", \"drive\"],\n        min_length=1,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"OSM networks to consider\",\n    )\n\n    weights: list = Field(\n        default=[\"chahinian_slope\", \"chahinian_angle\", \"length\", \"contributing_area\"],\n        min_length=1,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Weights for topo derivation\",\n    )\n\n    omit_edges: list = Field(\n        default=[\"motorway\", \"motorway_link\", \"bridge\", \"tunnel\", \"corridor\"],\n        min_length=1,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"OSM paths pipes are not allowed under\",\n    )\n\n    chahinian_slope_scaling: float = Field(\n        default=1,\n        le=1,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Constant to apply to surface slope in topo derivation\",\n    )\n\n    chahinian_angle_scaling: float = Field(\n        default=0,\n        le=1,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Constant to apply to chahinian angle in topo derivation\",\n    )\n\n    length_scaling: float = Field(\n        default=0.1,\n        le=1,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Constant to apply to length in topo derivation\",\n    )\n\n    contributing_area_scaling: float = Field(\n        default=0.1,\n        le=1,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Constant to apply to contributing area in topo derivation\",\n    )\n\n    chahinian_slope_exponent: float = Field(\n        default=1,\n        le=2,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Exponent to apply to surface slope in topo derivation\",\n    )\n\n    chahinian_angle_exponent: float = Field(\n        default=1,\n        le=2,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Exponent to apply to chahinian angle in topo derivation\",\n    )\n\n    length_exponent: float = Field(\n        default=1,\n        le=2,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Exponent to apply to length in topo derivation\",\n    )\n\n    contributing_area_exponent: float = Field(\n        default=1,\n        le=2,\n        ge=0,\n        json_schema_extra={\"unit\": \"-\"},\n        description=\"Exponent to apply to contributing area in topo derivation\",\n    )\n\n    @model_validator(mode=\"after\")\n    def check_weights(self) -&gt; TopologyDerivation:\n        \"\"\"Check that weights have associated scaling and exponents.\"\"\"\n        for weight in self.weights:\n            if not hasattr(self, f\"{weight}_scaling\"):\n                raise ValueError(f\"Missing {weight}_scaling\")\n            if not hasattr(self, f\"{weight}_exponent\"):\n                raise ValueError(f\"Missing {weight}_exponent\")\n        return self\n</code></pre>"},{"location":"reference-parameters/#swmmanywhere.parameters.TopologyDerivation.check_weights","title":"<code>check_weights()</code>","text":"<p>Check that weights have associated scaling and exponents.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_weights(self) -&gt; TopologyDerivation:\n    \"\"\"Check that weights have associated scaling and exponents.\"\"\"\n    for weight in self.weights:\n        if not hasattr(self, f\"{weight}_scaling\"):\n            raise ValueError(f\"Missing {weight}_scaling\")\n        if not hasattr(self, f\"{weight}_exponent\"):\n            raise ValueError(f\"Missing {weight}_exponent\")\n    return self\n</code></pre>"},{"location":"reference-parameters/#swmmanywhere.parameters.get_full_parameters","title":"<code>get_full_parameters()</code>","text":"<p>Get the full set of parameters.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>def get_full_parameters():\n    \"\"\"Get the full set of parameters.\"\"\"\n    return parameter_register\n</code></pre>"},{"location":"reference-parameters/#swmmanywhere.parameters.get_full_parameters_flat","title":"<code>get_full_parameters_flat()</code>","text":"<p>Get the full set of parameters in a flat format.</p> Source code in <code>swmmanywhere/parameters.py</code> <pre><code>def get_full_parameters_flat():\n    \"\"\"Get the full set of parameters in a flat format.\"\"\"\n    parameters = get_full_parameters()\n    # Flatten\n    # parameters_flat = {k : {**y, **{'category' : cat}}\n    #                    for cat,v in parameters.items()\n    #                     for k, y in v.model_json_schema()['properties'].items()}\n    parameters_flat = {}\n    for cat, v in parameters.items():\n        for k, y in v.model_json_schema()[\"properties\"].items():\n            parameters_flat[k] = {**y, **{\"category\": cat}}\n\n    return parameters_flat\n</code></pre>"},{"location":"reference-parameters/#swmmanywhere.parameters.register_parameter_group","title":"<code>register_parameter_group(name)</code>","text":"<p>Register a parameter group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter group that it will be keyed to in parameter_register.</p> required Source code in <code>swmmanywhere/parameters.py</code> <pre><code>def register_parameter_group(name: str) -&gt; Callable:\n    \"\"\"Register a parameter group.\n\n    Args:\n        name (str): Name of the parameter group that it will be keyed to in\n            parameter_register.\n    \"\"\"\n\n    def wrapper(cls: BaseModel) -&gt; BaseModel:\n        if name in parameter_register:\n            logger.warning(f\"{name} already in parameter register, overwriting.\")\n        parameter_register[name] = cls()\n        return cls\n\n    return wrapper\n</code></pre>"},{"location":"reference-post-processing/","title":"Reference for SWMManywhere/post_processing.py","text":"<p>Post processing module for SWMManywhere.</p> <p>A module containing functions to format and write processed data into SWMM .inp files.</p>"},{"location":"reference-post-processing/#swmmanywhere.post_processing.change_flow_routing","title":"<code>change_flow_routing(routing_method, file_path)</code>","text":"<p>Replace the flow routing method in a SWMM inp file with a new method, in-place.</p> <p>Parameters:</p> Name Type Description Default <code>file_path </code> <p>Path Path to the SWMM inp file to be modified.</p> required <code>routing_method </code> <p>{\"KINWAVE\", \"DYNWAVE\", \"STEADY\"} The new flow routing method to be used. Available options are: <code>KINWAVE</code>, <code>DYNWAVE</code>, or <code>STEADY</code>.</p> required Source code in <code>swmmanywhere/post_processing.py</code> <pre><code>def change_flow_routing(\n    routing_method: Literal[\"KINWAVE\", \"DYNWAVE\", \"STEADY\"], file_path: Path\n) -&gt; None:\n    \"\"\"Replace the flow routing method in a SWMM inp file with a new method, in-place.\n\n    Args:\n        file_path : Path\n            Path to the SWMM inp file to be modified.\n        routing_method : {\"KINWAVE\", \"DYNWAVE\", \"STEADY\"}\n            The new flow routing method to be used. Available options are:\n            ``KINWAVE``, ``DYNWAVE``, or ``STEADY``.\n    \"\"\"\n    if routing_method.upper() not in (\"KINWAVE\", \"DYNWAVE\", \"STEADY\"):\n        raise ValueError(\n            \"routing_method must be one of 'KINWAVE', 'DYNWAVE', or 'STEADY'.\"\n        )\n    updated_contents = re.sub(\n        r\"^FLOW_ROUTING\\s+.*$\",\n        f\"FLOW_ROUTING {routing_method.upper()}\",\n        file_path.read_text(),\n        flags=re.MULTILINE,\n    )\n    file_path.write_text(updated_contents)\n</code></pre>"},{"location":"reference-post-processing/#swmmanywhere.post_processing.data_dict_to_inp","title":"<code>data_dict_to_inp(data_dict, base_input_file, new_input_file, routing='DYNWAVE')</code>","text":"<p>Write a SWMM .inp file from a dictionary of data arrays.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>dict[str, ndarray]</code> <p>Dictionary of data arrays. Where each key is a SWMM section and each value is a numpy array of data to be written to that section. The existing section is overwritten</p> required <code>base_input_file</code> <code>Path</code> <p>File path to the example/template .inp file.</p> required <code>new_input_file</code> <code>Path</code> <p>File path to the new SWMM .inp file.</p> required <code>routing</code> <code>str</code> <p>Flow routing method (KINWAVE, DYNWAVE, STEADY). Defaults to \"DYNWAVE\".</p> <code>'DYNWAVE'</code> Source code in <code>swmmanywhere/post_processing.py</code> <pre><code>def data_dict_to_inp(\n    data_dict: dict[str, np.ndarray],\n    base_input_file: Path,\n    new_input_file: Path,\n    routing: Literal[\"KINWAVE\", \"DYNWAVE\", \"STEADY\"] = \"DYNWAVE\",\n):\n    \"\"\"Write a SWMM .inp file from a dictionary of data arrays.\n\n    Args:\n        data_dict (dict[str, np.ndarray]): Dictionary of data arrays. Where\n            each key is a SWMM section and each value is a numpy array of\n            data to be written to that section. The existing section is\n            overwritten\n        base_input_file (Path): File path to the example/template .inp file.\n        new_input_file (Path): File path to the new SWMM .inp file.\n        routing (str, optional): Flow routing method (KINWAVE, DYNWAVE,\n            STEADY). Defaults to \"DYNWAVE\".\n    \"\"\"\n    shutil.copy2(base_input_file, new_input_file)\n\n    # Write the inp file\n    for key, data in data_dict.items():\n        start_section = \"[{0}]\".format(key)\n\n        overwrite_section(data, start_section, new_input_file)\n\n    # Set the flow routing\n    change_flow_routing(routing, new_input_file)\n</code></pre>"},{"location":"reference-post-processing/#swmmanywhere.post_processing.explode_polygon","title":"<code>explode_polygon(row)</code>","text":"<p>Explode a polygon into a DataFrame of coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Series</code> <p>A row of a GeoDataFrame containing a polygon.</p> required Example <p>import geopandas as gpd from shapely.geometry import Polygon df = pd.Series({'subcatchment' : '1', ...                 'geometry' : Polygon([(0,0), (1,0), ...                                       (1,1), (0,1)])}) explode_polygon(df)      x    y subcatchment 0  0.0  0.0            1 1  1.0  0.0            1 2  1.0  1.0            1 3  0.0  1.0            1 4  0.0  0.0            1</p> Source code in <code>swmmanywhere/post_processing.py</code> <pre><code>def explode_polygon(row: pd.Series):\n    \"\"\"Explode a polygon into a DataFrame of coordinates.\n\n    Args:\n        row (pd.Series): A row of a GeoDataFrame containing a polygon.\n\n    Example:\n        &gt;&gt;&gt; import geopandas as gpd\n        &gt;&gt;&gt; from shapely.geometry import Polygon\n        &gt;&gt;&gt; df = pd.Series({'subcatchment' : '1',\n        ...                 'geometry' : Polygon([(0,0), (1,0),\n        ...                                       (1,1), (0,1)])})\n        &gt;&gt;&gt; explode_polygon(df)\n             x    y subcatchment\n        0  0.0  0.0            1\n        1  1.0  0.0            1\n        2  1.0  1.0            1\n        3  0.0  1.0            1\n        4  0.0  0.0            1\n    \"\"\"\n    # Get the vertices of the polygon\n    vertices = list(row[\"geometry\"].exterior.coords)\n\n    # Create a new DataFrame for this row\n    df = pd.DataFrame(columns=[\"x\", \"y\"], data=vertices)\n    df[\"subcatchment\"] = row[\"subcatchment\"]\n    return df\n</code></pre>"},{"location":"reference-post-processing/#swmmanywhere.post_processing.format_to_swmm_dict","title":"<code>format_to_swmm_dict(nodes, outfalls, conduits, subs, event, symbol)</code>","text":"<p>Format data to a dictionary of data arrays with columns matching SWMM.</p> <p>These data are the parameters of all assets that are written to the SWMM input file. More parameters are available to edit (see defs/swmm_conversion.yml).</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>DataFrame</code> <p>GeoDataFrame of nodes. With at least columns: 'id', 'x', 'y', 'max_depth', 'chamber_floor_elevation', 'manhole_area'.</p> required <code>outfalls</code> <code>DataFrame</code> <p>GeoDataFrame of outfalls. With at least columns: 'id', 'chamber_floor_elevation'.</p> required <code>conduits</code> <code>DataFrame</code> <p>GeoDataFrame of conduits. With at least columns: 'id', 'u', 'v', 'length', 'roughness', 'shape_swmm', 'diameter'.</p> required <code>subs</code> <code>GeoDataFrame</code> <p>GeoDataFrame of subcatchments. With at least columns: 'subcatchment', 'rain_gage', 'id', 'area', 'rc', 'width', 'geometry',</p> required <code>event</code> <code>dict</code> <p>Dict describing storm event. With at least keys: 'name', 'unit', 'interval', 'fid'.</p> required <code>symbol</code> <code>dict</code> <p>Dict with coordinates of rain gage. With at least keys: 'x', 'y', 'name'.</p> required Example <p>import os import geopandas as gpd from shapely.geometry import Point, Polygon nodes = gpd.GeoDataFrame({'id' : ['node1', 'node2'], ...                        'x' : [0, 1], ...                        'y' : [0, 1], ...                        'max_depth' : [1, 1], ...                        'chamber_floor_elevation' : [1, 1], ...                        'manhole_area' : [1,1] ...                        }) outfalls = gpd.GeoDataFrame({'id' : ['outfall3'], ...                                'chamber_floor_elevation' : [1], ...                                'x' : [0], ...                                'y' : [0]}) conduits = gpd.GeoDataFrame({'id' : ['link1','link2'], ...                                'u' : ['node1','node2'], ...                                'v' : ['node2','outfall3'], ...                                'length' : [1,1], ...                                'roughness' : [1,1], ...                                'shape_swmm' : ['CIRCULAR','CIRCULAR'], ...                                'diameter' : [1,1], ...                                'capacity' : [0.1,0.1] ...                                }) subs = gpd.GeoDataFrame({'subcatchment' : ['sub1'], ...                                'rain_gage' : ['1'], ...                                'id' : ['node1'], ...                                'area' : [1], ...                                'rc' : [1], ...                                'width' : [1], ...                                'slope' : [0.001], ...                                'geometry' : [Polygon([(0.0,0.0), ...                                                       (1.0,0.0), ...                                                       (1.0,1.0), ...                                                       (0.0,1.0)])]}) rain_fid = os.path.join(os.path.dirname(os.path.abspath(file)), ...                '..', ...                    'swmmanywhere', ...                    'defs', ...                    'storm.dat') event = {'name' : '1', ...                'unit' : 'mm', ...                'interval' : 1, ...                'fid' : rain_fid} symbol = {'x' : 0, ...            'y' : 0, ...            'name' : 'name'} data_dict = format_to_swmm_dict(nodes, ...                                    outfalls, ...                                    conduits, ...                                    subs, ...                                    event, ...                                    symbol)</p> Source code in <code>swmmanywhere/post_processing.py</code> <pre><code>def format_to_swmm_dict(\n    nodes: pd.DataFrame,\n    outfalls: pd.DataFrame,\n    conduits: pd.DataFrame,\n    subs: gpd.GeoDataFrame,\n    event: dict[str, Any],\n    symbol: dict[str, Any],\n) -&gt; dict[str, np.ndarray]:\n    \"\"\"Format data to a dictionary of data arrays with columns matching SWMM.\n\n    These data are the parameters of all assets that are written to the SWMM\n    input file. More parameters are available to edit (see\n    defs/swmm_conversion.yml).\n\n    Args:\n        nodes (pd.DataFrame): GeoDataFrame of nodes. With at least columns:\n            'id', 'x', 'y', 'max_depth', 'chamber_floor_elevation',\n            'manhole_area'.\n        outfalls (pd.DataFrame): GeoDataFrame of outfalls. With at least\n            columns: 'id', 'chamber_floor_elevation'.\n        conduits (pd.DataFrame): GeoDataFrame of conduits. With at least\n            columns: 'id', 'u', 'v', 'length', 'roughness', 'shape_swmm',\n            'diameter'.\n        subs (gpd.GeoDataFrame): GeoDataFrame of subcatchments. With at least\n            columns: 'subcatchment', 'rain_gage', 'id', 'area', 'rc', 'width',\n            'geometry',\n        event (dict): Dict describing storm event. With at least\n            keys: 'name', 'unit', 'interval', 'fid'.\n        symbol (dict): Dict with coordinates of rain gage. With at least keys:\n            'x', 'y', 'name'.\n\n    Example:\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; import geopandas as gpd\n        &gt;&gt;&gt; from shapely.geometry import Point, Polygon\n        &gt;&gt;&gt; nodes = gpd.GeoDataFrame({'id' : ['node1', 'node2'],\n        ...                        'x' : [0, 1],\n        ...                        'y' : [0, 1],\n        ...                        'max_depth' : [1, 1],\n        ...                        'chamber_floor_elevation' : [1, 1],\n        ...                        'manhole_area' : [1,1]\n        ...                        })\n        &gt;&gt;&gt; outfalls = gpd.GeoDataFrame({'id' : ['outfall3'],\n        ...                                'chamber_floor_elevation' : [1],\n        ...                                'x' : [0],\n        ...                                'y' : [0]})\n        &gt;&gt;&gt; conduits = gpd.GeoDataFrame({'id' : ['link1','link2'],\n        ...                                'u' : ['node1','node2'],\n        ...                                'v' : ['node2','outfall3'],\n        ...                                'length' : [1,1],\n        ...                                'roughness' : [1,1],\n        ...                                'shape_swmm' : ['CIRCULAR','CIRCULAR'],\n        ...                                'diameter' : [1,1],\n        ...                                'capacity' : [0.1,0.1]\n        ...                                })\n        &gt;&gt;&gt; subs = gpd.GeoDataFrame({'subcatchment' : ['sub1'],\n        ...                                'rain_gage' : ['1'],\n        ...                                'id' : ['node1'],\n        ...                                'area' : [1],\n        ...                                'rc' : [1],\n        ...                                'width' : [1],\n        ...                                'slope' : [0.001],\n        ...                                'geometry' : [Polygon([(0.0,0.0),\n        ...                                                       (1.0,0.0),\n        ...                                                       (1.0,1.0),\n        ...                                                       (0.0,1.0)])]})\n        &gt;&gt;&gt; rain_fid = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n        ...                '..',\n        ...                    'swmmanywhere',\n        ...                    'defs',\n        ...                    'storm.dat')\n        &gt;&gt;&gt; event = {'name' : '1',\n        ...                'unit' : 'mm',\n        ...                'interval' : 1,\n        ...                'fid' : rain_fid}\n        &gt;&gt;&gt; symbol = {'x' : 0,\n        ...            'y' : 0,\n        ...            'name' : 'name'}\n        &gt;&gt;&gt; data_dict = format_to_swmm_dict(nodes,\n        ...                                    outfalls,\n        ...                                    conduits,\n        ...                                    subs,\n        ...                                    event,\n        ...                                    symbol)\n    \"\"\"\n    # Get the directory of the current module\n    current_dir = Path(__file__).parent\n\n    # TODO use 'load_yaml_from_defs'\n    # Create the path to iso_converter.yml\n    iso_path = current_dir / \"defs\" / \"swmm_conversion.yml\"\n\n    # Load conversion mapping from YAML file\n    with iso_path.open(\"r\") as file:\n        conversion_dict = yaml.safe_load(file)\n\n    ## Create nodes, coordinates and map dimensions\n    dims = {\n        \"x1\": nodes.x.min(),\n        \"y1\": nodes.y.min(),\n        \"x2\": nodes.x.max(),\n        \"y2\": nodes.y.max(),\n    }\n    dims = {x: str(y) + \" \" for x, y in dims.items()}\n\n    map_dimensions = pd.Series(dims).reset_index().set_index(\"index\").T\n    polygons = subs[[\"subcatchment\", \"geometry\"]].copy()\n\n    # Format dicts to DataFrames\n    event = pd.Series(event).reset_index().set_index(\"index\").T\n    symbol = pd.Series(symbol).reset_index().set_index(\"index\").T\n\n    # Apply the function to each row\n    polygons = pd.concat(polygons.apply(explode_polygon, axis=1).tolist())\n\n    ## Specify sections\n    shps = {\n        \"SUBCATCHMENTS\": subs,\n        \"CONDUITS\": conduits,\n        \"OUTFALLS\": outfalls,\n        \"STORAGE\": nodes,\n        \"XSECTIONS\": conduits,\n        \"SUBAREAS\": subs,\n        \"INFILTRATION\": subs,\n        \"COORDINATES\": pd.concat([nodes, outfalls], axis=0),\n        \"MAP\": map_dimensions,\n        \"Polygons\": polygons,\n        \"PUMPS\": None,\n        \"ORIFICES\": None,\n        \"WEIRS\": None,\n        \"OUTLETS\": None,\n        \"JUNCTIONS\": None,\n        \"RAINGAGES\": event,\n        \"SYMBOLS\": symbol,\n    }\n\n    # Fill backslash columns and store data in data_dict in the correct order\n    import numpy.typing as npt\n\n    def _fill_backslash_columns(\n        shp: pd.DataFrame | None, key: str\n    ) -&gt; npt.ArrayLike | None:\n        if shp is None:\n            return None\n\n        # Extract SWMM order and default values\n        columns = conversion_dict[key][\"iwcolumns\"]\n        numeric_cols = shp.select_dtypes(include=[np.number]).columns\n        shp[numeric_cols] = shp[numeric_cols].fillna(0)\n\n        # Find columns with a default specified\n        cols_default = [c[1:] for c in columns if c.startswith(\"/\")]\n\n        # Fill columns with defaults\n        shp[[\"/\" + c for c in cols_default]] = np.array(cols_default).T\n        return shp[columns].values\n\n    data_dict = {key: _fill_backslash_columns(shp, key) for key, shp in shps.items()}\n    return data_dict\n</code></pre>"},{"location":"reference-post-processing/#swmmanywhere.post_processing.overwrite_section","title":"<code>overwrite_section(data, section, fid)</code>","text":"<p>Overwrite a section of a SWMM .inp file with new data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Data array to be written to the SWMM .inp file.</p> required <code>section</code> <code>str</code> <p>Section of the SWMM .inp file to be overwritten.</p> required <code>fid</code> <code>Path</code> <p>File path to the SWMM .inp file.</p> required Example <p>data = np.array([         ['1', '1', '1', '1.166', '100', '500', '0.5', '0', 'empty'],         ['2', '1', '1', '1.1', '100', '500', '0.5', '0', 'empty'],         ['3', '1', '1', '2', '100', '400', '0.5', '0', 'empty']]) fid = 'my_pre_existing_swmm_input_file.inp' section = '[SUBCATCHMENTS]' overwrite_section(data, section, fid)</p> Source code in <code>swmmanywhere/post_processing.py</code> <pre><code>def overwrite_section(data: np.ndarray, section: str, fid: Path):\n    \"\"\"Overwrite a section of a SWMM .inp file with new data.\n\n    Args:\n        data (np.ndarray): Data array to be written to the SWMM .inp file.\n        section (str): Section of the SWMM .inp file to be overwritten.\n        fid (Path): File path to the SWMM .inp file.\n\n    Example:\n        data = np.array([\n                ['1', '1', '1', '1.166', '100', '500', '0.5', '0', 'empty'],\n                ['2', '1', '1', '1.1', '100', '500', '0.5', '0', 'empty'],\n                ['3', '1', '1', '2', '100', '400', '0.5', '0', 'empty']])\n        fid = 'my_pre_existing_swmm_input_file.inp'\n        section = '[SUBCATCHMENTS]'\n        overwrite_section(data, section, fid)\n    \"\"\"\n    # Read the existing SWMM .inp file\n    with fid.open(\"r\") as infile:\n        lines = infile.readlines()\n\n    # Create a flag to indicate whether we are within the target section\n    within_target_section = False\n\n    # Iterate through the lines and make modifications as needed\n    with fid.open(\"w\") as outfile:\n        for ix, line in enumerate(lines):\n            if line.strip() != section and re.search(r\"\\[.*?\\]\", line):\n                within_target_section = False\n\n            if line.strip() != section and not within_target_section:\n                outfile.write(line)  # Write lines outside the target section\n\n            if line.strip() != section:\n                continue\n\n            within_target_section = True\n            outfile.write(line)  # Write the start section header\n\n            # Write headers\n            i = 1\n            while lines[ix + i][0] == \";\":\n                outfile.write(lines[ix + i])  # Write column headers\n                i += 1\n\n            example_line = lines[ix + i]\n            # print('example_line {1}: {0}'.format(\n            #     example_line.replace('\\n', ''), section))\n            # print('note - this line must have at least as many column')\n            # print('entries as all other rows in this section\\n')\n            pattern = r\"(\\s+)\"\n\n            # Find all matches of the pattern in the input line\n            matches = re.findall(pattern, example_line)\n\n            # Calculate the space counts by taking the length of each match\n            space_counts = [\n                len(x) + len(y) for x, y in zip(matches, example_line.split())\n            ]\n            if not space_counts:\n                if data.shape[0] != 0:\n                    logger.warning(\"no template for data?\")\n                continue\n\n            space_counts[-1] -= 1\n            new_text = \"\"\n            if data is None:\n                continue\n\n            for i, row in enumerate(data):\n                if section == \"[CONTROLS]\":\n                    new_text = row\n                    continue\n\n                formatted_row = []\n                for x, y in zip(row, space_counts):\n                    formatted_value = \"{0:&lt;{1}}\".format(x, max(y, len(str(x)) + 1))\n                    formatted_row.append(formatted_value)\n                new_line = \"{0}\\n\".format(\"\".join(formatted_row))\n                new_text += new_line\n\n            outfile.write(new_text)  # Write the new content\n            outfile.write(\"\\n\")\n</code></pre>"},{"location":"reference-post-processing/#swmmanywhere.post_processing.synthetic_write","title":"<code>synthetic_write(addresses)</code>","text":"<p>Load synthetic data and write to SWMM input file.</p> <p>Loads nodes, edges and subcatchments from synthetic data, assumes that these are all located in <code>addresses</code>. Fills in appropriate default values for many SWMM parameters. More parameters are available to edit (see defs/swmm_conversion.yml). Identifies outfalls and automatically ensures that they have only one link to them (as is required by SWMM). Formats (with format_to_swmm_dict) and writes (with data_dict_to_inp) the data to a SWMM input (.inp) file.</p> <p>Parameters:</p> Name Type Description Default <code>addresses</code> <code>FilePaths</code> <p>A dictionary of file paths.</p> required Source code in <code>swmmanywhere/post_processing.py</code> <pre><code>def synthetic_write(addresses: FilePaths):\n    \"\"\"Load synthetic data and write to SWMM input file.\n\n    Loads nodes, edges and subcatchments from synthetic data, assumes that\n    these are all located in `addresses`. Fills in appropriate default values\n    for many SWMM parameters. More parameters are available to edit (see\n    defs/swmm_conversion.yml). Identifies outfalls and automatically ensures\n    that they have only one link to them (as is required by SWMM). Formats\n    (with format_to_swmm_dict) and writes (with data_dict_to_inp) the data to\n    a SWMM input (.inp) file.\n\n    Args:\n        addresses (FilePaths): A dictionary of file paths.\n    \"\"\"\n    nodes = gpd.read_file(addresses.model_paths.nodes)\n    edges = gpd.read_file(addresses.model_paths.edges)\n\n    if addresses.model_paths.subcatchments.suffix == \".geoparquet\":\n        subs = gpd.read_parquet(addresses.model_paths.subcatchments)\n    else:\n        subs = gpd.read_file(addresses.model_paths.subcatchments)\n    subs = subs.loc[subs.id.isin(nodes.id)]\n\n    # Extract SWMM relevant data\n    edges = edges[[\"id\", \"u\", \"v\", \"diameter\", \"length\"]]\n    nodes = nodes[[\"id\", \"x\", \"y\", \"chamber_floor_elevation\", \"surface_elevation\"]]\n    subs = subs[[\"id\", \"geometry\", \"area\", \"slope\", \"width\", \"rc\"]]\n\n    # Nodes\n    nodes[\"id\"] = nodes[\"id\"].astype(str)\n    nodes[\"max_depth\"] = nodes.surface_elevation - nodes.chamber_floor_elevation\n    nodes[\"surcharge_depth\"] = 0\n    nodes[\"flooded_area\"] = 100  # TODO arbitrary... not sure how to calc this\n    nodes[\"manhole_area\"] = 0.5\n\n    # Subs\n    subs[\"id\"] = subs[\"id\"].astype(str)\n    subs[\"subcatchment\"] = subs[\"id\"] + \"-sub\"\n    subs[\"rain_gage\"] = 1  # TODO revise when revising storms\n    subs[\"area\"] /= 10000  # convert to ha\n\n    # Edges\n    edges[\"u\"] = edges[\"u\"].astype(str)\n    edges[\"v\"] = edges[\"v\"].astype(str)\n    edges[\"roughness\"] = 0.01\n    edges[\"capacity\"] = 1e10  # capacity in swmm is a hard limit\n\n    # Outfalls (create new nodes that link to the stores connected tothem\n    outfalls = nodes.loc[~nodes.id.isin(edges.u)].copy()\n    outfalls[\"id\"] = outfalls[\"id\"] + \"_outfall\"\n\n    # Reduce elevation to ensure flow\n    outfalls[\"chamber_floor_elevation\"] -= 5\n    outfalls[\"x\"] -= 50\n    outfalls[\"y\"] -= 50\n\n    # Link stores to outfalls\n    new_edges = pd.DataFrame(columns=edges.columns, index=range(len(outfalls)))\n    new_edges[\"u\"] = outfalls[\"id\"].str.replace(\"_outfall\", \"\").values\n    new_edges[\"v\"] = outfalls[\"id\"].values\n    new_edges[\"id\"] = [f\"{u}-{v}\" for u, v in zip(new_edges[\"u\"], new_edges[\"v\"])]\n    new_edges[\"diameter\"] = edges.diameter.max()\n    new_edges[\"length\"] = (50**2 + 50**2) ** 0.5\n    new_edges[\"roughness\"] = 0.01\n    new_edges[\"capacity\"] = 1e10\n\n    # Append new edges\n    edges = pd.concat([edges, new_edges], ignore_index=True)\n\n    # Create event\n    # TODO will need some updating if multiple rain gages\n    # TODO automatically match units to storm.csv?\n    event = {\n        \"name\": \"1\",\n        \"unit\": \"mm\",\n        \"interval\": \"00:05\",  # hh:mm\n        \"fid\": str(addresses.bbox_paths.precipitation),\n    }\n\n    # Locate raingage(s) on the map\n    symbol = {\n        \"x\": nodes.x.min(),\n        \"y\": nodes.y.min(),\n        \"name\": \"1\",  # matches event name(s)\n    }\n\n    # Template SWMM input file\n    existing_input_file = Path(__file__).parent / \"defs\" / \"basic_drainage_all_bits.inp\"\n\n    # Format to dict\n    data_dict = format_to_swmm_dict(nodes, outfalls, edges, subs, event, symbol)\n\n    # Write new input file\n    data_dict_to_inp(data_dict, existing_input_file, addresses.model_paths.inp)\n</code></pre>"},{"location":"reference-preprocessing/","title":"Reference for SWMManywhere/preprocessing.py","text":"<p>Preprocessing module for SWMManywhere.</p> <p>A module to call downloads, preprocess these downloads into formats suitable for graphfcns, and some other utilities (such as creating a project folder structure or create the starting graph from rivers/streets).</p>"},{"location":"reference-preprocessing/#swmmanywhere.preprocessing.create_starting_graph","title":"<code>create_starting_graph(addresses)</code>","text":"<p>Create the starting graph.</p> <p>Create the starting graph by combining the street and river networks.</p> <p>Parameters:</p> Name Type Description Default <code>addresses</code> <code>FilePaths</code> <p>Class containing the addresses of the directories.</p> required <p>Returns:</p> Type Description <p>nx.Graph: Combined street and river network.</p> Source code in <code>swmmanywhere/preprocessing.py</code> <pre><code>def create_starting_graph(addresses: FilePaths):\n    \"\"\"Create the starting graph.\n\n    Create the starting graph by combining the street and river networks.\n\n    Args:\n        addresses (FilePaths): Class containing the addresses of the directories.\n\n    Returns:\n        nx.Graph: Combined street and river network.\n    \"\"\"\n    river = gu.load_graph(addresses.bbox_paths.river)\n    nx.set_edge_attributes(river, \"river\", \"edge_type\")\n    street = gu.load_graph(addresses.bbox_paths.street)\n    nx.set_edge_attributes(street, \"street\", \"edge_type\")\n    return nx.compose(river, street)\n</code></pre>"},{"location":"reference-preprocessing/#swmmanywhere.preprocessing.prepare_building","title":"<code>prepare_building(bbox, addresses, target_crs)</code>","text":"<p>Download and reproject building data.</p> Source code in <code>swmmanywhere/preprocessing.py</code> <pre><code>def prepare_building(\n    bbox: tuple[float, float, float, float], addresses: FilePaths, target_crs: str\n):\n    \"\"\"Download and reproject building data.\"\"\"\n    if addresses.bbox_paths.building.exists():\n        return\n\n    logger.info(f\"downloading buildings to {addresses.bbox_paths.building}\")\n    prepare_data.download_buildings_bbox(addresses.bbox_paths.building, bbox)\n\n    buildings = gpd.read_parquet(addresses.bbox_paths.building)\n    buildings = buildings.to_crs(target_crs)\n    write_df(buildings, addresses.bbox_paths.building)\n</code></pre>"},{"location":"reference-preprocessing/#swmmanywhere.preprocessing.prepare_elevation","title":"<code>prepare_elevation(bbox, addresses, target_crs)</code>","text":"<p>Download and reproject elevation data.</p> Source code in <code>swmmanywhere/preprocessing.py</code> <pre><code>def prepare_elevation(\n    bbox: tuple[float, float, float, float], addresses: FilePaths, target_crs: str\n):\n    \"\"\"Download and reproject elevation data.\"\"\"\n    if addresses.bbox_paths.elevation.exists():\n        return\n    logger.info(f\"downloading elevation to {addresses.bbox_paths.elevation}\")\n    with tempfile.TemporaryDirectory(dir=\".\") as temp_dir:\n        fid = Path(temp_dir) / \"elevation.tif\"\n        prepare_data.download_elevation(\n            fid,\n            bbox,\n        )\n        go.reproject_raster(target_crs, fid, addresses.bbox_paths.elevation)\n</code></pre>"},{"location":"reference-preprocessing/#swmmanywhere.preprocessing.prepare_precipitation","title":"<code>prepare_precipitation(bbox, addresses, api_keys, target_crs, source_crs='EPSG:4326')</code>","text":"<p>Download and reproject precipitation data.</p> Source code in <code>swmmanywhere/preprocessing.py</code> <pre><code>def prepare_precipitation(\n    bbox: tuple[float, float, float, float],\n    addresses: FilePaths,\n    api_keys: dict[str, str],\n    target_crs: str,\n    source_crs: str = \"EPSG:4326\",\n):\n    \"\"\"Download and reproject precipitation data.\"\"\"\n    if addresses.bbox_paths.precipitation.exists():\n        return\n    logger.info(f\"downloading precipitation to {addresses.bbox_paths.precipitation}\")\n    precip = prepare_data.download_precipitation(\n        bbox, api_keys[\"cds_username\"], api_keys[\"cds_api_key\"]\n    )\n    precip = precip.reset_index()\n    precip = go.reproject_df(precip, source_crs, target_crs)\n    write_df(precip, addresses.bbox_paths.precipitation)\n</code></pre>"},{"location":"reference-preprocessing/#swmmanywhere.preprocessing.prepare_river","title":"<code>prepare_river(bbox, addresses, target_crs, source_crs='EPSG:4326')</code>","text":"<p>Download and reproject river graph.</p> Source code in <code>swmmanywhere/preprocessing.py</code> <pre><code>def prepare_river(\n    bbox: tuple[float, float, float, float],\n    addresses: FilePaths,\n    target_crs: str,\n    source_crs: str = \"EPSG:4326\",\n):\n    \"\"\"Download and reproject river graph.\"\"\"\n    if addresses.bbox_paths.river.exists():\n        return\n    logger.info(f\"downloading river network to {addresses.bbox_paths.river}\")\n    river_network = prepare_data.download_river(bbox)\n    river_network = go.reproject_graph(river_network, source_crs, target_crs)\n    gu.save_graph(river_network, addresses.bbox_paths.river)\n</code></pre>"},{"location":"reference-preprocessing/#swmmanywhere.preprocessing.prepare_street","title":"<code>prepare_street(bbox, addresses, target_crs, source_crs='EPSG:4326', network_types=['drive'])</code>","text":"<p>Download and reproject street graph.</p> <p>Download the street graph within the bbox and reproject it to the UTM zone. The street graph is downloaded for all network types in network_types. The street graph is saved to the addresses.bbox_paths.street directory.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>tuple[float, float, float, float]</code> <p>Bounding box coordinates in the format (minx, miny, maxx, maxy) in EPSG:4326.</p> required <code>addresses</code> <code>FilePaths</code> <p>Class containing the addresses of the directories.</p> required <code>target_crs</code> <code>str</code> <p>Target CRS to reproject the graph to.</p> required <code>source_crs</code> <code>str</code> <p>Source CRS of the graph.</p> <code>'EPSG:4326'</code> <code>network_types</code> <code>list</code> <p>List of network types to download. For duplicate edges, nx.compose_all selects the attributes in priority of last to first. In likelihood, you want to ensure that the last network in the list is <code>drive</code>, so as to retain information about <code>lanes</code>, which is needed to calculate impervious area.</p> <code>['drive']</code> Source code in <code>swmmanywhere/preprocessing.py</code> <pre><code>def prepare_street(\n    bbox: tuple[float, float, float, float],\n    addresses: FilePaths,\n    target_crs: str,\n    source_crs: str = \"EPSG:4326\",\n    network_types=[\"drive\"],\n):\n    \"\"\"Download and reproject street graph.\n\n    Download the street graph within the bbox and reproject it to the UTM zone.\n    The street graph is downloaded for all network types in network_types. The\n    street graph is saved to the addresses.bbox_paths.street directory.\n\n    Args:\n        bbox (tuple[float, float, float, float]): Bounding box coordinates in\n            the format (minx, miny, maxx, maxy) in EPSG:4326.\n        addresses (FilePaths): Class containing the addresses of the directories.\n        target_crs (str): Target CRS to reproject the graph to.\n        source_crs (str): Source CRS of the graph.\n        network_types (list): List of network types to download. For duplicate\n            edges, nx.compose_all selects the attributes in priority of last to\n            first. In likelihood, you want to ensure that the last network in\n            the list is `drive`, so as to retain information about `lanes`,\n            which is needed to calculate impervious area.\n    \"\"\"\n    if addresses.bbox_paths.street.exists():\n        return\n    logger.info(f\"downloading network to {addresses.bbox_paths.street}\")\n    if \"drive\" in network_types and network_types[-1] != \"drive\":\n        logger.warning(\n            \"\"\"The last network type should be `drive` to retain \n                        `lanes` attribute, needed to calculate impervious area.\n                        Moving it to the last position.\"\"\"\n        )\n        network_types.pop(\"drive\")\n        network_types.append(\"drive\")\n    networks = []\n    for network_type in network_types:\n        network = prepare_data.download_street(bbox, network_type=network_type)\n        nx.set_edge_attributes(network, network_type, \"network_type\")\n        networks.append(network)\n    street_network = nx.compose_all(networks)\n\n    # Reproject graph\n    street_network = go.reproject_graph(street_network, source_crs, target_crs)\n\n    gu.save_graph(street_network, addresses.bbox_paths.street)\n</code></pre>"},{"location":"reference-preprocessing/#swmmanywhere.preprocessing.run_downloads","title":"<code>run_downloads(bbox, addresses, network_types=['drive'])</code>","text":"<p>Run the data downloads.</p> <p>Run the precipitation, elevation, building, street and river network downloads. If the data already exists, do not download it again. Reprojects data to the UTM zone.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>tuple[float, float, float, float]</code> <p>Bounding box coordinates in the format (minx, miny, maxx, maxy) in EPSG:4326.</p> required <code>addresses</code> <code>FilePaths</code> <p>Class containing the addresses of the directories.</p> required <code>network_types</code> <code>list</code> <p>List of network types to download.</p> <code>['drive']</code> Source code in <code>swmmanywhere/preprocessing.py</code> <pre><code>def run_downloads(\n    bbox: tuple[float, float, float, float],\n    addresses: FilePaths,\n    network_types=[\"drive\"],\n):\n    \"\"\"Run the data downloads.\n\n    Run the precipitation, elevation, building, street and river network\n    downloads. If the data already exists, do not download it again. Reprojects\n    data to the UTM zone.\n\n    Args:\n        bbox (tuple[float, float, float, float]): Bounding box coordinates in\n            the format (minx, miny, maxx, maxy) in EPSG:4326.\n        addresses (FilePaths): Class containing the addresses of the directories.\n        network_types (list): List of network types to download.\n    \"\"\"\n    target_crs = go.get_utm_epsg(bbox[0], bbox[1])\n\n    # Download precipitation data\n    # Currently commented because it doesn't work\n    # prepare_precipitation(bbox, addresses, api_keys, target_crs)\n\n    # Download elevation data\n    prepare_elevation(bbox, addresses, target_crs)\n\n    # Download building data\n    prepare_building(bbox, addresses, target_crs)\n\n    # Download street network data\n    prepare_street(bbox, addresses, target_crs, network_types=network_types)\n\n    # Download river network data\n    prepare_river(bbox, addresses, target_crs)\n</code></pre>"},{"location":"reference-preprocessing/#swmmanywhere.preprocessing.write_df","title":"<code>write_df(df, fid)</code>","text":"<p>Write a DataFrame to a file.</p> <p>Write a DataFrame to a file. The file type is determined by the file extension.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to write to a file.</p> required <code>fid</code> <code>Path</code> <p>Path to the file.</p> required Source code in <code>swmmanywhere/preprocessing.py</code> <pre><code>def write_df(df: pd.DataFrame | gpd.GeoDataFrame, fid: Path):\n    \"\"\"Write a DataFrame to a file.\n\n    Write a DataFrame to a file. The file type is determined by the file\n    extension.\n\n    Args:\n        df (DataFrame): DataFrame to write to a file.\n        fid (Path): Path to the file.\n    \"\"\"\n    if fid.suffix in (\".geoparquet\", \".parquet\"):\n        df.to_parquet(fid)\n    elif fid.suffix in (\".geojson\", \".json\"):\n        if isinstance(df, gpd.GeoDataFrame):\n            df.to_file(fid, driver=\"GeoJSON\")\n        else:\n            df.to_json(fid)\n</code></pre>"},{"location":"reference/","title":"Reference for SWMManywhere/swmmanywhere.py","text":"<p>The main SWMManywhere module to generate and run a synthetic network.</p>"},{"location":"reference/#swmmanywhere.swmmanywhere.check_address_overrides","title":"<code>check_address_overrides(config)</code>","text":"<p>Check the address overrides in the config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If an address override path does not exist.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def check_address_overrides(config: dict):\n    \"\"\"Check the address overrides in the config.\n\n    Args:\n        config (dict): The configuration.\n\n    Raises:\n        FileNotFoundError: If an address override path does not exist.\n    \"\"\"\n    overrides = config.get(\"address_overrides\", None)\n\n    if not overrides:\n        return config\n\n    for key, path in overrides.items():\n        if not Path(path).exists():\n            raise FileNotFoundError(f\"{key} not found at {path}\")\n        config[\"address_overrides\"][key] = Path(path)\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.check_and_register_custom_graphfcns","title":"<code>check_and_register_custom_graphfcns(config)</code>","text":"<p>Check, register and validate custom graphfcns in the config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a graphfcn module does not exist.</p> <code>ValueError</code> <p>If a custom graphfcn is not successfully registered.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def check_and_register_custom_graphfcns(config: dict):\n    \"\"\"Check, register and validate custom graphfcns in the config.\n\n    Args:\n        config (dict): The configuration.\n\n    Raises:\n        ValueError: If a graphfcn module does not exist.\n        ValueError: If a custom graphfcn is not successfully registered.\n    \"\"\"\n    import_modules(config.get(\"custom_graphfcn_modules\", []))\n\n    # Validate the import\n    validate_graphfcn_list(config.get(\"graphfcn_list\", []))\n\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.check_and_register_custom_metrics","title":"<code>check_and_register_custom_metrics(config)</code>","text":"<p>Check, register and validate custom metrics in the config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the custom metrics module does not exist.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def check_and_register_custom_metrics(config: dict):\n    \"\"\"Check, register and validate custom metrics in the config.\n\n    Args:\n        config (dict): The configuration.\n\n    Raises:\n        ValueError: If the custom metrics module does not exist.\n    \"\"\"\n    import_modules(config.get(\"custom_metric_modules\", []))\n\n    # Validate metric list\n    validate_metric_list(config.get(\"metric_list\", []))\n\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.check_parameter_overrides","title":"<code>check_parameter_overrides(config)</code>","text":"<p>Check the parameter overrides in the config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a parameter override is not in the parameters dictionary.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def check_parameter_overrides(config: dict):\n    \"\"\"Check the parameter overrides in the config.\n\n    Args:\n        config (dict): The configuration.\n\n    Raises:\n        ValueError: If a parameter override is not in the parameters\n            dictionary.\n    \"\"\"\n    params = parameters.get_full_parameters()\n    for category, overrides in config.get(\"parameter_overrides\", {}).items():\n        if category not in params:\n            raise ValueError(\n                f\"\"\"{category} not a category of parameter. Must\n                             be one of {params.keys()}.\"\"\"\n            )\n\n        # Get the available properties for a category\n        cat_properties = params[category].model_json_schema()[\"properties\"]\n\n        for key, val in overrides.items():\n            # Check that the parameter is available\n            if key not in cat_properties:\n                raise ValueError(f\"{key} not found in {category}.\")\n\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.check_real_network_paths","title":"<code>check_real_network_paths(config)</code>","text":"<p>Check the paths to the real network in the config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If a real network path does not exist.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def check_real_network_paths(config: dict):\n    \"\"\"Check the paths to the real network in the config.\n\n    Args:\n        config (dict): The configuration.\n\n    Raises:\n        FileNotFoundError: If a real network path does not exist.\n    \"\"\"\n    real = config.get(\"real\", None)\n\n    if not real:\n        return config\n\n    for key, path in real.items():\n        if not isinstance(path, str):\n            continue\n        if not Path(path).exists():\n            raise FileNotFoundError(f\"{key} not found at {path}\")\n        config[\"real\"][key] = Path(path)\n\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.check_starting_graph","title":"<code>check_starting_graph(config)</code>","text":"<p>Check the starting graph in the config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the starting graph path does not exist.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def check_starting_graph(config: dict):\n    \"\"\"Check the starting graph in the config.\n\n    Args:\n        config (dict): The configuration.\n\n    Raises:\n        FileNotFoundError: If the starting graph path does not exist.\n    \"\"\"\n    # If no starting graph, return\n    if not config.get(\"starting_graph\", None):\n        return config\n\n    # Check the starting graph exists and convert to Path\n    config[\"starting_graph\"] = Path(config[\"starting_graph\"])\n    if not config[\"starting_graph\"].exists():\n        raise FileNotFoundError(\n            f\"\"\"starting_graph not found at \n                                {config[\"starting_graph\"]}\"\"\"\n        )\n\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.check_top_level_paths","title":"<code>check_top_level_paths(config)</code>","text":"<p>Check the top level paths (<code>base_dir</code>) in the config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If a top level path does not exist.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def check_top_level_paths(config: dict):\n    \"\"\"Check the top level paths (`base_dir`) in the config.\n\n    Args:\n        config (dict): The configuration.\n\n    Raises:\n        FileNotFoundError: If a top level path does not exist.\n    \"\"\"\n    key = \"base_dir\"\n    if not Path(config[key]).exists():\n        raise FileNotFoundError(f\"{key} not found at {config[key]}\")\n    config[key] = Path(config[key])\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.import_module","title":"<code>import_module(module)</code>","text":"<p>Import module with importlib.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Path</code> <p>path to module.</p> required Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def import_module(module: Path):\n    \"\"\"Import module with importlib.\n\n    Args:\n        module (Path): path to module.\n    \"\"\"\n    # Import the module\n    spec = importlib.util.spec_from_file_location(  # type: ignore[attr-defined]\n        module.stem, module\n    )\n    module = importlib.util.module_from_spec(spec)  # type: ignore[attr-defined]\n    spec.loader.exec_module(module)\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.import_modules","title":"<code>import_modules(modules)</code>","text":"<p>Import modules specified in list of files.</p> <p>Parameters:</p> Name Type Description Default <code>modules</code> <code>list</code> <p>List of files</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a module does not exist.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def import_modules(modules: list[str | Path]):\n    \"\"\"Import modules specified in list of files.\n\n    Args:\n        modules (list): List of files\n\n    Raises:\n        ValueError: If a module does not exist.\n    \"\"\"\n    for module in modules:\n        module = Path(module)\n\n        # Check that module exists\n        if not module.exists():\n            raise FileNotFoundError(f\"Module not found at {module}\")\n        import_module(module)\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.load_config","title":"<code>load_config(config_path=Path(__file__).parent / 'defs' / 'demo_config.yml', validation=True, schema_fid=None)</code>","text":"<p>Load, validate, and convert Paths in a configuration file.</p> <p>Note, if using a custom graphfcn, load_config must be called with validation=True.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path</code> <p>The path to the configuration file.</p> <code>parent / 'defs' / 'demo_config.yml'</code> <code>validation</code> <code>bool</code> <p>Whether to validate the configuration. Defaults to True.</p> <code>True</code> <code>schema_fid</code> <code>Path</code> <p>The path to the schema file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The configuration.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def load_config(\n    config_path: Path = Path(__file__).parent / \"defs\" / \"demo_config.yml\",\n    validation: bool = True,\n    schema_fid: Path | None = None,\n):\n    \"\"\"Load, validate, and convert Paths in a configuration file.\n\n    Note, if using a custom graphfcn, load_config must be called with validation=True.\n\n    Args:\n        config_path (Path): The path to the configuration file.\n        validation (bool, optional): Whether to validate the configuration.\n            Defaults to True.\n        schema_fid (Path, optional): The path to the schema file. Defaults to\n            None.\n\n    Returns:\n        dict: The configuration.\n    \"\"\"\n    # Load the schema\n    schema_fid = (\n        Path(__file__).parent / \"defs\" / \"schema.yml\"\n        if schema_fid is None\n        else Path(schema_fid)\n    )\n    schema = yaml_load(schema_fid.read_text())\n\n    # Load the config\n    config = yaml_load(config_path.read_text())\n\n    if not validation:\n        return config\n\n    # Validate the config\n    jsonschema.validate(instance=config, schema=schema)\n\n    # Check top level paths\n    config = check_top_level_paths(config)\n\n    # Check address overrides\n    config = check_address_overrides(config)\n\n    # Check real network paths\n    config = check_real_network_paths(config)\n\n    # Check starting graph\n    config = check_starting_graph(config)\n\n    # Check parameter overrides\n    config = check_parameter_overrides(config)\n\n    # Check and register custom metrics\n    config = check_and_register_custom_metrics(config)\n\n    # Check and register custom graphfcns\n    config = check_and_register_custom_graphfcns(config)\n\n    # Register custom parameters\n    config = register_custom_parameters(config)\n\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.register_custom_parameters","title":"<code>register_custom_parameters(config)</code>","text":"<p>Register custom parameter modules.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def register_custom_parameters(config: dict):\n    \"\"\"Register custom parameter modules.\n\n    Args:\n        config (dict): The configuration.\n    \"\"\"\n    import_modules(config.get(\"custom_parameter_modules\", []))\n    return config\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.run","title":"<code>run(model, reporting_iters=50, duration=86400, storevars=['flooding', 'flow'])</code>","text":"<p>Run a SWMM model and store the results.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Path</code> <p>The path to the SWMM model .inp file.</p> required <code>reporting_iters</code> <code>int</code> <p>The number of iterations between storing results. Defaults to 50.</p> <code>50</code> <code>duration</code> <code>int</code> <p>The duration of the simulation in seconds. Starts at the 'START_DATE' and 'START_TIME' defined in the 'model' .inp file Defaults to 86400.</p> <code>86400</code> <code>storevars</code> <code>list[str]</code> <p>The variables to store. Defaults to ['flooding','flow'].</p> <code>['flooding', 'flow']</code> <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing the results.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def run(\n    model: Path,\n    reporting_iters: int = 50,\n    duration: int = 86400,\n    storevars: list[str] = [\"flooding\", \"flow\"],\n):\n    \"\"\"Run a SWMM model and store the results.\n\n    Args:\n        model (Path): The path to the SWMM model .inp file.\n        reporting_iters (int, optional): The number of iterations between\n            storing results. Defaults to 50.\n        duration (int, optional): The duration of the simulation in seconds.\n            Starts at the 'START_DATE' and 'START_TIME' defined in the 'model'\n            .inp file Defaults to 86400.\n        storevars (list[str], optional): The variables to store. Defaults to\n            ['flooding','flow'].\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the results.\n    \"\"\"\n    with pyswmm.Simulation(str(model)) as sim:\n        sim.start()\n        logger.info(f\"{model} initialised in pyswmm\")\n\n        # Define the variables to store\n        variables = {\n            \"flooding\": {\"class\": pyswmm.Nodes, \"id\": \"_nodeid\"},\n            \"depth\": {\"class\": pyswmm.Nodes, \"id\": \"_nodeid\"},\n            \"flow\": {\"class\": pyswmm.Links, \"id\": \"_linkid\"},\n            \"runoff\": {\"class\": pyswmm.Subcatchments, \"id\": \"_subcatchmentid\"},\n        }\n\n        results_list = []\n        for var, info in variables.items():\n            if var not in storevars:\n                continue\n            # Rather than calling eg Nodes or Links, only call them if they\n            # are needed for storevars because they carry a significant\n            # overhead\n            pobjs = info[\"class\"](sim)\n            results_list += [\n                {\"object\": x, \"variable\": var, \"id\": info[\"id\"]} for x in pobjs\n            ]\n\n        # Iterate the model\n        results = []\n        t_ = sim.current_time\n        ind = 0\n        logger.info(f\"Starting simulation for: {model}\")\n\n        progress_bar = tqdm(total=duration, disable=not verbose())\n\n        offset = 0\n        while (\n            (offset &lt;= duration)\n            &amp; (sim.current_time &lt; sim.end_time)\n            &amp; (not sim._terminate_request)\n        ):\n            progress_bar.update((sim.current_time - t_).total_seconds() - offset)\n            offset = (sim.current_time - t_).total_seconds()\n\n            ind += 1\n\n            # Iterate the main model timestep\n            time = sim._model.swmm_step()\n\n            # Break condition\n            if time &lt; 0:\n                sim._terminate_request = True\n                break\n\n            # Check whether to save results\n            if ind % reporting_iters != 1:\n                continue\n\n            # Store results in a list of dictionaries\n            for storevar in results_list:\n                results.append(\n                    {\n                        \"date\": sim.current_time,\n                        \"value\": getattr(storevar[\"object\"], storevar[\"variable\"]),\n                        \"variable\": storevar[\"variable\"],\n                        \"id\": getattr(storevar[\"object\"], storevar[\"id\"]),\n                    }\n                )\n\n    logger.info(\"Model run complete.\")\n    return pd.DataFrame(results)\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.save_config","title":"<code>save_config(config, config_path)</code>","text":"<p>Save the configuration to a file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <code>config_path</code> <code>Path</code> <p>The path to save the configuration.</p> required Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def save_config(config: dict, config_path: Path):\n    \"\"\"Save the configuration to a file.\n\n    Args:\n        config (dict): The configuration.\n        config_path (Path): The path to save the configuration.\n    \"\"\"\n    yaml_dump(config, config_path.open(\"w\"))\n</code></pre>"},{"location":"reference/#swmmanywhere.swmmanywhere.swmmanywhere","title":"<code>swmmanywhere(config)</code>","text":"<p>Run SWMManywhere processes.</p> <p>This function runs the SWMManywhere processes, including downloading data, preprocessing the graphfcns, running the model, and comparing the results to real data using metrics. The function will always return the path to the generated .inp file. If real data (either a results file or the .inp, as well as graph, and subcatchments) is provided, the function will also return the metrics comparing the synthetic network with the real.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The loaded config as a dict.</p> required <p>Returns:</p> Type Description <code>tuple[Path, dict | None]</code> <p>tuple[Path, dict | None]: The address of generated .inp and metrics.</p> Source code in <code>swmmanywhere/swmmanywhere.py</code> <pre><code>def swmmanywhere(config: dict) -&gt; tuple[Path, dict | None]:\n    \"\"\"Run SWMManywhere processes.\n\n    This function runs the SWMManywhere processes, including downloading data,\n    preprocessing the graphfcns, running the model, and comparing the results\n    to real data using metrics. The function will always return the path to\n    the generated .inp file. If real data (either a results file or the .inp,\n    as well as graph, and subcatchments) is provided, the function will also\n    return the metrics comparing the synthetic network with the real.\n\n    Args:\n        config (dict): The loaded config as a dict.\n\n    Returns:\n        tuple[Path, dict | None]: The address of generated .inp and metrics.\n    \"\"\"\n    # Check for defaults\n    config = _check_defaults(config)\n\n    # Currently precipitation must be provided via address_overrides, otherwise\n    # the default storm.dat file will be used\n    if not Path(\n        config.get(\"address_overrides\", {}).get(\n            \"precipitation\", Path(\"precipitation.dat\")\n        )\n    ).exists():\n        config[\"address_overrides\"] = config.get(\"address_overrides\", {})\n        config[\"address_overrides\"][\"precipitation\"] = (\n            Path(__file__).parent / \"defs\" / \"storm.dat\"\n        )\n\n    # Create the project structure\n    logger.info(\"Creating project structure.\")\n    addresses = filepaths.FilePaths(\n        config[\"base_dir\"],\n        config[\"project\"],\n        config[\"bbox\"],\n        config.get(\"bbox_number\", None),\n        config.get(\"model_number\", None),\n        config.get(\"extension\", \"parquet\"),\n        **config.get(\"address_overrides\", {}),\n    )\n\n    logger.info(f\"Project structure created at {addresses.project_paths.base_dir}\")\n    logger.info(f\"Project name: {config['project']}\")\n    logger.info(\n        f\"\"\"Bounding box: {config[\"bbox\"]}, \n                number: {addresses.bbox_paths.bbox_number}\"\"\"\n    )\n    logger.info(f\"Model number: {addresses.model_paths.model_number}\")\n\n    # Save config file\n    if verbose():\n        save_config(config, addresses.model_paths.model / \"config.yml\")\n\n    # Load the parameters and perform any manual overrides\n    logger.info(\"Loading and setting parameters.\")\n    params = parameters.get_full_parameters()\n    for category, overrides in config.get(\"parameter_overrides\", {}).items():\n        for key, val in overrides.items():\n            logger.info(f\"Setting {category} {key} to {val}\")\n            setattr(params[category], key, val)\n\n    # If `allowable_networks` has been changed, force a redownload of street graph.\n    if \"allowable_networks\" in config.get(\"parameter_overrides\", {}).get(\n        \"topology_derivation\", {}\n    ):\n        logger.info(\"Allowable networks have been changed, removing old street graph.\")\n        addresses.bbox_paths.street.unlink(missing_ok=True)\n\n    # Run downloads\n    logger.info(\"Running downloads.\")\n    preprocessing.run_downloads(\n        config[\"bbox\"],\n        addresses,\n        network_types=params[\"topology_derivation\"].allowable_networks,\n    )\n\n    # Identify the starting graph\n    logger.info(\"Iterating graphs.\")\n    if config.get(\"starting_graph\", None):\n        G = load_graph(config[\"starting_graph\"])\n    else:\n        G = preprocessing.create_starting_graph(addresses)\n\n    # Validate the graphfcn order\n    validate_graphfcn_list(config[\"graphfcn_list\"], G)\n\n    # Iterate the graph functions\n    logger.info(\"Iterating graph functions.\")\n    G = iterate_graphfcns(G, config[\"graphfcn_list\"], params, addresses)\n\n    # Save the final graph\n    logger.info(\"Saving final graph and writing inp file.\")\n    go.graph_to_geojson(\n        G, addresses.model_paths.nodes, addresses.model_paths.edges, G.graph[\"crs\"]\n    )\n    save_graph(G, addresses.model_paths.graph)\n\n    # Check any edges\n    if len(G.edges) == 0:\n        logger.warning(\"No edges in graph, returning graph file.\")\n        return addresses.model_paths.graph, None\n\n    # Write to .inp\n    synthetic_write(addresses)\n\n    # Return model if no run\n    if not config.get(\"run_model\", True):\n        return addresses.model_paths.inp, None\n\n    # Run the model\n    logger.info(\"Running the synthetic model.\")\n    synthetic_results = run(addresses.model_paths.inp, **config[\"run_settings\"])\n    logger.info(\"Writing synthetic results.\")\n    if verbose():\n        synthetic_results.to_parquet(addresses.model_paths.model / \"results.parquet\")\n\n    # Get the real results\n    if config.get(\"real\", {}).get(\"results\", None):\n        logger.info(\"Loading real results.\")\n        real_results = pd.read_parquet(config[\"real\"][\"results\"])\n    elif config.get(\"real\", {}).get(\"inp\", None):\n        logger.info(\"Running the real model.\")\n        real_results = run(config[\"real\"][\"inp\"], **config[\"run_settings\"])\n        if verbose():\n            real_results.to_parquet(\n                config[\"real\"][\"inp\"].parent / \"real_results.parquet\"\n            )\n    else:\n        logger.info(\"No real network provided, returning SWMM .inp file.\")\n        return addresses.model_paths.inp, None\n\n    # Iterate the metrics\n    logger.info(\"Iterating metrics.\")\n    if addresses.model_paths.subcatchments.suffix == \".geoparquet\":\n        subs = gpd.read_parquet(addresses.model_paths.subcatchments)\n    else:\n        subs = gpd.read_file(addresses.model_paths.subcatchments)\n\n    if config[\"real\"][\"subcatchments\"].suffix == \".geoparquet\":\n        real_subs = gpd.read_parquet(config[\"real\"][\"subcatchments\"])\n    else:\n        real_subs = gpd.read_file(config[\"real\"][\"subcatchments\"])\n    metrics = iterate_metrics(\n        synthetic_results,\n        subs,\n        G,\n        real_results,\n        real_subs,\n        load_graph(config[\"real\"][\"graph\"]),\n        config[\"metric_list\"],\n        params[\"metric_evaluation\"],\n    )\n    logger.info(\"Metrics complete\")\n    return addresses.model_paths.inp, metrics\n</code></pre>"},{"location":"notebooks/custom_data_demo/","title":"Custom data demo","text":"In\u00a0[1]: Copied! <pre># Imports\nfrom __future__ import annotations\n\nimport tempfile\nfrom pathlib import Path\n\nimport folium\nimport geopandas as gpd\n\nfrom swmmanywhere.logging import set_verbose\nfrom swmmanywhere.swmmanywhere import swmmanywhere\nfrom swmmanywhere.utilities import plot_map\n\n# Create temporary directory\ntemp_dir = tempfile.TemporaryDirectory(dir=\".\")\nbase_dir = Path(temp_dir.name)\n\n# Define minimum viable config\nbbox = (1.52740, 42.50524, 1.54273, 42.51259)\nconfig = {\n    \"base_dir\": base_dir,\n    \"project\": \"my_first_swmm\",\n    \"bbox\": bbox,\n    \"run_settings\": {\"duration\": 3600},\n    \"parameter_overrides\": {\n        \"topology_derivation\": {\n            \"allowable_networks\": [\"drive\"],\n            \"omit_edges\": [\"bridge\"],\n        },\n        \"outfall_derivation\": {\n            \"outfall_length\": 5,\n            \"river_buffer_distance\": 30,\n        },\n    },\n}\nset_verbose(True)  # Set verbosity\n\n# Run SWMManywhere\noutputs = swmmanywhere(config)\nmodel_dir = outputs[0].parent\n</pre> # Imports from __future__ import annotations  import tempfile from pathlib import Path  import folium import geopandas as gpd  from swmmanywhere.logging import set_verbose from swmmanywhere.swmmanywhere import swmmanywhere from swmmanywhere.utilities import plot_map  # Create temporary directory temp_dir = tempfile.TemporaryDirectory(dir=\".\") base_dir = Path(temp_dir.name)  # Define minimum viable config bbox = (1.52740, 42.50524, 1.54273, 42.51259) config = {     \"base_dir\": base_dir,     \"project\": \"my_first_swmm\",     \"bbox\": bbox,     \"run_settings\": {\"duration\": 3600},     \"parameter_overrides\": {         \"topology_derivation\": {             \"allowable_networks\": [\"drive\"],             \"omit_edges\": [\"bridge\"],         },         \"outfall_derivation\": {             \"outfall_length\": 5,             \"river_buffer_distance\": 30,         },     }, } set_verbose(True)  # Set verbosity  # Run SWMManywhere outputs = swmmanywhere(config) model_dir = outputs[0].parent <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>2025/10/10 14:35:28 | Creating project structure.\n</pre> <pre>2025/10/10 14:35:28 | Project structure created at tmpq9xfrgih\n</pre> <pre>2025/10/10 14:35:28 | Project name: my_first_swmm\n</pre> <pre>2025/10/10 14:35:28 | Bounding box: (1.5274, 42.50524, 1.54273, 42.51259), \n                number: 1\n</pre> <pre>2025/10/10 14:35:28 | Model number: 1\n</pre> <pre>2025/10/10 14:35:28 | Loading and setting parameters.\n</pre> <pre>2025/10/10 14:35:28 | Setting topology_derivation allowable_networks to ['drive']\n</pre> <pre>2025/10/10 14:35:28 | Setting topology_derivation omit_edges to ['bridge']\n</pre> <pre>2025/10/10 14:35:28 | Setting outfall_derivation outfall_length to 5\n</pre> <pre>2025/10/10 14:35:28 | Setting outfall_derivation river_buffer_distance to 30\n</pre> <pre>2025/10/10 14:35:28 | Allowable networks have been changed, removing old street graph.\n</pre> <pre>2025/10/10 14:35:28 | Running downloads.\n</pre> <pre>2025/10/10 14:35:28 | downloading elevation to tmpq9xfrgih/my_first_swmm/bbox_1/download/elevation.tif\n</pre> <pre>2025/10/10 14:35:35 | downloading buildings to tmpq9xfrgih/my_first_swmm/bbox_1/download/building.geoparquet\n</pre> <pre>2025/10/10 14:35:48 | downloading network to tmpq9xfrgih/my_first_swmm/bbox_1/download/street.parquet\n</pre> <pre>2025/10/10 14:36:51 | downloading river network to tmpq9xfrgih/my_first_swmm/bbox_1/download/river.parquet\n</pre> <pre>2025/10/10 14:36:52 | Iterating graphs.\n</pre> <pre>2025/10/10 14:36:52 | Iterating graph functions.\n</pre> <pre>2025/10/10 14:36:52 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:36:52 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:36:52 | graphfcn: remove_non_pipe_allowable_links completed.\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/networkx/readwrite/json_graph/node_link.py:290: FutureWarning: \nThe default value will be changed to `edges=\"edges\" in NetworkX 3.6.\n\nTo make this warning go away, explicitly set the edges kwarg, e.g.:\n\n  nx.node_link_graph(data, edges=\"links\") to preserve current behavior, or\n  nx.node_link_graph(data, edges=\"edges\") for forward compatibility.\n  warnings.warn(\n</pre> <pre>2025/10/10 14:36:52 | graphfcn: calculate_streetcover completed.\n</pre> <pre>2025/10/10 14:36:52 | graphfcn: remove_parallel_edges completed.\n</pre> <pre>2025/10/10 14:36:53 | graphfcn: to_undirected completed.\n</pre> <pre>2025/10/10 14:36:53 | graphfcn: split_long_edges completed.\n</pre> <pre>2025/10/10 14:36:53 | graphfcn: merge_street_nodes completed.\n</pre> <pre>2025/10/10 14:36:53 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:36:58 | graphfcn: clip_to_catchments completed.\n</pre> <pre>2025/10/10 14:36:59 | graphfcn: calculate_contributing_area completed.\n</pre> <pre>2025/10/10 14:36:59 | graphfcn: set_elevation completed.\n</pre> <pre>2025/10/10 14:36:59 | graphfcn: double_directed completed.\n</pre> <pre>2025/10/10 14:37:00 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:37:00 | graphfcn: set_surface_slope completed.\n</pre> <pre>2025/10/10 14:37:00 | graphfcn: set_chahinian_slope completed.\n</pre> <pre>2025/10/10 14:37:00 | graphfcn: set_chahinian_angle completed.\n</pre> <pre>2025/10/10 14:37:00 | graphfcn: calculate_weights completed.\n</pre> <pre>2025/10/10 14:37:00 | No outfalls found for subgraph containing \n                        858, using this node as outfall.\n</pre> <pre>2025/10/10 14:37:00 | No outfalls found for subgraph containing \n                        823, using this node as outfall.\n</pre> <pre>2025/10/10 14:37:00 | No outfalls found for subgraph containing \n                        507, using this node as outfall.\n</pre> <pre>2025/10/10 14:37:00 | No outfalls found for subgraph containing \n                        674, using this node as outfall.\n</pre> <pre>2025/10/10 14:37:00 | No outfalls found for subgraph containing \n                        754, using this node as outfall.\n</pre> <pre>2025/10/10 14:37:00 | No outfalls found for subgraph containing \n                        779, using this node as outfall.\n</pre> <pre>2025/10/10 14:37:00 | No outfalls found for subgraph containing \n                        1255, using this node as outfall.\n</pre> <pre>2025/10/10 14:37:00 | No outfalls found for subgraph containing \n                        1535, using this node as outfall.\n</pre> <pre>2025/10/10 14:37:00 | graphfcn: identify_outfalls completed.\n</pre> <pre>2025/10/10 14:37:01 | Total graph weight 264.28645874589057.\n</pre> <pre>2025/10/10 14:37:01 | graphfcn: derive_topology completed.\n</pre> <pre>\r  0%|          | 0/395 [00:00&lt;?, ?it/s]</pre> <pre>\r 11%|\u2588         | 42/395 [00:00&lt;00:00, 415.47it/s]</pre> <pre>\r 22%|\u2588\u2588\u258f       | 88/395 [00:00&lt;00:00, 433.94it/s]</pre> <pre>\r 33%|\u2588\u2588\u2588\u258e      | 132/395 [00:00&lt;00:00, 407.61it/s]</pre> <pre>\r 44%|\u2588\u2588\u2588\u2588\u258d     | 173/395 [00:00&lt;00:00, 344.30it/s]</pre> <pre>\r 53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 209/395 [00:00&lt;00:00, 323.32it/s]</pre> <pre>\r 62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 243/395 [00:00&lt;00:00, 291.37it/s]</pre> <pre>\r 69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 273/395 [00:00&lt;00:00, 283.80it/s]</pre> <pre>\r 77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 304/395 [00:00&lt;00:00, 287.43it/s]</pre> <pre>\r 85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 334/395 [00:01&lt;00:00, 286.69it/s]</pre> <pre>\r 92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 363/395 [00:01&lt;00:00, 256.55it/s]</pre> <pre>\r 99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 390/395 [00:01&lt;00:00, 259.13it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 395/395 [00:01&lt;00:00, 297.39it/s]</pre> <pre>2025/10/10 14:37:02 | graphfcn: pipe_by_pipe completed.\n</pre> <pre>2025/10/10 14:37:02 | graphfcn: fix_geometries completed.\n</pre> <pre>\n</pre> <pre>2025/10/10 14:37:02 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:37:02 | Saving final graph and writing inp file.\n</pre> <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> <pre>2025/10/10 14:37:03 | Running the synthetic model.\n</pre> <pre>2025/10/10 14:37:03 | tmpq9xfrgih/my_first_swmm/bbox_1/model_1/model_1.inp initialised in pyswmm\n</pre> <pre>2025/10/10 14:37:03 | Starting simulation for: tmpq9xfrgih/my_first_swmm/bbox_1/model_1/model_1.inp\n</pre> <pre>\r  0%|          | 0/3600 [00:00&lt;?, ?it/s]</pre> <pre>\r 13%|\u2588\u258e        | 483.0/3600 [00:00&lt;00:00, 4815.13it/s]</pre> <pre>\r 27%|\u2588\u2588\u258b       | 965.0/3600 [00:00&lt;00:01, 2388.51it/s]</pre> <pre>\r 35%|\u2588\u2588\u2588\u258c      | 1268.0/3600 [00:00&lt;00:01, 2160.15it/s]</pre> <pre>\r 44%|\u2588\u2588\u2588\u2588\u258d     | 1580.0/3600 [00:00&lt;00:00, 2406.82it/s]</pre> <pre>\r 56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 2021.0/3600 [00:00&lt;00:00, 2948.13it/s]</pre> <pre>\r 75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2695.0/3600 [00:00&lt;00:00, 4001.00it/s]</pre> <pre>2025/10/10 14:37:04 | Model run complete.\n</pre> <pre>\r3605.0it [00:00, 3748.40it/s]                          </pre> <pre>2025/10/10 14:37:04 | Writing synthetic results.\n</pre> <pre>2025/10/10 14:37:04 | No real network provided, returning SWMM .inp file.\n</pre> <pre>\n</pre> In\u00a0[2]: Copied! <pre>m = plot_map(model_dir)\nsubbasins = gpd.read_file(model_dir / \"subbasins.geoparquet\")\nfolium.GeoJson(subbasins, fill_opacity=0, color=\"blue\", weight=2).add_to(m)\nm\n</pre> m = plot_map(model_dir) subbasins = gpd.read_file(model_dir / \"subbasins.geoparquet\") folium.GeoJson(subbasins, fill_opacity=0, color=\"blue\", weight=2).add_to(m) m <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre># Import NASADEM downloader and reprojection tools\nfrom swmmanywhere.geospatial_utilities import (  # noqa: E402\n    get_utm_epsg,\n    reproject_raster,\n)\nfrom swmmanywhere.prepare_data import download_elevation  # noqa: E402\n\n# Download and reproject the correct elevation to UTM\ndownload_elevation(base_dir / \"elevation.tif\", bbox)\nreproject_raster(\n    get_utm_epsg(bbox[0], bbox[1]),\n    base_dir / \"elevation.tif\",\n    base_dir / \"elevation_utm.tif\",\n)\n\n# Flip it\nimport numpy as np  # noqa: E402\nimport rasterio  # noqa: E402\n\nwith rasterio.open(base_dir / \"elevation_utm.tif\") as src:\n    data = np.fliplr(src.read(1))\n    with rasterio.open(base_dir / \"fake_elevation.tif\", \"w\", **src.profile) as dst:\n        dst.write(data, 1)\n</pre>  # Import NASADEM downloader and reprojection tools from swmmanywhere.geospatial_utilities import (  # noqa: E402     get_utm_epsg,     reproject_raster, ) from swmmanywhere.prepare_data import download_elevation  # noqa: E402  # Download and reproject the correct elevation to UTM download_elevation(base_dir / \"elevation.tif\", bbox) reproject_raster(     get_utm_epsg(bbox[0], bbox[1]),     base_dir / \"elevation.tif\",     base_dir / \"elevation_utm.tif\", )  # Flip it import numpy as np  # noqa: E402 import rasterio  # noqa: E402  with rasterio.open(base_dir / \"elevation_utm.tif\") as src:     data = np.fliplr(src.read(1))     with rasterio.open(base_dir / \"fake_elevation.tif\", \"w\", **src.profile) as dst:         dst.write(data, 1) In\u00a0[4]: Copied! <pre># Update config\nconfig[\"address_overrides\"] = {\n    \"elevation\": str(base_dir / \"fake_elevation.tif\"),\n}\n\n# Run again\noutputs = swmmanywhere(config)\nmodel_dir = outputs[0].parent\n</pre> # Update config config[\"address_overrides\"] = {     \"elevation\": str(base_dir / \"fake_elevation.tif\"), }  # Run again outputs = swmmanywhere(config) model_dir = outputs[0].parent <pre>2025/10/10 14:38:13 | Creating project structure.\n</pre> <pre>2025/10/10 14:38:13 | Project structure created at tmpq9xfrgih\n</pre> <pre>2025/10/10 14:38:13 | Project name: my_first_swmm\n</pre> <pre>2025/10/10 14:38:13 | Bounding box: (1.5274, 42.50524, 1.54273, 42.51259), \n                number: 1\n</pre> <pre>2025/10/10 14:38:13 | Model number: 2\n</pre> <pre>2025/10/10 14:38:13 | Loading and setting parameters.\n</pre> <pre>2025/10/10 14:38:13 | Setting topology_derivation allowable_networks to ['drive']\n</pre> <pre>2025/10/10 14:38:13 | Setting topology_derivation omit_edges to ['bridge']\n</pre> <pre>2025/10/10 14:38:13 | Setting outfall_derivation outfall_length to 5\n</pre> <pre>2025/10/10 14:38:13 | Setting outfall_derivation river_buffer_distance to 30\n</pre> <pre>2025/10/10 14:38:13 | Allowable networks have been changed, removing old street graph.\n</pre> <pre>2025/10/10 14:38:13 | Running downloads.\n</pre> <pre>2025/10/10 14:38:13 | downloading network to tmpq9xfrgih/my_first_swmm/bbox_1/download/street.parquet\n</pre> <pre>2025/10/10 14:38:16 | Iterating graphs.\n</pre> <pre>2025/10/10 14:38:16 | Iterating graph functions.\n</pre> <pre>2025/10/10 14:38:16 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:38:16 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:38:16 | graphfcn: remove_non_pipe_allowable_links completed.\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/networkx/readwrite/json_graph/node_link.py:290: FutureWarning: \nThe default value will be changed to `edges=\"edges\" in NetworkX 3.6.\n\nTo make this warning go away, explicitly set the edges kwarg, e.g.:\n\n  nx.node_link_graph(data, edges=\"links\") to preserve current behavior, or\n  nx.node_link_graph(data, edges=\"edges\") for forward compatibility.\n  warnings.warn(\n</pre> <pre>2025/10/10 14:38:16 | graphfcn: calculate_streetcover completed.\n</pre> <pre>2025/10/10 14:38:16 | graphfcn: remove_parallel_edges completed.\n</pre> <pre>2025/10/10 14:38:16 | graphfcn: to_undirected completed.\n</pre> <pre>2025/10/10 14:38:17 | graphfcn: split_long_edges completed.\n</pre> <pre>2025/10/10 14:38:17 | graphfcn: merge_street_nodes completed.\n</pre> <pre>2025/10/10 14:38:17 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:38:18 | graphfcn: clip_to_catchments completed.\n</pre> <pre>2025/10/10 14:38:20 | graphfcn: calculate_contributing_area completed.\n</pre> <pre>2025/10/10 14:38:20 | graphfcn: set_elevation completed.\n</pre> <pre>2025/10/10 14:38:20 | graphfcn: double_directed completed.\n</pre> <pre>2025/10/10 14:38:20 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:38:20 | graphfcn: set_surface_slope completed.\n</pre> <pre>2025/10/10 14:38:20 | graphfcn: set_chahinian_slope completed.\n</pre> <pre>2025/10/10 14:38:20 | graphfcn: set_chahinian_angle completed.\n</pre> <pre>2025/10/10 14:38:21 | graphfcn: calculate_weights completed.\n</pre> <pre>2025/10/10 14:38:21 | No outfalls found for subgraph containing \n                        474, using this node as outfall.\n</pre> <pre>2025/10/10 14:38:21 | No outfalls found for subgraph containing \n                        653, using this node as outfall.\n</pre> <pre>2025/10/10 14:38:21 | No outfalls found for subgraph containing \n                        713, using this node as outfall.\n</pre> <pre>2025/10/10 14:38:21 | No outfalls found for subgraph containing \n                        745, using this node as outfall.\n</pre> <pre>2025/10/10 14:38:21 | No outfalls found for subgraph containing \n                        780, using this node as outfall.\n</pre> <pre>2025/10/10 14:38:21 | No outfalls found for subgraph containing \n                        1536, using this node as outfall.\n</pre> <pre>2025/10/10 14:38:21 | graphfcn: identify_outfalls completed.\n</pre> <pre>2025/10/10 14:38:21 | Total graph weight 277.4753575488574.\n</pre> <pre>2025/10/10 14:38:21 | graphfcn: derive_topology completed.\n</pre> <pre>\r  0%|          | 0/386 [00:00&lt;?, ?it/s]</pre> <pre>\r  9%|\u2589         | 36/386 [00:00&lt;00:00, 356.55it/s]</pre> <pre>\r 19%|\u2588\u258a        | 72/386 [00:00&lt;00:01, 297.76it/s]</pre> <pre>\r 27%|\u2588\u2588\u258b       | 103/386 [00:00&lt;00:01, 276.75it/s]</pre> <pre>\r 34%|\u2588\u2588\u2588\u258d      | 132/386 [00:00&lt;00:00, 281.12it/s]</pre> <pre>\r 42%|\u2588\u2588\u2588\u2588\u258f     | 161/386 [00:00&lt;00:01, 217.84it/s]</pre> <pre>\r 48%|\u2588\u2588\u2588\u2588\u258a     | 185/386 [00:00&lt;00:01, 194.16it/s]</pre> <pre>\r 53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 206/386 [00:00&lt;00:00, 185.06it/s]</pre> <pre>\r 60%|\u2588\u2588\u2588\u2588\u2588\u2589    | 230/386 [00:01&lt;00:00, 196.92it/s]</pre> <pre>\r 65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 251/386 [00:01&lt;00:00, 198.12it/s]</pre> <pre>\r 72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 276/386 [00:01&lt;00:00, 210.65it/s]</pre> <pre>\r 79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 304/386 [00:01&lt;00:00, 227.93it/s]</pre> <pre>\r 86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 331/386 [00:01&lt;00:00, 238.36it/s]</pre> <pre>\r 92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 356/386 [00:01&lt;00:00, 227.92it/s]</pre> <pre>\r 98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 380/386 [00:01&lt;00:00, 223.79it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 386/386 [00:01&lt;00:00, 225.39it/s]</pre> <pre>2025/10/10 14:38:23 | graphfcn: pipe_by_pipe completed.\n</pre> <pre>\n</pre> <pre>2025/10/10 14:38:23 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:38:23 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:38:23 | Saving final graph and writing inp file.\n</pre> <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> <pre>2025/10/10 14:38:24 | Running the synthetic model.\n</pre> <pre>2025/10/10 14:38:24 | tmpq9xfrgih/my_first_swmm/bbox_1/model_2/model_2.inp initialised in pyswmm\n</pre> <pre>2025/10/10 14:38:24 | Starting simulation for: tmpq9xfrgih/my_first_swmm/bbox_1/model_2/model_2.inp\n</pre> <pre>\r  0%|          | 0/3600 [00:00&lt;?, ?it/s]</pre> <pre>\r 14%|\u2588\u258d        | 501.0/3600 [00:00&lt;00:00, 4992.22it/s]</pre> <pre>\r 28%|\u2588\u2588\u258a       | 1001.0/3600 [00:00&lt;00:01, 2497.80it/s]</pre> <pre>\r 37%|\u2588\u2588\u2588\u258b      | 1317.0/3600 [00:00&lt;00:00, 2399.73it/s]</pre> <pre>\r 46%|\u2588\u2588\u2588\u2588\u258b     | 1668.0/3600 [00:00&lt;00:00, 2701.30it/s]</pre> <pre>\r 64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 2297.0/3600 [00:00&lt;00:00, 3704.22it/s]</pre> <pre>\r 86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3096.0/3600 [00:00&lt;00:00, 4929.06it/s]</pre> <pre>2025/10/10 14:38:25 | Model run complete.\n</pre> <pre>\r3603.0it [00:00, 4074.28it/s]                          </pre> <pre>2025/10/10 14:38:25 | Writing synthetic results.\n</pre> <pre>2025/10/10 14:38:25 | No real network provided, returning SWMM .inp file.\n</pre> <pre>\n</pre> In\u00a0[5]: Copied! <pre>m = plot_map(model_dir)\nsubbasins_new = gpd.read_file(model_dir / \"subbasins.geoparquet\")\nfolium.GeoJson(subbasins_new, fill_opacity=0, color=\"red\", weight=2).add_to(m)\nfolium.GeoJson(subbasins, fill_opacity=0, color=\"blue\", weight=2).add_to(m)\nm\n</pre> m = plot_map(model_dir) subbasins_new = gpd.read_file(model_dir / \"subbasins.geoparquet\") folium.GeoJson(subbasins_new, fill_opacity=0, color=\"red\", weight=2).add_to(m) folium.GeoJson(subbasins, fill_opacity=0, color=\"blue\", weight=2).add_to(m) m <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"notebooks/custom_data_demo/#custom-data-demo","title":"Custom data demo\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/notebooks. To run this on your local machine, you will need to install the optional dependencies for <code>doc</code>:</p> <p><code>pip install swmmanywhere[doc]</code></p>"},{"location":"notebooks/custom_data_demo/#introduction","title":"Introduction\u00b6","text":"<p>This script demonstrates how to use <code>swmmanywhere</code> when you have custom data.</p> <p>Since this is a notebook, we will define <code>config</code> as a dictionary rather than a <code>yaml</code> file, but the same principles apply.</p>"},{"location":"notebooks/custom_data_demo/#initial-setup","title":"Initial setup\u00b6","text":"<p>We will use the same example as the extended demo, but with a custom elevation dataset. Let's start by rerunning it.</p>"},{"location":"notebooks/custom_data_demo/#plotting-output","title":"Plotting output\u00b6","text":"<p>Now we can plot the output. To highlight the differences in the supplied data that we are about to demonstrate, we also plot the subbasins.</p>"},{"location":"notebooks/custom_data_demo/#supply-custom-elevation-data","title":"Supply custom elevation data\u00b6","text":"<p>To keep things simple, we will just download some elevation data for the same area and perturb it, though in practice you are likely to use some higher resolution or more accurate data.</p> <p>You don't need to worry about your files lining up perfectly (though of course if they do not overlap at all then you will run into problems).</p>"},{"location":"notebooks/custom_data_demo/#update-config-and-run-again","title":"Update config and run again\u00b6","text":"<p>Now we update the <code>elevation</code> entry in the <code>address_overrides</code> part of the <code>config</code> to point to the new elevation data, then rerun <code>swmmanywhere</code>.</p>"},{"location":"notebooks/custom_data_demo/#plotting-output","title":"Plotting output\u00b6","text":"<p>This time we will include both the original (blue) and the new (red) subbasins to highlight the impact of flipping the elevation data.</p>"},{"location":"notebooks/custom_data_demo/#in-summary","title":"In Summary\u00b6","text":"<p>This tutorial has demonstrated how we can supply our own data in place of the existing files that are downloaded by SWMManywhere. This method works for any filepath, which are the files used by the current workflow.</p> <p>You can also use <code>address_overrides</code> to you add your own custom data that might be used by a custom graphfcn , for example. If you are adding new data to the SWMManywhere workflow in this way, you will have to access it from the <code>FilePaths</code> object with the <code>get_path</code> method.</p>"},{"location":"notebooks/extended_demo/","title":"Extended Demo","text":"In\u00a0[1]: Copied! <pre># Imports\nfrom __future__ import annotations\n\nimport tempfile\nfrom pathlib import Path\n\nimport folium\nimport geopandas as gpd\nimport pandas as pd\n\nfrom swmmanywhere.logging import set_verbose\nfrom swmmanywhere.swmmanywhere import swmmanywhere\nfrom swmmanywhere.utilities import plot_map\n\n# Create temporary directory\ntemp_dir = tempfile.TemporaryDirectory(dir=\".\")\nbase_dir = Path(temp_dir.name)\n\n# Define minimum viable config (with shorter duration so better inspect results)\nconfig = {\n    \"base_dir\": base_dir,\n    \"project\": \"my_first_swmm\",\n    \"bbox\": [1.52740, 42.50524, 1.54273, 42.51259],\n    \"run_settings\": {\"duration\": 3600},\n}\n\n# Run SWMManywhere\noutputs = swmmanywhere(config)\n\n# Verify the output\nmodel_file = outputs[0]\nif not model_file.exists():\n    raise FileNotFoundError(f\"Model file not created: {model_file}\")\n</pre> # Imports from __future__ import annotations  import tempfile from pathlib import Path  import folium import geopandas as gpd import pandas as pd  from swmmanywhere.logging import set_verbose from swmmanywhere.swmmanywhere import swmmanywhere from swmmanywhere.utilities import plot_map  # Create temporary directory temp_dir = tempfile.TemporaryDirectory(dir=\".\") base_dir = Path(temp_dir.name)  # Define minimum viable config (with shorter duration so better inspect results) config = {     \"base_dir\": base_dir,     \"project\": \"my_first_swmm\",     \"bbox\": [1.52740, 42.50524, 1.54273, 42.51259],     \"run_settings\": {\"duration\": 3600}, }  # Run SWMManywhere outputs = swmmanywhere(config)  # Verify the output model_file = outputs[0] if not model_file.exists():     raise FileNotFoundError(f\"Model file not created: {model_file}\") <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/networkx/readwrite/json_graph/node_link.py:290: FutureWarning: \nThe default value will be changed to `edges=\"edges\" in NetworkX 3.6.\n\nTo make this warning go away, explicitly set the edges kwarg, e.g.:\n\n  nx.node_link_graph(data, edges=\"links\") to preserve current behavior, or\n  nx.node_link_graph(data, edges=\"edges\") for forward compatibility.\n  warnings.warn(\n</pre> <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field access: unsupported OGR type: 5\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> In\u00a0[2]: Copied! <pre># Create a folium map and add the nodes and edges\nplot_map(model_file.parent)\n</pre> # Create a folium map and add the nodes and edges plot_map(model_file.parent) <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field access: unsupported OGR type: 5\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>OK, it's done something! Though perhaps we're not super satisfied with the output.</p> In\u00a0[3]: Copied! <pre>config[\"parameter_overrides\"] = {\n    \"topology_derivation\": {\n        \"allowable_networks\": [\"drive\"],\n        \"omit_edges\": [\"bridge\"],\n    },\n    \"outfall_derivation\": {\n        \"outfall_length\": 5,\n        \"river_buffer_distance\": 30,\n    },\n}\noutputs = swmmanywhere(config)\nplot_map(outputs[0].parent)\n</pre> config[\"parameter_overrides\"] = {     \"topology_derivation\": {         \"allowable_networks\": [\"drive\"],         \"omit_edges\": [\"bridge\"],     },     \"outfall_derivation\": {         \"outfall_length\": 5,         \"river_buffer_distance\": 30,     }, } outputs = swmmanywhere(config) plot_map(outputs[0].parent) <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/networkx/readwrite/json_graph/node_link.py:290: FutureWarning: \nThe default value will be changed to `edges=\"edges\" in NetworkX 3.6.\n\nTo make this warning go away, explicitly set the edges kwarg, e.g.:\n\n  nx.node_link_graph(data, edges=\"links\") to preserve current behavior, or\n  nx.node_link_graph(data, edges=\"edges\") for forward compatibility.\n  warnings.warn(\n</pre> <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>OK that clearly helped, although we have appear to have stranded pipes (e.g., along Carrer dels Canals in North West), presumably due to some mistake in the OSM specifying that it is connected via a pedestrian route. We won't remedy this in the tutorial, but you can manually provide your <code>starting_graph</code> via the configuration file to address such mistakes.</p> <p>More importantly we can see some distinctive unconnected network in the South West. What is going on there? To explain this we will have to turn on verbosity to print the intermediate files used in model derivation.</p> <p>To do this with a command line call we simply add the flag <code>--verbose=True</code>. Though in code we will have to use <code>set_verbose</code> from the <code>logging</code> module.</p> In\u00a0[4]: Copied! <pre># Make verbose\nset_verbose(True)  # Set verbosity\n\n# Run again\noutputs = swmmanywhere(config)\nmodel_dir = outputs[0].parent\nm = plot_map(model_dir)\n</pre> # Make verbose set_verbose(True)  # Set verbosity  # Run again outputs = swmmanywhere(config) model_dir = outputs[0].parent m = plot_map(model_dir) <pre>2025/10/10 14:41:26 | Creating project structure.\n</pre> <pre>2025/10/10 14:41:26 | Project structure created at tmpxu8p_d54\n</pre> <pre>2025/10/10 14:41:26 | Project name: my_first_swmm\n</pre> <pre>2025/10/10 14:41:26 | Bounding box: [1.5274, 42.50524, 1.54273, 42.51259], \n                number: 1\n</pre> <pre>2025/10/10 14:41:26 | Model number: 3\n</pre> <pre>2025/10/10 14:41:26 | Loading and setting parameters.\n</pre> <pre>2025/10/10 14:41:26 | Setting topology_derivation allowable_networks to ['drive']\n</pre> <pre>2025/10/10 14:41:26 | Setting topology_derivation omit_edges to ['bridge']\n</pre> <pre>2025/10/10 14:41:26 | Setting outfall_derivation outfall_length to 5\n</pre> <pre>2025/10/10 14:41:26 | Setting outfall_derivation river_buffer_distance to 30\n</pre> <pre>2025/10/10 14:41:26 | Allowable networks have been changed, removing old street graph.\n</pre> <pre>2025/10/10 14:41:26 | Running downloads.\n</pre> <pre>2025/10/10 14:41:26 | downloading network to tmpxu8p_d54/my_first_swmm/bbox_1/download/street.parquet\n</pre> <pre>2025/10/10 14:41:27 | Iterating graphs.\n</pre> <pre>2025/10/10 14:41:27 | Iterating graph functions.\n</pre> <pre>2025/10/10 14:41:27 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:41:27 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:41:27 | graphfcn: remove_non_pipe_allowable_links completed.\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/networkx/readwrite/json_graph/node_link.py:290: FutureWarning: \nThe default value will be changed to `edges=\"edges\" in NetworkX 3.6.\n\nTo make this warning go away, explicitly set the edges kwarg, e.g.:\n\n  nx.node_link_graph(data, edges=\"links\") to preserve current behavior, or\n  nx.node_link_graph(data, edges=\"edges\") for forward compatibility.\n  warnings.warn(\n</pre> <pre>2025/10/10 14:41:27 | graphfcn: calculate_streetcover completed.\n</pre> <pre>2025/10/10 14:41:27 | graphfcn: remove_parallel_edges completed.\n</pre> <pre>2025/10/10 14:41:27 | graphfcn: to_undirected completed.\n</pre> <pre>2025/10/10 14:41:27 | graphfcn: split_long_edges completed.\n</pre> <pre>2025/10/10 14:41:28 | graphfcn: merge_street_nodes completed.\n</pre> <pre>2025/10/10 14:41:28 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:41:29 | graphfcn: clip_to_catchments completed.\n</pre> <pre>2025/10/10 14:41:30 | graphfcn: calculate_contributing_area completed.\n</pre> <pre>2025/10/10 14:41:30 | graphfcn: set_elevation completed.\n</pre> <pre>2025/10/10 14:41:30 | graphfcn: double_directed completed.\n</pre> <pre>2025/10/10 14:41:31 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:41:31 | graphfcn: set_surface_slope completed.\n</pre> <pre>2025/10/10 14:41:31 | graphfcn: set_chahinian_slope completed.\n</pre> <pre>2025/10/10 14:41:31 | graphfcn: set_chahinian_angle completed.\n</pre> <pre>2025/10/10 14:41:31 | graphfcn: calculate_weights completed.\n</pre> <pre>2025/10/10 14:41:31 | No outfalls found for subgraph containing \n                        858, using this node as outfall.\n</pre> <pre>2025/10/10 14:41:31 | No outfalls found for subgraph containing \n                        823, using this node as outfall.\n</pre> <pre>2025/10/10 14:41:31 | No outfalls found for subgraph containing \n                        507, using this node as outfall.\n</pre> <pre>2025/10/10 14:41:31 | No outfalls found for subgraph containing \n                        674, using this node as outfall.\n</pre> <pre>2025/10/10 14:41:31 | No outfalls found for subgraph containing \n                        754, using this node as outfall.\n</pre> <pre>2025/10/10 14:41:31 | No outfalls found for subgraph containing \n                        779, using this node as outfall.\n</pre> <pre>2025/10/10 14:41:31 | No outfalls found for subgraph containing \n                        1255, using this node as outfall.\n</pre> <pre>2025/10/10 14:41:31 | No outfalls found for subgraph containing \n                        1535, using this node as outfall.\n</pre> <pre>2025/10/10 14:41:31 | graphfcn: identify_outfalls completed.\n</pre> <pre>2025/10/10 14:41:32 | Total graph weight 264.28645874589057.\n</pre> <pre>2025/10/10 14:41:32 | graphfcn: derive_topology completed.\n</pre> <pre>\r  0%|          | 0/395 [00:00&lt;?, ?it/s]</pre> <pre>\r 11%|\u2588         | 42/395 [00:00&lt;00:00, 411.14it/s]</pre> <pre>\r 22%|\u2588\u2588\u258f       | 87/395 [00:00&lt;00:00, 429.81it/s]</pre> <pre>\r 33%|\u2588\u2588\u2588\u258e      | 130/395 [00:00&lt;00:00, 400.54it/s]</pre> <pre>\r 43%|\u2588\u2588\u2588\u2588\u258e     | 171/395 [00:00&lt;00:00, 340.27it/s]</pre> <pre>\r 52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 207/395 [00:00&lt;00:00, 318.50it/s]</pre> <pre>\r 61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 240/395 [00:00&lt;00:00, 291.33it/s]</pre> <pre>\r 68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 270/395 [00:00&lt;00:00, 282.34it/s]</pre> <pre>\r 76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 299/395 [00:00&lt;00:00, 281.02it/s]</pre> <pre>\r 84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 330/395 [00:01&lt;00:00, 287.08it/s]</pre> <pre>\r 91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 359/395 [00:01&lt;00:00, 261.71it/s]</pre> <pre>\r 98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 386/395 [00:01&lt;00:00, 250.42it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 395/395 [00:01&lt;00:00, 294.26it/s]</pre> <pre>2025/10/10 14:41:33 | graphfcn: pipe_by_pipe completed.\n</pre> <pre>\n</pre> <pre>2025/10/10 14:41:33 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:41:33 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:41:33 | Saving final graph and writing inp file.\n</pre> <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> <pre>2025/10/10 14:41:34 | Running the synthetic model.\n</pre> <pre>2025/10/10 14:41:34 | tmpxu8p_d54/my_first_swmm/bbox_1/model_3/model_3.inp initialised in pyswmm\n</pre> <pre>2025/10/10 14:41:34 | Starting simulation for: tmpxu8p_d54/my_first_swmm/bbox_1/model_3/model_3.inp\n</pre> <pre>\r  0%|          | 0/3600 [00:00&lt;?, ?it/s]</pre> <pre>\r 13%|\u2588\u258e        | 479.0/3600 [00:00&lt;00:00, 4785.38it/s]</pre> <pre>\r 27%|\u2588\u2588\u258b       | 958.0/3600 [00:00&lt;00:01, 2391.35it/s]</pre> <pre>\r 35%|\u2588\u2588\u2588\u258c      | 1260.0/3600 [00:00&lt;00:01, 2153.38it/s]</pre> <pre>\r 44%|\u2588\u2588\u2588\u2588\u258e     | 1566.0/3600 [00:00&lt;00:00, 2387.10it/s]</pre> <pre>\r 56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 2009.0/3600 [00:00&lt;00:00, 2936.73it/s]</pre> <pre>\r 74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2653.0/3600 [00:00&lt;00:00, 3911.32it/s]</pre> <pre>2025/10/10 14:41:35 | Model run complete.\n</pre> <pre>\r3603.0it [00:00, 3742.08it/s]                          </pre> <pre>2025/10/10 14:41:35 | Writing synthetic results.\n</pre> <pre>2025/10/10 14:41:35 | No real network provided, returning SWMM .inp file.\n</pre> <pre>\nSkipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> <p>That's a lot of information! However, the reason we are currently interested in this is because the files associated with each workflow step are saved when <code>verbose=True</code>.</p> <p>We will load a file called <code>subbasins</code> and add it to the map.</p> In\u00a0[5]: Copied! <pre>subbasins = gpd.read_file(model_dir / \"subbasins.geoparquet\")\nfolium.GeoJson(subbasins, fill_opacity=0, color=\"blue\", weight=2).add_to(m)\nm\n</pre> subbasins = gpd.read_file(model_dir / \"subbasins.geoparquet\") folium.GeoJson(subbasins, fill_opacity=0, color=\"blue\", weight=2).add_to(m) m Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>Although this can be customised, the default behaviour of <code>swmmanywhere</code> is to not allow edges to cross hydrological subbasins. It is now super clear why these unconnected  networks have appeared, and are ultimately due to the underlying DEM. If you did desperately care about these streets, then you should probably widen your bounding box.</p> In\u00a0[6]: Copied! <pre>df = pd.read_parquet(model_dir / \"results.parquet\")\ndf.head()\n</pre> df = pd.read_parquet(model_dir / \"results.parquet\") df.head() Out[6]: date value variable id 0 2000-01-01 00:00:01 0.0 flooding 228_outfall 1 2000-01-01 00:00:01 0.0 flooding 384_outfall 2 2000-01-01 00:00:01 0.0 flooding 385_outfall 3 2000-01-01 00:00:01 0.0 flooding 386_outfall 4 2000-01-01 00:00:01 0.0 flooding 391_outfall <p><code>results</code> contains all simulation results in long format, with <code>flooding</code> at nodes and <code>flow</code> at edges. We will plot a random <code>flow</code>.</p> In\u00a0[7]: Copied! <pre>flows = df.loc[df.variable == \"flow\"]\nflows.loc[flows.id == flows.iloc[0].id].set_index(\"date\").value.plot(\n    ylabel=\"flow (l/s)\"\n)\n</pre> flows = df.loc[df.variable == \"flow\"] flows.loc[flows.id == flows.iloc[0].id].set_index(\"date\").value.plot(     ylabel=\"flow (l/s)\" ) Out[7]: <pre>&lt;Axes: xlabel='date', ylabel='flow (l/s)'&gt;</pre> <p>If <code>results</code> are present in the <code>model_dir</code>, <code>plot_map</code> will make clickable elements to view plots, now you can inspect your results in a much more elegant way than the SWMM GUI. Just click a node or link to view the flooding or flow timeseries!</p> In\u00a0[8]: Copied! <pre>plot_map(model_dir)\n</pre> plot_map(model_dir) <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field highway: unsupported OGR type: 5\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field maxspeed: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>If we explore around, clicking on edges, we can see that flows are often looking sensible, though we can definitely some areas that have been hampered by our starting street graph (e.g., in the Western portion of Carrer del Sant Andreu in North West we can see negative flows meaning the direction is different from what the topology derivation assumed flow would be going in!). The first suggestion here would be to examine the starting graph, however, if you want to make more sophisticated customisations then your probably want to learn about graph functions.</p>"},{"location":"notebooks/extended_demo/#extended-demo","title":"Extended Demo\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/notebooks . To run this on your local machine, you will need to install the optional dependencies for <code>doc</code>:</p> <p><code>pip install swmmanywhere[doc]</code></p>"},{"location":"notebooks/extended_demo/#introduction","title":"Introduction\u00b6","text":"<p>This script demonstrates a simple use case of <code>swmmanywhere</code>, building on the quickstart example, but including plotting and alterations.</p> <p>Since this is a notebook, we will define <code>config</code> as a dictionary rather than a <code>yaml</code> file, but the same principles apply.</p>"},{"location":"notebooks/extended_demo/#initial-run","title":"Initial run\u00b6","text":"<p>Here we will run the quickstart configuration, keeping everything in a temporary directory.</p>"},{"location":"notebooks/extended_demo/#plotting-output","title":"Plotting output\u00b6","text":"<p>If you do not have a real UDM, the majority of your interpretation will be around the synthesised <code>nodes</code> and <code>edges</code>. These are created in the same directory as the <code>model_file</code>. Let's have a look at them. Note that the <code>outfall</code> that each node drains to is specified in the <code>outfall</code> attribute, we will plot these in red and other nodes in black with the built- in <code>swmmanywhere.utilities.plot_map</code> function.</p>"},{"location":"notebooks/extended_demo/#customising-outputs","title":"Customising outputs\u00b6","text":"<p>Some things stick out on first glance,</p> <ul> <li>Probably we do not need pipes in the hills to the South, these seem to be along pedestrian routes, which can be adjusted with the <code>allowable_networks</code> parameter.</li> <li>We will also remove any types under the <code>omit_edges</code> entry, here you can specify to not allow pipes to cross bridges, tunnels, motorways, etc., however, this is such a small area we probably don't want to restrict things so much.</li> <li>We have far too few outfalls, it seems implausible that so many riverside streets would not have outfalls. Furthermore, there are points that are quite far from the river that have been assigned as outfalls. We can reduce the <code>river_buffer_distance</code> to make nodes nearer the river more likely to be outfalls, but also reduce the <code>outfall_length</code> distance parameter to enable <code>swmmanywhere</code> to more freely select outfalls that are adjacent to the river.</li> </ul> <p>Let's just demonstrate that using the <code>parameter_overrides</code> functionality.</p>"},{"location":"notebooks/extended_demo/#plotting-results","title":"Plotting results\u00b6","text":"<p>Because we have run the model with <code>verbose=True</code> we will also see that a new <code>results</code> file has appeared, which contains all of the simulation results from SWMM.</p>"},{"location":"notebooks/validation_demo/","title":"Network comparison demo","text":"In\u00a0[1]: Copied! <pre># Imports\nfrom __future__ import annotations\n\nimport tempfile\nfrom pathlib import Path\n\nfrom swmmanywhere.defs import copy_test_data\nfrom swmmanywhere.logging import set_verbose\nfrom swmmanywhere.swmmanywhere import swmmanywhere\nfrom swmmanywhere.utilities import plot_map\n\n# Create temporary directory\ntemp_dir = tempfile.TemporaryDirectory(dir=\".\")\nbase_dir = Path(temp_dir.name)\n\n# Make a folder for real data\nreal_dir = base_dir / \"real\"\nreal_dir.mkdir(exist_ok=True)\n\n# Copy test data into the real data folder\ncopy_test_data(real_dir)\n</pre> # Imports from __future__ import annotations  import tempfile from pathlib import Path  from swmmanywhere.defs import copy_test_data from swmmanywhere.logging import set_verbose from swmmanywhere.swmmanywhere import swmmanywhere from swmmanywhere.utilities import plot_map  # Create temporary directory temp_dir = tempfile.TemporaryDirectory(dir=\".\") base_dir = Path(temp_dir.name)  # Make a folder for real data real_dir = base_dir / \"real\" real_dir.mkdir(exist_ok=True)  # Copy test data into the real data folder copy_test_data(real_dir) <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/networkx/readwrite/json_graph/node_link.py:290: FutureWarning: \nThe default value will be changed to `edges=\"edges\" in NetworkX 3.6.\n\nTo make this warning go away, explicitly set the edges kwarg, e.g.:\n\n  nx.node_link_graph(data, edges=\"links\") to preserve current behavior, or\n  nx.node_link_graph(data, edges=\"edges\") for forward compatibility.\n  warnings.warn(\n</pre> In\u00a0[2]: Copied! <pre># Define config\nconfig = {\n    \"base_dir\": base_dir,\n    \"project\": \"bellinge_small\",\n    \"bbox\": [10.309, 55.333, 10.317, 55.339],\n    \"run_settings\": {\"duration\": 3600},\n    \"real\": {\n        \"graph\": real_dir / \"bellinge_small_graph.json\",\n        \"inp\": real_dir / \"bellinge_small.inp\",\n        \"subcatchments\": real_dir / \"bellinge_small_subcatchments.geojson\",\n    },\n    \"parameter_overrides\": {\n        \"topology_derivation\": {\n            \"allowable_networks\": [\"drive\"],\n            \"omit_edges\": [\"bridge\"],\n        }\n    },\n}\n</pre> # Define config config = {     \"base_dir\": base_dir,     \"project\": \"bellinge_small\",     \"bbox\": [10.309, 55.333, 10.317, 55.339],     \"run_settings\": {\"duration\": 3600},     \"real\": {         \"graph\": real_dir / \"bellinge_small_graph.json\",         \"inp\": real_dir / \"bellinge_small.inp\",         \"subcatchments\": real_dir / \"bellinge_small_subcatchments.geojson\",     },     \"parameter_overrides\": {         \"topology_derivation\": {             \"allowable_networks\": [\"drive\"],             \"omit_edges\": [\"bridge\"],         }     }, } In\u00a0[3]: Copied! <pre>## Run SWMManywhere\nset_verbose(True)\noutputs = swmmanywhere(config)\n</pre> ## Run SWMManywhere set_verbose(True) outputs = swmmanywhere(config) <pre>2025/10/10 14:44:00 | Creating project structure.\n</pre> <pre>2025/10/10 14:44:00 | Project structure created at tmp3vc2_b9m\n</pre> <pre>2025/10/10 14:44:00 | Project name: bellinge_small\n</pre> <pre>2025/10/10 14:44:00 | Bounding box: [10.309, 55.333, 10.317, 55.339], \n                number: 1\n</pre> <pre>2025/10/10 14:44:00 | Model number: 1\n</pre> <pre>2025/10/10 14:44:00 | Loading and setting parameters.\n</pre> <pre>2025/10/10 14:44:00 | Setting topology_derivation allowable_networks to ['drive']\n</pre> <pre>2025/10/10 14:44:00 | Setting topology_derivation omit_edges to ['bridge']\n</pre> <pre>2025/10/10 14:44:00 | Allowable networks have been changed, removing old street graph.\n</pre> <pre>2025/10/10 14:44:00 | Running downloads.\n</pre> <pre>2025/10/10 14:44:01 | downloading elevation to tmp3vc2_b9m/bellinge_small/bbox_1/download/elevation.tif\n</pre> <pre>2025/10/10 14:44:04 | downloading buildings to tmp3vc2_b9m/bellinge_small/bbox_1/download/building.geoparquet\n</pre> <pre>2025/10/10 14:44:18 | downloading network to tmp3vc2_b9m/bellinge_small/bbox_1/download/street.parquet\n</pre> <pre>2025/10/10 14:44:20 | downloading river network to tmp3vc2_b9m/bellinge_small/bbox_1/download/river.parquet\n</pre> <pre>2025/10/10 14:44:21 | No water network found within the bounding box.\n</pre> <pre>2025/10/10 14:44:21 | Iterating graphs.\n</pre> <pre>2025/10/10 14:44:21 | Iterating graph functions.\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: remove_non_pipe_allowable_links completed.\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: calculate_streetcover completed.\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: remove_parallel_edges completed.\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: to_undirected completed.\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: split_long_edges completed.\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/networkx/readwrite/json_graph/node_link.py:290: FutureWarning: \nThe default value will be changed to `edges=\"edges\" in NetworkX 3.6.\n\nTo make this warning go away, explicitly set the edges kwarg, e.g.:\n\n  nx.node_link_graph(data, edges=\"links\") to preserve current behavior, or\n  nx.node_link_graph(data, edges=\"edges\") for forward compatibility.\n  warnings.warn(\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: merge_street_nodes completed.\n</pre> <pre>2025/10/10 14:44:21 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:44:26 | graphfcn: clip_to_catchments completed.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: calculate_contributing_area completed.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: set_elevation completed.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: double_directed completed.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: fix_geometries completed.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: set_surface_slope completed.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: set_chahinian_slope completed.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: set_chahinian_angle completed.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: calculate_weights completed.\n</pre> <pre>2025/10/10 14:44:27 | No outfalls found for subgraph containing \n                        186, using this node as outfall.\n</pre> <pre>2025/10/10 14:44:27 | No outfalls found for subgraph containing \n                        88, using this node as outfall.\n</pre> <pre>2025/10/10 14:44:27 | No outfalls found for subgraph containing \n                        104, using this node as outfall.\n</pre> <pre>2025/10/10 14:44:27 | No outfalls found for subgraph containing \n                        123, using this node as outfall.\n</pre> <pre>2025/10/10 14:44:27 | No outfalls found for subgraph containing \n                        161, using this node as outfall.\n</pre> <pre>2025/10/10 14:44:27 | No outfalls found for subgraph containing \n                        176, using this node as outfall.\n</pre> <pre>2025/10/10 14:44:27 | No outfalls found for subgraph containing \n                        213, using this node as outfall.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: identify_outfalls completed.\n</pre> <pre>2025/10/10 14:44:27 | Total graph weight 59.7413491472801.\n</pre> <pre>2025/10/10 14:44:27 | graphfcn: derive_topology completed.\n</pre> <pre>\r  0%|          | 0/147 [00:00&lt;?, ?it/s]</pre> <pre>\r 24%|\u2588\u2588\u258d       | 36/147 [00:00&lt;00:00, 349.34it/s]</pre> <pre>\r 51%|\u2588\u2588\u2588\u2588\u2588     | 75/147 [00:00&lt;00:00, 369.10it/s]</pre> <pre>\r 76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 112/147 [00:00&lt;00:00, 333.46it/s]</pre> <pre>\r 99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 146/147 [00:00&lt;00:00, 280.46it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 147/147 [00:00&lt;00:00, 304.09it/s]</pre> <pre>2025/10/10 14:44:28 | graphfcn: pipe_by_pipe completed.\n</pre> <pre>2025/10/10 14:44:28 | graphfcn: fix_geometries completed.\n</pre> <pre>\n</pre> <pre>2025/10/10 14:44:28 | graphfcn: assign_id completed.\n</pre> <pre>2025/10/10 14:44:28 | Saving final graph and writing inp file.\n</pre> <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> <pre>2025/10/10 14:44:28 | Running the synthetic model.\n</pre> <pre>2025/10/10 14:44:28 | tmp3vc2_b9m/bellinge_small/bbox_1/model_1/model_1.inp initialised in pyswmm\n</pre> <pre>2025/10/10 14:44:28 | Starting simulation for: tmp3vc2_b9m/bellinge_small/bbox_1/model_1/model_1.inp\n</pre> <pre>\r  0%|          | 0/3600 [00:00&lt;?, ?it/s]</pre> <pre>\r 46%|\u2588\u2588\u2588\u2588\u258b     | 1668.0/3600 [00:00&lt;00:00, 16553.21it/s]</pre> <pre>\r 92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 3328.0/3600 [00:00&lt;00:00, 15446.85it/s]</pre> <pre>2025/10/10 14:44:28 | Model run complete.\n</pre> <pre>\r3603.0it [00:00, 14413.28it/s]                          </pre> <pre>2025/10/10 14:44:28 | Writing synthetic results.\n</pre> <pre>2025/10/10 14:44:28 | Running the real model.\n</pre> <pre>2025/10/10 14:44:28 | tmp3vc2_b9m/real/bellinge_small.inp initialised in pyswmm\n</pre> <pre>2025/10/10 14:44:28 | Starting simulation for: tmp3vc2_b9m/real/bellinge_small.inp\n</pre> <pre>\n</pre> <pre>\r  0%|          | 0/3600 [00:00&lt;?, ?it/s]</pre> <pre>2025/10/10 14:44:28 | Model run complete.\n</pre> <pre>\r3603.0it [00:00, 154345.04it/s]         </pre> <pre>2025/10/10 14:44:28 | Iterating metrics.\n</pre> <pre>\n</pre> <pre>2025/10/10 14:44:28 | outfall_nse_flow completed\n</pre> <pre>2025/10/10 14:44:28 | outfall_kge_flow completed\n</pre> <pre>2025/10/10 14:44:28 | outfall_relerror_flow completed\n</pre> <pre>2025/10/10 14:44:28 | outfall_relerror_length completed\n</pre> <pre>2025/10/10 14:44:28 | outfall_relerror_npipes completed\n</pre> <pre>2025/10/10 14:44:28 | outfall_relerror_nmanholes completed\n</pre> <pre>2025/10/10 14:44:28 | outfall_relerror_diameter completed\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/networkx/readwrite/json_graph/node_link.py:290: FutureWarning: \nThe default value will be changed to `edges=\"edges\" in NetworkX 3.6.\n\nTo make this warning go away, explicitly set the edges kwarg, e.g.:\n\n  nx.node_link_graph(data, edges=\"links\") to preserve current behavior, or\n  nx.node_link_graph(data, edges=\"edges\") for forward compatibility.\n  warnings.warn(\n</pre> <pre>2025/10/10 14:44:28 | outfall_nse_flooding completed\n</pre> <pre>2025/10/10 14:44:28 | outfall_kge_flooding completed\n</pre> <pre>2025/10/10 14:44:28 | outfall_relerror_flooding completed\n</pre> <pre>2025/10/10 14:44:28 | grid_nse_flooding completed\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:662: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(func=lambda x: x.set_index(\"date\")[[\"value_syn\"]].interpolate())\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:487: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  val = results.groupby(gb_key).apply(lambda x: coef_func(x.value_real, x.value_syn))\n</pre> <pre>2025/10/10 14:44:28 | grid_kge_flooding completed\n</pre> <pre>2025/10/10 14:44:28 | grid_relerror_flooding completed\n</pre> <pre>2025/10/10 14:44:28 | subcatchment_nse_flooding completed\n</pre> <pre>2025/10/10 14:44:28 | subcatchment_kge_flooding completed\n</pre> <pre>2025/10/10 14:44:29 | subcatchment_relerror_flooding completed\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:662: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(func=lambda x: x.set_index(\"date\")[[\"value_syn\"]].interpolate())\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:487: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  val = results.groupby(gb_key).apply(lambda x: coef_func(x.value_real, x.value_syn))\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:662: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(func=lambda x: x.set_index(\"date\")[[\"value_syn\"]].interpolate())\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:487: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  val = results.groupby(gb_key).apply(lambda x: coef_func(x.value_real, x.value_syn))\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:662: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(func=lambda x: x.set_index(\"date\")[[\"value_syn\"]].interpolate())\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:487: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  val = results.groupby(gb_key).apply(lambda x: coef_func(x.value_real, x.value_syn))\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:662: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(func=lambda x: x.set_index(\"date\")[[\"value_syn\"]].interpolate())\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:487: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  val = results.groupby(gb_key).apply(lambda x: coef_func(x.value_real, x.value_syn))\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:662: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(func=lambda x: x.set_index(\"date\")[[\"value_syn\"]].interpolate())\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:487: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  val = results.groupby(gb_key).apply(lambda x: coef_func(x.value_real, x.value_syn))\n</pre> <pre>2025/10/10 14:44:29 | bias_flood_depth completed\n</pre> <pre>2025/10/10 14:44:29 | kstest_edge_betweenness completed\n</pre> <pre>2025/10/10 14:44:29 | kstest_betweenness completed\n</pre> <pre>2025/10/10 14:44:29 | outfall_kstest_diameters completed\n</pre> <pre>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:1069: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  syn_flooding = extract_var(synthetic_results, \"flooding\").groupby(\"id\").apply(_f)\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:1073: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  real_flooding = extract_var(real_results, \"flooding\").groupby(\"id\").apply(_f)\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/swmmanywhere/metric_utilities.py:1077: RuntimeWarning: divide by zero encountered in scalar divide\n  return (syn_tot - real_tot) / real_tot\n</pre> <pre>2025/10/10 14:44:29 | nc_deltacon0 completed\n</pre> <pre>2025/10/10 14:44:29 | nc_laplacian_dist completed\n</pre> <pre>2025/10/10 14:44:29 | nc_vertex_edge_distance completed\n</pre> <pre>2025/10/10 14:44:29 | Metrics complete\n</pre> In\u00a0[4]: Copied! <pre>## View real data\nplot_map(real_dir)\n</pre> ## View real data plot_map(real_dir) Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>... and we can plot the synthesised network</p> In\u00a0[5]: Copied! <pre>## View output\nmodel_file = outputs[0]\nplot_map(model_file.parent)\n</pre> ## View output model_file = outputs[0] plot_map(model_file.parent) <pre>Skipping field osmid: unsupported OGR type: 1\n</pre> <pre>Skipping field lanes: unsupported OGR type: 5\n</pre> <pre>Skipping field name: unsupported OGR type: 5\n</pre> <pre>Skipping field reversed: unsupported OGR type: 1\n</pre> Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>.. but of course we can see that the two networks do not perfectly line up. So we can't exactly plot our timeseries side-by-side. To quantify this properly we need to draw on SWMManywhere's ability to compare two networks that don't line up, which is done using the <code>metrics</code> output, automatically calculated when <code>real</code> data is provided.</p> In\u00a0[6]: Copied! <pre># View metrics\nmetrics = outputs[1]\nprint(metrics)\n</pre> # View metrics metrics = outputs[1] print(metrics) <pre>{'outfall_nse_flow': np.float64(0.20843705476557417), 'outfall_kge_flow': np.float64(0.05086487444604504), 'outfall_relerror_flow': np.float64(-0.5352576068673963), 'outfall_relerror_length': np.float64(0.05450306902826656), 'outfall_relerror_npipes': np.float64(0.42857142857142855), 'outfall_relerror_nmanholes': np.float64(0.4), 'outfall_relerror_diameter': np.float64(-0.17826086956521758), 'outfall_nse_flooding': inf, 'outfall_kge_flooding': inf, 'outfall_relerror_flooding': inf, 'grid_nse_flooding': nan, 'grid_kge_flooding': nan, 'grid_relerror_flooding': nan, 'subcatchment_nse_flooding': nan, 'subcatchment_kge_flooding': nan, 'subcatchment_relerror_flooding': nan, 'bias_flood_depth': np.float64(inf), 'kstest_edge_betweenness': np.float64(0.90625), 'kstest_betweenness': np.float64(0.5591836734693878), 'outfall_kstest_diameters': np.float64(0.65), 'nc_deltacon0': np.float64(0.0009376553015700077), 'nc_laplacian_dist': np.float64(3.7416573867739413), 'nc_vertex_edge_distance': 0.940766550522648}\n</pre> <p>For more information on using metrics see our metrics guide. To understand how to make use of such information, see our paper for example.</p>"},{"location":"notebooks/validation_demo/#network-comparison-demo","title":"Network comparison demo\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/notebooks . To run this on your local machine, you will need to install the optional dependencies for <code>doc</code>:</p> <p><code>pip install swmmanywhere[doc]</code></p>"},{"location":"notebooks/validation_demo/#introduction","title":"Introduction\u00b6","text":"<p>This script demonstrates how to use SWMManywhere when you have a real network. It shows how to tell SWMManywhere where the necessary data is, and how, when this is provided, a suite of metrics are calculated to compare the real network with the synthesised network.</p> <p>Since this is a notebook, we will define <code>config</code> as a dictionary rather than a <code>yaml</code> file, but the same principles apply.</p>"},{"location":"notebooks/validation_demo/#initial-setup","title":"Initial setup\u00b6","text":"<p>Here we will run one of the Bellinge sub-networks which is provided in the test data. We will keep everything in a temporary directory.</p>"},{"location":"notebooks/validation_demo/#create-config-file","title":"Create config file\u00b6","text":"<p>Below, we update our config file to use new coordinates, and provide the real data. As set out in the schema, a variety of data entries can be provided to describe the real network, all CRS of shapefiles must be in the UTM CRS for the project:</p> <ul> <li><code>graph</code> (essential) - a graph file in JSON format created from <code>nx.node_link_data</code></li> <li><code>subcatchments</code> (essential) - a GeoJSON file with subcatchment outlines, with headings for <code>id</code>, and <code>impervious_area</code> (only needed if calculating the metric, <code>bias_flood_depth</code>).</li> <li><code>inp</code> - an inp file to run the model with, matching the appropriate graph and subcatchments.</li> <li><code>results</code> - a results file to compare the model with.</li> </ul> <p>At least one of <code>results</code> or <code>inp</code> must be provided. If <code>inp</code> is provided then the model will be run and the results compared to the real data, otherwise <code>results</code> will be loaded directly.</p> <p>Note that the need to separately provide a <code>graph</code> and <code>subcatchments</code> will be removed following fixing of this.</p>"},{"location":"notebooks/validation_demo/#run-swmmanywhere","title":"Run SWMManywhere\u00b6","text":"<p>We make the <code>swmmanywhere</code> call as normal, but can observe that there is an additional model run (scroll towards the bottom) where the real model <code>inp</code> is being run and the metrics are shown to have been calculated in the log.</p>"},{"location":"notebooks/validation_demo/#plot-results","title":"Plot results\u00b6","text":"<p>We can plot the real network data and simulation (click on links for flow and nodes for flooding).</p>"},{"location":"paper/paper/","title":"SWMManywhere: Synthesise Urban Drainage Network Models Anywhere in the World","text":"","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#summary","title":"Summary","text":"<p>Urban drainage network models (UDMs) contain pipe and manhole information for drainage networks in urban areas. When driven by precipitation timeseries data, they can be used to simulate the flow of water through the network, which is useful for a variety of purposes, most notably simulating and alleviating pluvial flooding. Despite the clear usefulness of UDMs, they are often not used owing to the difficulty and expense of creating them. This creates a significant gap for users attempting to generate UDMs if they are not able to perform an expensive underground survey. SWMManywhere automates the full workflow of UDM synthesis, from global data acquisition and preprocessing through to hydraulically plausible model generation. No previous expertise with hydraulic modelling is required, only a bounding box is needed, however, users may tune a variety of parameters to better understand UDM synthesis for their case (Dobson et al., 2025)<sup>1</sup>.</p>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#statement-of-need","title":"Statement of need","text":"<p>A variety of literature exists to derive UDMs from GIS data, producing hydraulically feasible models that closely approximate real-world systems (Blumensaat, Wolfram, &amp; Krebs, 2012; Chahinian et al., 2019; Chegini &amp; Li, 2022; Reyes-Silva, Novoa, Helm, &amp; Krebs, 2022)<sup>2</sup> <sup>3</sup> <sup>4</sup> <sup>5</sup>. We identify some key limitations of these approaches, most notably the lack of automatic data acquisition and preprocessing, that all approaches are closed-source to date, and that a key feature of such an approach should be to facilitate extension and customisation. An open-source approach exists for sanitary sewer systems, however it does not provide automatic data acquisition (Sanne, Khurelbaatar, Despot, Afferden, &amp; Friesen, 2024)<sup>6</sup>.</p> <p>SWMManywhere is an open-source Python package designed for the global synthesis of urban drainage networks. SWMManywhere integrates publicly available geospatial data and automates data acquisition and preprocessing, reducing the technical burden on users. Designed for both researchers and practitioners in urban water management, SWMManywhere responds to the limitations of existing methods by providing an end-to-end, open-source, and customisable solution. Although SWMManywhere has been used in research applications (Dobson et al., 2025)<sup>1</sup>, currently missing is a description focussed on the software implementation and key features, which we provide below.</p>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#features","title":"Features","text":"<p>SWMManywhere includes a variety of key features aimed to improve useability and usefulness. A command line interface (CLI) offers a flexible workflow, providing an accessible entry point to using and customising synthesis. Its parameterized design enables detailed sensitivity analyses, allowing users to understand and manage uncertainties inherent in urban drainage modelling (Dobson et al., 2025)<sup>1</sup>. By emphasizing user control, SWMManywhere allows tuning of outputs with parameters to meet local requirements, making it adaptable to a wide range of scenarios. We provide further details on the data and general approach below.</p>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#data","title":"Data","text":"<p>A variety of datasets were selected to enable SWMManywhere to be applied globally, \\autoref{table:table1}.</p> <p>: SWMManywhere data sources. \\label{table:table1}</p> Data Source Description Reference OpenStreetMap (OSM) Provides global street and river data, used to define potential pipe locations and outfall points for drainage networks. (Boeing, 2017; OpenStreetMap contributors, 2017)<sup>9</sup> <sup>10</sup> Google-Microsoft Open Buildings A dataset of global building footprints, used for estimating impervious surfaces essential for runoff calculations. (OpenStreetMap contributors, 2024; VIDA, 2023)<sup>11</sup> <sup>12</sup> NASADEM Provides 30m resolution global digital elevation model (DEM) data to support sub-catchment delineation and slope calculation. (Crippen et al., 2016)<sup>13</sup> <p>These datasets are global in their coverage, and we consider them of sufficient quality in locations that we have tested (Dobson et al., 2025)<sup>1</sup>, however, we urge users to check data in their specific case study.</p>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#approach-and-customisation","title":"Approach and customisation","text":"<p>The core task in SWMManywhere is to begin with a 'starting graph' (e.g., an OSM street graph), refine this graph first into manhole locations and potential pipe locations, eliminate pipes from unnecessary locations, and then dimension the resulting pipe network which is then simulated in the software SWMM using the <code>pyswmm</code> package (McDonnell, Ratliff, Tryby, Wu, &amp; Mullapudi, 2020)<sup>7</sup>. These operations take place in an iterative approach, where each function takes a graph, and returns the transformed graph, thus each operation is referred to as a 'graph function'. The use of graph functions in SWMManywhere enables modular packaging of functions, easy customisation of the approach (e.g., by adding/removing/reordering graph functions), and explicit definition of parameters for each graph function. Explanations for making these customisations are available in the documentation. Ultimately, this customisability facilitates exploring uncertainty in urban drainage modelling in a way that reflects not just the model itself but the model creation process, as is demonstrated in (Dobson et al., 2025)<sup>1</sup>.</p> <p>We visualise the example from the extended demonstration in the documentation to illustrate how changing relatively few parameter values in a strategic way can dramatically change the nature of the synthesised network \\autoref{fig:fig1}.</p> <p></p>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#comparisons-with-real-networks","title":"Comparisons with real networks","text":"<p>Because manhole and pipe locations rarely coincide between a synthetic and survey-derived UDM, direct element-by-element comparisons are infeasible (Chahinian et al., 2019)<sup>3</sup>. SWMManywhere therefore implements a comprehensive suite of metrics mapped to each stage of the synthesis pipeline: system description (e.g., pipe lengths, counts), topological structure (e.g., Laplacian and vertex\u2013edge distances, betweenness distributions), hydraulic design (e.g., diameter and depth statistics), and simulation performance (e.g., outfall flows and network flooding volumes). This multi\u2010tiered approach validates model realism against observed networks and facilitates understanding of where in the SWMManywhere workflow the synthetic and real UDM diverge, thereby transforming UDM synthesis into an explicit, uncertainty\u2010driven workflow.</p>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#outlook","title":"Outlook","text":"<p>While we believe that SWMManywhere is a useful tool it has a variety of current limitations that present an exciting outlook for future research. Key improvements to the overall realism of the approach may be made in the future, in particular,</p> <ul> <li>Based on the findings of a sensitivity analysis (Dobson et al., 2025)<sup>1</sup>, better identification of manhole locations and outfalls will be critical to narrowing uncertainty in simulation outputs and improving realism.</li> <li>Capturing the gradual evolution of a network over time is known to be important in UDM synthesis (Rauch et al., 2017)<sup>8</sup>, and further illustrated by SWMManywhere results (Dobson et al., 2025)<sup>1</sup>. We do not know of a global database that provides the information that would be necessary to capture this, but it may exist in the future or for local applications.</li> </ul>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#acknowledgements","title":"Acknowledgements","text":"<p>BD is funded through the Imperial College Research Fellowship scheme, which also funded the software development. We acknowledge computational resources and support provided by the Imperial College Research Computing Service.</p>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]},{"location":"paper/paper/#references","title":"References","text":"<ol> <li> <p>Dobson, B., Jovanovic, T., Alonso-\u00c1lvarez, D., &amp; Chegini, T. (2025). [SWMManywhere: A Workflow for Generation and Sensitivity Analysis of Synthetic Urban Drainage Models, Anywhere]{.nocase}. Environmental Modelling\\ &amp; Software. https://doi.org/10.1016/j.envsoft.2025.106358 \u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Blumensaat, F., Wolfram, M., &amp; Krebs, P. (2012). Sewer model development under minimum data requirements. Environ. Earth Sci., 65(5), 1427--1437. https://doi.org/10.1007/s12665-011-1146-1 \u21a9</p> </li> <li> <p>Chahinian, N., Delenne, C., Commandr\u00e9, B., Derras, M., Deruelle, L., &amp; Bailly, J.-S. (2019). Automatic mapping of urban wastewater networks based on manhole cover locations. Comput. Environ. Urban Syst., 78(101370), 101370. https://doi.org/10.1016/j.compenvurbsys.2019.101370 \u21a9\u21a9</p> </li> <li> <p>Reyes-Silva, J. D., Novoa, D., Helm, B., &amp; Krebs, P. (2022). An evaluation framework for urban pluvial flooding based on open-access data. Water (Basel), 15(1), 46. https://doi.org/10.3390/w15010046 \u21a9</p> </li> <li> <p>Chegini, T., &amp; Li, H.-Y. (2022). An algorithm for deriving the topology of belowground urban stormwater networks. Hydrol. Earth Syst. Sci., 26(16), 4279--4300. https://doi.org/10.5194/hess-26-4279-2022 \u21a9</p> </li> <li> <p>Sanne, M., Khurelbaatar, G., Despot, D., Afferden, M. van, &amp; Friesen, J. (2024). Pysewer: A python library for sewer network generation in data scarce regions. Journal of Open Source Software, 9(104), 6430. https://doi.org/10.21105/joss.06430 \u21a9</p> </li> <li> <p>McDonnell, B. E., Ratliff, K., Tryby, M. E., Wu, J. J. X., &amp; Mullapudi, A. (2020). PySWMM: The python interface to stormwater management model (SWMM). Journal of Open Source Software, 5(52), 1. https://doi.org/10.21105/joss.02292 \u21a9</p> </li> <li> <p>Rauch, W., Urich, C., Bach, P. M., Rogers, B. C., Haan, F. J. de, Brown, R. R., ... Deletic, A. (2017). Modelling transitions in urban water systems. Water Res., 126, 501--514. https://doi.org/10.1016/j.watres.2017.09.039 \u21a9</p> </li> <li> <p>Boeing, G. (2017). [OSMnx: New methods for acquiring, constructing, analyzing, and visualizing complex street networks]{.nocase}. Computers, Environment and Urban Systems, 65, 126--139. https://doi.org/10.1016/j.compenvurbsys.2017.05.004 \u21a9</p> </li> <li> <p>OpenStreetMap contributors. (2017). [Planet dump retrieved from https://planet.osm.org ]{.nocase}. https://www.openstreetmap.org{.uri}.\u00a0\u21a9</p> </li> <li> <p>OpenStreetMap contributors. (2024). Overture Maps Foundation. https://overturemaps.org/{.uri}.\u00a0\u21a9</p> </li> <li> <p>VIDA. (2023). Google-Microsoft Open Buildings. Retrieved from https://beta.source.coop/repositories/vida/google-microsoft-open-buildings \u21a9</p> </li> <li> <p>Crippen, R., Buckley, S., Agram, P., Belz, E., Gurrola, E., Hensley, S., ... Tung, W. (2016). NASADEM GLOBAL ELEVATION MODEL: METHODS AND PROGRESS. The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, XLI-B4, 125--128. https://doi.org/10.5194/isprs-archives-XLI-B4-125-2016 \u21a9</p> </li> </ol>","tags":["python","stormwater","hydrology-stormwater-analysis","swmm5","swmm","hydraulic-modelling"]}]}